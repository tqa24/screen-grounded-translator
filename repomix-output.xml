<files>
This section contains the contents of the repository's files.

<file path=".cargo/config.toml">
[build]
# Optimize compilation
rustflags = [
    "-Z", "location-detail=none",
    "-C", "target-cpu=native"
]
</file>

<file path="app.rc">
id ICON "assets/app.ico"

1 VERSIONINFO
FILEVERSION 3,5,1,0
PRODUCTVERSION 3,5,1,0
BEGIN
  BLOCK "StringFileInfo"
  BEGIN
    BLOCK "040904E4"
    BEGIN
      VALUE "CompanyName", "nganlinh4 - Open Source Developer"
      VALUE "FileDescription", "Screen Goated Toolbox - AI-powered screen capture and productivity tool. Open source on GitHub."
      VALUE "FileVersion", "3.5.1.0"
      VALUE "InternalName", "screen-goated-toolbox"
      VALUE "LegalCopyright", "Copyright (c) 2024-2025 nganlinh4. MIT License. https://github.com/nganlinh4/screen-goated-toolbox"
      VALUE "OriginalFilename", "ScreenGoatedToolbox.exe"
      VALUE "ProductName", "Screen Goated Toolbox (SGT)"
      VALUE "ProductVersion", "3.5.1.0"
    END
  END
  BLOCK "VarFileInfo"
  BEGIN
    VALUE "Translation", 0x409, 1252
  END
END
</file>

<file path="docs/WEBVIEW2_INITIALIZATION.md">
# WebView2 Initialization on Windows - Critical Notes

## The Problem

WebView2 (`wry` crate) creation can hang indefinitely on Windows when:
1. Called from deeply nested spawned threads
2. Called without proper warmup of the WebView2 infrastructure

## Root Cause

WebView2 requires the first `WebViewBuilder::build_as_child()` call to happen in a specific context:
- Thread spawned **directly from the main thread** 
- With a proper message loop running
- Window styles matching: `WS_EX_TOPMOST | WS_EX_TOOLWINDOW | WS_EX_LAYERED` (NO `WS_EX_NOACTIVATE`)
- Base style: `WS_POPUP` (NO `WS_CLIPCHILDREN`)

When the first WebView is created from a thread that was spawned several levels deep in the call stack (e.g., hotkey handler ‚Üí capture thread ‚Üí process thread ‚Üí result window thread), the WebView2 controller initialization hangs at `CreateCoreWebView2Controller`.

## The Solution: Warmup Pattern

Follow the same pattern as `text_input.rs`:

1. **Call warmup at app startup** (in `main.rs`):
```rust
overlay::result::markdown_view::warmup();
```

2. **Warmup spawns a dedicated thread** from the main thread context:
```rust
pub fn warmup() {
    std::thread::spawn(|| {
        warmup_internal();
    });
}
```

3. **Create a hidden window with WebView** in that thread:
```rust
fn warmup_internal() {
    // Create hidden window
    let hwnd = CreateWindowExW(
        WS_EX_TOPMOST | WS_EX_TOOLWINDOW | WS_EX_LAYERED,
        class_name,
        w!("MarkdownWarmup"),
        WS_POPUP,
        0, 0, 100, 100,
        None, None, instance, None
    );
    
    // Make transparent
    SetLayeredWindowAttributes(hwnd, COLORREF(0), 0, LWA_ALPHA);
    
    // Create WebView - this "warms up" the WebView2 infrastructure
    let result = WebViewBuilder::new()
        .with_bounds(...)
        .with_html("<html><body>Warmup</body></html>")
        .with_transparent(false)
        .build_as_child(&wrapper);
    
    // Run message loop forever to keep thread alive
    while GetMessageW(&mut msg, None, 0, 0).into() {
        TranslateMessage(&msg);
        DispatchMessageW(&msg);
    }
}
```

4. **After warmup succeeds**, all subsequent WebView2 creations work - even from deeply nested threads!

## Why This Works

The first WebView2 creation initializes the shared WebView2 runtime infrastructure. Once initialized from a "good" thread context (spawned directly from main), all other threads can successfully create WebViews.

## Window Style Requirements for WebView2

| Style | Required for WebView2 |
|-------|----------------------|
| `WS_EX_NOACTIVATE` | ‚ùå AVOID - blocks initialization |
| `WS_CLIPCHILDREN` | ‚ùå AVOID - can interfere |
| `WS_EX_LAYERED` | ‚úÖ OK |
| `WS_EX_TOOLWINDOW` | ‚úÖ OK |
| `WS_EX_TOPMOST` | ‚úÖ OK |
| `WS_POPUP` | ‚úÖ Use as base style |

## Debug Tips

If WebView creation hangs:
1. Check if `[WARMUP] WebView created successfully!` appears at startup
2. If not, the warmup itself is failing
3. Add `eprintln!` at each step to find where it hangs
4. The typical hang point is Step 6 (`build_as_child()`)

## Related Files

- `src/overlay/result/markdown_view.rs` - Contains `warmup()` function
- `src/overlay/text_input.rs` - Reference implementation that works
- `src/main.rs` - Where warmup is called

---
*This issue was debugged in December 2024. The fix involved extensive investigation of thread spawning hierarchies, window styles, and COM initialization.*
</file>

<file path="installer.nsi">
; Screen Goated Toolbox Installer
!include "MUI2.nsh"
!include "x64.nsh"

; Basic Settings
Name "Screen Goated Toolbox"
OutFile "target\release\screen-goated-toolbox-installer.exe"
InstallDir "$PROGRAMFILES\ScreenGoatedToolbox"
RequestExecutionLevel admin
Icon ".\assets\app.ico"

; MUI Settings
!insertmacro MUI_PAGE_WELCOME
!insertmacro MUI_PAGE_DIRECTORY
!insertmacro MUI_PAGE_INSTFILES
!insertmacro MUI_PAGE_FINISH

!insertmacro MUI_LANGUAGE "English"

; Installer Sections
Section "Install Application"
  SetOutPath "$INSTDIR"
  
  ; Copy main executable
  File "target\release\screen-goated-toolbox.exe"
  
  ; Copy Visual C++ Runtime and install it
  File "vc_redist.x64.exe"
  DetailPrint "Installing Visual C++ Runtime..."
  ExecWait "$INSTDIR\vc_redist.x64.exe /quiet /norestart" $0
  Delete "$INSTDIR\vc_redist.x64.exe"
  
  ; Create Start Menu shortcut
  CreateDirectory "$SMPROGRAMS\Screen Goated Toolbox"
  CreateShortcut "$SMPROGRAMS\Screen Goated Toolbox\Screen Goated Toolbox.lnk" "$INSTDIR\screen-goated-toolbox.exe"
  CreateShortcut "$SMPROGRAMS\Screen Goated Toolbox\Uninstall.lnk" "$INSTDIR\uninstall.exe"
  
  ; Create Desktop shortcut (optional, uncomment if desired)
  ; CreateShortcut "$DESKTOP\Screen Goated Toolbox.lnk" "$INSTDIR\screen-goated-toolbox.exe"
  
  ; Write uninstaller
  WriteUninstaller "$INSTDIR\uninstall.exe"
  
  ; Write registry entry for Add/Remove Programs
  WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\ScreenGoatedToolbox" "DisplayName" "Screen Goated Toolbox"
  WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\ScreenGoatedToolbox" "UninstallString" "$INSTDIR\uninstall.exe"
  WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\ScreenGoatedToolbox" "InstallLocation" "$INSTDIR"
  WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\ScreenGoatedToolbox" "DisplayVersion" "1.6"
SectionEnd

; Uninstaller Section
Section "Uninstall"
  Delete "$INSTDIR\screen-goated-toolbox.exe"
  Delete "$INSTDIR\uninstall.exe"
  RMDir "$INSTDIR"
  
  Delete "$SMPROGRAMS\Screen Goated Toolbox\Screen Goated Toolbox.lnk"
  Delete "$SMPROGRAMS\Screen Goated Toolbox\Uninstall.lnk"
  RMDir "$SMPROGRAMS\Screen Goated Toolbox"
  
  Delete "$DESKTOP\Screen Goated Toolbox.lnk"
  
  DeleteRegKey HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\ScreenGoatedToolbox"
SectionEnd
</file>

<file path="README.md">
# Screen Goated Toolbox (SGT)

A powerful Windows utility that captures any region of your screen **or records system/microphone audio** and processes it using advanced AI models. Whether you need to translate text, extract code (OCR), summarize content, get image descriptions, **or transcribe meetings**, SGT handles it with customizable presets and global hotkeys.

## Key Features

- **Multi-Modal Support:** Utilize **Groq** (Llama 4, Whisper, GPT-OSS) or **Google Gemini** (Flash, Pro) for Vision, Text, and Audio processing.
- **Audio Intelligence:** Record and transcribe/translate audio from your **Microphone** or **System Sound** (Device Audio/Loopback).
- **Preset System:** Create unlimited custom profiles (e.g., "Translate Image", "Transcribe Meeting", "Quick 4NR reply").
- **Advanced Hotkeys:** Assign custom key combinations (e.g., `Ctrl+Alt+T`, `Win+Shift+S`) to specific presets.
- **Retranslation Pipeline:** Chain models (e.g., Vision/Audio -> Text Model) for higher accuracy.
- **Smart Overlay:**
  - Streaming text support (Typewriter effect).
  - Auto-copy to clipboard.
  - "Broom" cursor for precise selection.
  - Linked windows for dual-view.
- **Usage Statistics:** Monitor your API usage limits directly in the app.
- **Localization:** UI available in English, Vietnamese, and Korean.

## Screenshot

![Screenshot](docs/images/screenshot.png)
![Demo Video](docs/images/demo-video.gif)

## Prerequisites

- **OS:** Windows 10 or Windows 11.
- **API Keys:**
  - **Groq:** [Get a free key here](https://console.groq.com/keys) (Required for Llama, Whisper, & GPT-OSS models).
  - **Google Gemini:** [Get a free key here](https://aistudio.google.com/app/apikey) (Required for Gemini Vision & Audio models).

### Build Prerequisites (if building from source)
- **Rust Nightly:** [Install from rustup](https://rustup.rs/), then run `rustup default nightly`.
- **Visual Studio Build Tools 2022:** [Download here](https://visualstudio.microsoft.com/downloads/) and install with "Desktop development with C++" workload.
- **MinGW-w64 with windres:** [Download from here](https://github.com/niXman/mingw-builds-binaries/releases), extract to `C:\mingw-w64`, and add `C:\mingw-w64\mingw64\bin` to your system PATH.

## Installation

### Option 1: Download Release
Download the latest `.exe` from the [Releases](https://github.com/nganlinh4/screen-goated-toolbox/releases) page.

### Option 2: Build from Source
Ensure [Rust](https://www.rust-lang.org/tools/install) is installed.

```bash
git clone https://github.com/nganlinh4/screen-goated-toolbox
cd screen-goated-toolbox

# Setup patched egui-snarl (required before building)
powershell -ExecutionPolicy Bypass -File scripts/setup-egui-snarl.ps1

# The build script will handle icon resource embedding automatically
cargo build --release
```

Run the executable found in `target/release/`.

## Getting Started

1. **Launch the App:** Open `screen-goated-toolbox.exe`.
2. **Global Settings:**
   - Paste your **Groq API Key** and/or **Gemini API Key**.
   - Toggle **Run at Windows Startup** if desired.
3. **Configure a Preset:**
   - Select a preset on the left or create a new one.
   - **Type:** Choose `Image Understanding` or `Audio Understanding`.
   - **Prompt:** Define the AI instruction (e.g., "Translate to {language1}").
   - **Model:** Select your preferred model (e.g., `Llama 4 Scout`, `Gemini Flash`, `Whisper`).
   - **Hotkeys:** Click "Add Key" to assign a shortcut.
4. **Capture:**
   - **Image:** Press hotkey -> Drag to select area -> Result appears in overlay.
   - **Audio:** Press hotkey -> Recording overlay appears -> Press hotkey again to finish.

## Configuration Guide

### Preset Types
* **Image Understanding:** Captures a screen region (OCR, Translation, Description).
* **Audio Understanding:** Records audio from **Mic** or **Device** (System Audio). Useful for meetings, videos, or quick voice commands.
* **Video Understanding:** (Upcoming feature).

### Retranslation (Pipeline)
For higher quality results, SGT can chain models:
1. **Extraction:** Vision/Audio model extracts raw text/transcript.
2. **Retranslation:** A specialized Text model (e.g., `GPT-OSS`, `Kimi`, `Gemini`) translates/refines the output.

### Available Models

**Vision Models (Image):**
* `Scout` (Llama 4 Scout 17B) - Extremely fast, good for general text.
* `Maverick` (Llama 4 Maverick 17B) - Highly accurate instruction following.
* `Gemini Flash Lite` (Google) - Efficient and fast.
* `Gemini Flash` (Google) - Balanced performance.
* `Gemini 2.5 Pro` (Google) - Highest accuracy, best for reasoning.

**Audio Models (Speech):**
* `Whisper Fast` (Large v3 Turbo) - Fast transcription via Groq.
* `Whisper Accurate` (Large v3) - High accuracy transcription via Groq.
* `Gemini Audio` (Flash Lite / Flash / 2.5 Pro) - Native multimodal audio understanding (can summarize/translate directly).

**Text Models (Retranslation):**
* `Fast Text` (GPT-OSS 20B) - Super fast.
* `Fast 120B` (GPT-OSS 120B) - Balanced speed/quality.
* `Accurate` (Kimi k2-instruct) - High quality Chinese/English handling.
* `Quick Search` (Groq Compound Mini) - **NEW!** Search the web quickly for answers.
* `Deep Search` (Groq Compound) - **NEW!** Comprehensive web search with detailed sources.
* `Gemini Text` (Flash Lite / Flash / 2.5 Pro) - Google's text capabilities.

## Troubleshooting

**Hotkey conflict / Not working:**
* If using the app in games or elevated applications, **run SGT as Administrator**.
* Check for conflicts with other apps.

**"NO_API_KEY" Error:**
* Ensure keys are entered in "Global Settings".
* Verify the selected preset uses a model matching the provider key you entered (Groq vs Google).

**Audio Recording Issues:**
* Ensure your default microphone or output device is active in Windows Sound Settings.
* If recording "Device Audio", play some sound to ensure the loopback stream has data.

## License

MIT ‚Äî See [LICENSE](LICENSE) file.

## Credits

Developed by **nganlinh4**.
* Powered by [Groq](https://groq.com) and [Google DeepMind](https://deepmind.google/technologies/gemini/).
* Built with [Rust](https://www.rust-lang.org/) and [egui](https://github.com/emilk/egui).
</file>

<file path="scripts/setup-egui-snarl.ps1">
# Setup script for patched egui-snarl
# This clones egui-snarl and patches it for scroll-to-zoom support

$snarlDir = Join-Path $PSScriptRoot "..\libs\egui-snarl"
$patchFile = Join-Path $PSScriptRoot "egui-snarl-scroll-zoom.patch"

# Check if already set up
if (Test-Path $snarlDir) {
    Write-Host "egui-snarl already exists at $snarlDir"
    Write-Host "To re-patch, delete the folder and run this script again."
    exit 0
}

# Clone egui-snarl (latest version)
Write-Host "Cloning egui-snarl..."
git clone --depth 1 https://github.com/zakarumych/egui-snarl.git $snarlDir

if (-not (Test-Path $snarlDir)) {
    Write-Error "Failed to clone egui-snarl"
    exit 1
}

# Apply the patch
Write-Host "Applying scroll-to-zoom patch..."

# Read the ui.rs file
$uiRsPath = Join-Path $snarlDir "src\ui.rs"
$content = Get-Content $uiRsPath -Raw

# The original code we're replacing (Scene::register_pan_and_zoom)
$originalCode = @"
    clamp_scale(&mut to_global, min_scale, max_scale, ui_rect);

    let mut snarl_resp = ui.response();
    Scene::new()
        .zoom_range(min_scale..=max_scale)
        .register_pan_and_zoom(&ui, &mut snarl_resp, &mut to_global);

    if snarl_resp.changed() {
        ui.ctx().request_repaint();
    }
"@

# The patched code (scroll-to-zoom without Ctrl + double-click reset + external reset trigger)
$patchedCode = @"
    clamp_scale(&mut to_global, min_scale, max_scale, ui_rect);

    let mut snarl_resp = ui.response();
    
    // CUSTOM SCROLL-TO-ZOOM: Instead of using Scene::register_pan_and_zoom which uses Ctrl+scroll for zoom,
    // we manually handle scroll as zoom directly (no Ctrl required)
    
    // Disable native double-click centering to prevent it from overriding our custom reset logic
    style.centering = Some(false);

    {
        let scroll_delta = ui.ctx().input(|i| i.raw_scroll_delta);
        let zoom_delta = ui.ctx().input(|i| i.zoom_delta());
        let pointer_in_canvas = ui.ctx().input(|i| {
            i.pointer.hover_pos().map(|pos| ui_rect.contains(pos)).unwrap_or(false)
        });
        
        // Check for external reset request (set by application code via egui context data)
        let reset_id = egui::Id::new("snarl_reset_view");
        let should_reset = ui.ctx().data_mut(|d| {
            let reset = d.get_temp::<bool>(reset_id).unwrap_or(false);
            if reset {
                d.insert_temp(reset_id, false); // Clear the flag
            }
            reset
        });
        
        // Reset view on double-click OR external reset request
        let double_clicked = snarl_resp.double_clicked();
        if (double_clicked && pointer_in_canvas) || should_reset {
            to_global.scaling = 1.0;
            
            // "Fit View" - Center the nodes in the viewport
            let mut min_pos = egui::pos2(f32::INFINITY, f32::INFINITY);
            let mut max_pos = egui::pos2(f32::NEG_INFINITY, f32::NEG_INFINITY);
            let mut has_nodes = false;
            
            for (pos, _) in snarl.nodes_pos() {
                has_nodes = true;
                if pos.x < min_pos.x { min_pos.x = pos.x; }
                if pos.y < min_pos.y { min_pos.y = pos.y; }
                
                // Assume generic node size approx 200x150 for centering
                let right = pos.x + 200.0;
                let bottom = pos.y + 150.0;
                
                if right > max_pos.x { max_pos.x = right; }
                if bottom > max_pos.y { max_pos.y = bottom; }
            }
            
            if has_nodes {
                 let graph_center = min_pos.lerp(max_pos, 0.5);
                 // Center the graph content
                 to_global.translation = ui_rect.center().to_vec2() - graph_center.to_vec2();
            } else {
                 // Fallback if no nodes (center origin logic)
                 to_global.translation = ui_rect.center().to_vec2();
            }
            
            snarl_resp.mark_changed();
        }
        
        // Check if any popup is open (ComboBox dropdowns, context menus, etc.)
        // If a popup is open, we should NOT capture scroll, let the popup handle it
        let any_popup_open = egui::Popup::is_any_open(ui.ctx());
        
        // Check if pointer is over a higher layer (Modal windows, Panels, etc.)
        // Only capture scroll if the pointer is on the Background layer (the canvas itself)
        let pointer_on_foreground = if let Some(pos) = ui.ctx().input(|i| i.pointer.hover_pos()) {
            if let Some(layer_id) = ui.ctx().layer_id_at(pos) {
                // Background order is 0, anything higher means a window/panel/modal is above
                layer_id.order != egui::Order::Background && layer_id.order != egui::Order::Middle
            } else {
                false
            }
        } else {
            false
        };
        
        // Handle scroll wheel as zoom (not pan) - works anywhere in the canvas, including over nodes
        // BUT skip if a popup is open OR pointer is over a modal/window so they can scroll properly
        if scroll_delta.y.abs() > 0.1 && pointer_in_canvas && !any_popup_open && !pointer_on_foreground {
            let zoom_factor = if scroll_delta.y > 0.0 { 1.1 } else { 0.9 };
            let pointer_pos = ui.ctx().input(|i| i.pointer.hover_pos()).unwrap_or(ui_rect.center());
            
            // Apply zoom centered on pointer position
            let new_scale = (to_global.scaling * zoom_factor).clamp(min_scale, max_scale);
            if new_scale != to_global.scaling {
                // Zoom towards the pointer: adjust translation so pointer stays at same graph position
                let scale_ratio = new_scale / to_global.scaling;
                to_global.translation = pointer_pos.to_vec2() + (to_global.translation - pointer_pos.to_vec2()) * scale_ratio;
                to_global.scaling = new_scale;
                snarl_resp.mark_changed();
            }
        }
        
        // Also handle pinch zoom gestures (zoom_delta from touch)
        if zoom_delta != 1.0 && pointer_in_canvas {
            let pointer_pos = ui.ctx().input(|i| i.pointer.hover_pos()).unwrap_or(ui_rect.center());
            let new_scale = (to_global.scaling * zoom_delta).clamp(min_scale, max_scale);
            if new_scale != to_global.scaling {
                let scale_ratio = new_scale / to_global.scaling;
                to_global.translation = pointer_pos.to_vec2() + (to_global.translation - pointer_pos.to_vec2()) * scale_ratio;
                to_global.scaling = new_scale;
                snarl_resp.mark_changed();
            }
        }
        
        // Handle drag for panning (left mouse button, middle mouse button, or right mouse button)
        if snarl_resp.dragged_by(PointerButton::Primary) || snarl_resp.dragged_by(PointerButton::Middle) || snarl_resp.dragged_by(PointerButton::Secondary) {
            to_global.translation += snarl_resp.drag_delta();
            snarl_resp.mark_changed();
        }
    }

    if snarl_resp.changed() {
        ui.ctx().request_repaint();
    }
"@

# Replace the code
$newContent = $content -replace [regex]::Escape($originalCode), $patchedCode

if ($newContent -eq $content) {
    Write-Warning "Could not find the exact code to patch. egui-snarl may have updated."
    Write-Warning "Please check libs/egui-snarl/src/ui.rs manually around line 989."
    exit 1
}

# Also remove unused Scene import to avoid warning
$newContent = $newContent -replace "Pos2, Rect, Scene, Sense,", "Pos2, Rect, Sense,"

# Write the patched file
Set-Content -Path $uiRsPath -Value $newContent -NoNewline

Write-Host "Patch applied successfully!"
Write-Host "egui-snarl is ready at: $snarlDir"
</file>

<file path="src/api/client.rs">
use lazy_static::lazy_static;
use std::time::Duration;
lazy_static! {
</file>

<file path="src/api/mod.rs">
pub mod types;
pub mod client;
pub mod vision;
pub mod audio;
pub mod text;
pub mod realtime_audio;
pub mod ollama;
pub mod tts;
pub use vision::translate_image_streaming;
‚ãÆ----
pub use audio::record_audio_and_transcribe;
</file>

<file path="src/api/ollama.rs">
use anyhow::Result;
‚ãÆ----
use serde::Deserialize;
use super::client::UREQ_AGENT;
use crate::gui::locale::LocaleText;
‚ãÆ----
pub struct OllamaStreamChunk {
‚ãÆ----
pub struct OllamaGenerateResponse {
‚ãÆ----
pub struct OllamaModel {
‚ãÆ----
pub struct OllamaTagsResponse {
‚ãÆ----
pub struct OllamaModelWithCaps {
‚ãÆ----
struct OllamaShowResponse {
‚ãÆ----
struct OllamaModelDetails {
‚ãÆ----
pub fn fetch_ollama_models(base_url: &str) -> Result<Vec<OllamaModel>> {
let url = format!("{}/api/tags", base_url.trim_end_matches('/'));
let resp = UREQ_AGENT.get(&url)
.call()
.map_err(|e| anyhow::anyhow!("Failed to connect to Ollama: {}", e))?;
let tags: OllamaTagsResponse = resp.into_body().read_json()
.map_err(|e| anyhow::anyhow!("Failed to parse Ollama response: {}", e))?;
Ok(tags.models)
‚ãÆ----
fn check_model_has_vision(base_url: &str, model_name: &str) -> bool {
let url = format!("{}/api/show", base_url.trim_end_matches('/'));
‚ãÆ----
let resp = match UREQ_AGENT.post(&url)
.send_json(&payload) {
‚ãÆ----
if let Ok(show_resp) = resp.into_body().read_json::<OllamaShowResponse>() {
let families_str = show_resp.details.families.join(" ").to_lowercase();
if families_str.contains("clip") || families_str.contains("vision") {
‚ãÆ----
let modelfile_lower = show_resp.modelfile.to_lowercase();
if modelfile_lower.contains("projector") || modelfile_lower.contains("vision") {
‚ãÆ----
let name_lower = model_name.to_lowercase();
if name_lower.contains("vision") || name_lower.contains("-vl") ||
name_lower.contains("llava") || name_lower.contains("bakllava") ||
name_lower.contains("moondream") || name_lower.contains("minicpm-v") {
‚ãÆ----
pub fn fetch_ollama_models_with_caps(base_url: &str) -> Result<Vec<OllamaModelWithCaps>> {
let models = fetch_ollama_models(base_url)?;
‚ãÆ----
let has_vision = check_model_has_vision(base_url, &model.name);
result.push(OllamaModelWithCaps {
‚ãÆ----
Ok(result)
‚ãÆ----
pub fn ollama_generate_text<F>(
‚ãÆ----
let url = format!("{}/api/generate", base_url.trim_end_matches('/'));
‚ãÆ----
let resp = UREQ_AGENT.post(&url)
.send_json(&payload)
.map_err(|e| anyhow::anyhow!("Ollama API Error: {}", e))?;
‚ãÆ----
let reader = BufReader::new(resp.into_body().into_reader());
‚ãÆ----
for line in reader.lines() {
‚ãÆ----
if line.is_empty() { continue; }
‚ãÆ----
if !thinking.is_empty() && !thinking_shown && !content_started {
on_chunk(locale.model_thinking);
‚ãÆ----
if !chunk.response.is_empty() {
‚ãÆ----
full_content.push_str(&chunk.response);
let wipe_content = format!("{}{}", crate::api::WIPE_SIGNAL, full_content);
on_chunk(&wipe_content);
‚ãÆ----
on_chunk(&chunk.response);
‚ãÆ----
let ollama_resp: OllamaGenerateResponse = resp.into_body().read_json()
‚ãÆ----
on_chunk(&full_content);
‚ãÆ----
Ok(full_content)
‚ãÆ----
pub fn ollama_generate_vision<F>(
‚ãÆ----
image.write_to(&mut Cursor::new(&mut image_data), image::ImageFormat::Png)?;
let b64_image = general_purpose::STANDARD.encode(&image_data);
‚ãÆ----
.map_err(|e| anyhow::anyhow!("Ollama Vision API Error: {}", e))?;
</file>

<file path="src/api/realtime_audio/utils.rs">
use std::sync::Mutex;
‚ãÆ----
pub fn update_overlay_text(hwnd: HWND, text: &str) {
if let Ok(mut display) = REALTIME_DISPLAY_TEXT.lock() {
*display = text.to_string();
‚ãÆ----
let _ = PostMessageW(Some(hwnd), WM_REALTIME_UPDATE, WPARAM(0), LPARAM(0));
‚ãÆ----
pub fn update_translation_text(hwnd: HWND, text: &str) {
if let Ok(mut display) = TRANSLATION_DISPLAY_TEXT.lock() {
‚ãÆ----
let _ = PostMessageW(Some(hwnd), WM_TRANSLATION_UPDATE, WPARAM(0), LPARAM(0));
‚ãÆ----
pub fn refresh_transcription_window() {
‚ãÆ----
if !realtime_hwnd.is_invalid() {
let _ = PostMessageW(Some(realtime_hwnd), WM_REALTIME_UPDATE, WPARAM(0), LPARAM(0));
</file>

<file path="src/api/realtime_audio/websocket.rs">
use anyhow::Result;
‚ãÆ----
use std::net::TcpStream;
use std::time::Duration;
use super::REALTIME_MODEL;
pub fn connect_websocket(
‚ãÆ----
let ws_url = format!(
‚ãÆ----
.host_str()
.ok_or_else(|| anyhow::anyhow!("No host in URL"))?;
‚ãÆ----
use std::net::ToSocketAddrs;
let addr = format!("{}:{}", host, port)
.to_socket_addrs()?
.next()
.ok_or_else(|| anyhow::anyhow!("Failed to resolve hostname: {}", host))?;
‚ãÆ----
tcp_stream.set_read_timeout(Some(Duration::from_secs(30)))?;
tcp_stream.set_write_timeout(Some(Duration::from_secs(30)))?;
tcp_stream.set_nodelay(true)?;
‚ãÆ----
let tls_stream = connector.connect(host, tcp_stream)?;
‚ãÆ----
Ok(socket)
‚ãÆ----
pub fn set_socket_nonblocking(
‚ãÆ----
let stream = socket.get_mut();
let tcp_stream = stream.get_mut();
tcp_stream.set_read_timeout(Some(Duration::from_millis(50)))?;
Ok(())
‚ãÆ----
pub fn send_setup_message(
‚ãÆ----
let msg_str = setup.to_string();
socket.write(tungstenite::Message::Text(msg_str.into()))?;
socket.flush()?;
‚ãÆ----
pub fn send_audio_chunk(
‚ãÆ----
let mut bytes = Vec::with_capacity(pcm_data.len() * 2);
‚ãÆ----
bytes.extend_from_slice(&sample.to_le_bytes());
‚ãÆ----
let b64_audio = general_purpose::STANDARD.encode(&bytes);
‚ãÆ----
socket.write(tungstenite::Message::Text(msg.to_string().into()))?;
‚ãÆ----
pub fn parse_input_transcription(msg: &str) -> Option<String> {
‚ãÆ----
if let Some(server_content) = json.get("serverContent") {
if let Some(input_transcription) = server_content.get("inputTranscription") {
if let Some(text) = input_transcription.get("text").and_then(|t| t.as_str()) {
return Some(text.to_string());
</file>

<file path="src/api/tts/edge_voices.rs">
use lazy_static::lazy_static;
‚ãÆ----
use std::collections::HashMap;
use std::sync::Mutex;
‚ãÆ----
pub struct EdgeVoice {
‚ãÆ----
pub struct EdgeVoiceCache {
‚ãÆ----
impl Default for EdgeVoiceCache {
fn default() -> Self {
‚ãÆ----
lazy_static! {
‚ãÆ----
pub fn load_edge_voices_async() {
‚ãÆ----
let cache = EDGE_VOICE_CACHE.lock().unwrap();
‚ãÆ----
let mut cache = EDGE_VOICE_CACHE.lock().unwrap();
‚ãÆ----
.header(
‚ãÆ----
.call()
‚ãÆ----
match response.into_body().read_to_string() {
‚ãÆ----
.entry(voice.locale.clone())
.or_insert_with(Vec::new)
.push(voice.clone());
‚ãÆ----
.split('-')
.next()
.unwrap_or(&voice.locale)
.to_lowercase();
‚ãÆ----
.entry(lang_code)
‚ãÆ----
cache.error = Some(format!("Parse error: {}", e));
‚ãÆ----
cache.error = Some(format!("Read error: {}", e));
‚ãÆ----
cache.error = Some(format!("Network error: {}", e));
‚ãÆ----
pub fn get_available_languages() -> Vec<(String, String)> {
‚ãÆ----
if lang_map.contains_key(&lang_code) {
‚ãÆ----
if let Some(dash_pos) = voice.friendly_name.rfind(" - ") {
‚ãÆ----
if let Some(paren_pos) = lang_region.find(" (") {
‚ãÆ----
lang_map.insert(lang_code, lang_only.to_string());
‚ãÆ----
lang_map.insert(lang_code, lang_region.to_string());
‚ãÆ----
let mut languages: Vec<(String, String)> = lang_map.into_iter().collect();
languages.sort_by(|a, b| a.1.cmp(&b.1));
‚ãÆ----
pub fn get_voices_for_language(lang_code: &str) -> Vec<EdgeVoice> {
‚ãÆ----
.get(&lang_code.to_lowercase())
.cloned()
.unwrap_or_default()
</file>

<file path="src/api/tts/instance.rs">
use std::sync::Arc;
use lazy_static::lazy_static;
use super::manager::TtsManager;
lazy_static! {
</file>

<file path="src/api/tts/mod.rs">
pub mod edge_voices;
pub mod instance;
pub mod manager;
pub mod player;
pub mod types;
pub mod utils;
pub mod websocket;
pub mod worker;
pub mod wsola;
pub use instance::TTS_MANAGER;
pub use manager::TtsManager;
pub fn init_tts() {
let manager = TTS_MANAGER.clone();
</file>

<file path="src/api/tts/types.rs">
pub enum AudioEvent {
‚ãÆ----
pub struct QueuedRequest {
‚ãÆ----
pub struct TtsRequest {
</file>

<file path="src/api/tts/utils.rs">
use windows::Win32::Foundation::HWND;
use windows::Win32::Graphics::Gdi::InvalidateRect;
‚ãÆ----
use crate::overlay::result::state::WINDOW_STATES;
pub fn clear_tts_loading_state(hwnd: isize) {
‚ãÆ----
let mut states = WINDOW_STATES.lock().unwrap();
if let Some(state) = states.get_mut(&hwnd) {
‚ãÆ----
let _ = InvalidateRect(Some(HWND(hwnd as *mut std::ffi::c_void)), None, false);
‚ãÆ----
pub fn clear_tts_state(hwnd: isize) {
‚ãÆ----
pub fn get_language_instruction_for_text(
‚ãÆ----
let detected_code = detected.code();
‚ãÆ----
if condition.language_code.eq_ignore_ascii_case(detected_code) {
return Some(condition.instruction.clone());
‚ãÆ----
pub fn get_output_devices() -> Vec<(String, String)> {
‚ãÆ----
let _ = CoInitializeEx(None, COINIT_MULTITHREADED);
‚ãÆ----
if let Ok(collection) = enumerator.EnumAudioEndpoints(eRender, DEVICE_STATE_ACTIVE) {
if let Ok(count) = collection.GetCount() {
‚ãÆ----
if let Ok(device) = collection.Item(i) {
if let Ok(id) = device.GetId() {
let id_str = id.to_string().unwrap_or_default();
let name = if let Ok(_props) = device.OpenPropertyStore(STGM_READ) {
id_str.clone()
‚ãÆ----
devices.push((id_str, name));
</file>

<file path="src/api/tts/websocket.rs">
use anyhow::Result;
‚ãÆ----
use native_tls::TlsStream;
use std::net::TcpStream;
use std::time::Duration;
use tungstenite::WebSocket;
use super::types::TTS_MODEL;
pub fn connect_tts_websocket(api_key: &str) -> Result<WebSocket<TlsStream<TcpStream>>> {
let ws_url = format!(
‚ãÆ----
.host_str()
.ok_or_else(|| anyhow::anyhow!("No host in URL"))?;
‚ãÆ----
use std::net::ToSocketAddrs;
let addr = format!("{}:{}", host, port)
.to_socket_addrs()?
.next()
.ok_or_else(|| anyhow::anyhow!("Failed to resolve hostname: {}", host))?;
‚ãÆ----
tcp_stream.set_read_timeout(Some(Duration::from_secs(30)))?;
tcp_stream.set_write_timeout(Some(Duration::from_secs(30)))?;
tcp_stream.set_nodelay(true)?;
‚ãÆ----
let tls_stream = connector.connect(host, tcp_stream)?;
‚ãÆ----
Ok(socket)
‚ãÆ----
pub fn send_tts_setup(
‚ãÆ----
let mut system_text = "You are a text-to-speech reader. Your ONLY job is to read the user's text out loud, exactly as written, word for word. Do NOT respond conversationally. Do NOT add commentary. Do NOT ask questions. ".to_string();
‚ãÆ----
"Slow" => system_text.push_str("Speak slowly, clearly, and with deliberate pacing. "),
"Fast" => system_text.push_str("Speak quickly, efficiently, and with a brisk pace. "),
_ => system_text.push_str("Simply read the provided text aloud naturally and clearly. "),
‚ãÆ----
if !instructions.trim().is_empty() {
system_text.push_str(" Additional instructions: ");
system_text.push_str(instructions.trim());
system_text.push(' ');
‚ãÆ----
system_text.push_str("Start reading immediately.");
‚ãÆ----
let msg_str = setup.to_string();
socket.write(tungstenite::Message::Text(msg_str.into()))?;
socket.flush()?;
Ok(())
‚ãÆ----
pub fn send_tts_text(socket: &mut WebSocket<TlsStream<TcpStream>>, text: &str) -> Result<()> {
let prompt = format!("[READ ALOUD VERBATIM - START NOW]\n\n{}", text);
‚ãÆ----
socket.write(tungstenite::Message::Text(msg.to_string().into()))?;
‚ãÆ----
pub fn parse_audio_data(msg: &str) -> Option<Vec<u8>> {
‚ãÆ----
if let Some(server_content) = json.get("serverContent") {
if let Some(model_turn) = server_content.get("modelTurn") {
if let Some(parts) = model_turn.get("parts").and_then(|p| p.as_array()) {
‚ãÆ----
if let Some(inline_data) = part.get("inlineData") {
if let Some(data_b64) = inline_data.get("data").and_then(|d| d.as_str())
‚ãÆ----
if let Ok(audio_bytes) = general_purpose::STANDARD.decode(data_b64)
‚ãÆ----
return Some(audio_bytes);
‚ãÆ----
pub fn is_turn_complete(msg: &str) -> bool {
‚ãÆ----
if let Some(turn_complete) = server_content.get("turnComplete") {
if turn_complete.as_bool().unwrap_or(false) {
‚ãÆ----
if let Some(gen_complete) = server_content.get("generationComplete") {
if gen_complete.as_bool().unwrap_or(false) {
</file>

<file path="src/api/tts/worker.rs">
use super::manager::TtsManager;
use super::types::AudioEvent;
‚ãÆ----
use crate::api::client::UREQ_AGENT;
use crate::APP;
use isolang::Language;
pub fn run_socket_worker(manager: Arc<TtsManager>) {
‚ãÆ----
if manager.shutdown.load(Ordering::SeqCst) {
‚ãÆ----
let mut queue = manager.work_queue.lock().unwrap();
while queue.is_empty() && !manager.shutdown.load(Ordering::SeqCst) {
let result = manager.work_signal.wait(queue).unwrap();
‚ãÆ----
queue.pop_front().unwrap()
‚ãÆ----
if request.generation < manager.interrupt_generation.load(Ordering::SeqCst) {
let _ = tx.send(AudioEvent::End);
‚ãÆ----
match APP.lock() {
Ok(app) => app.config.tts_method.clone(),
‚ãÆ----
handle_google_tts(manager.clone(), request, tx);
‚ãÆ----
handle_edge_tts(manager.clone(), request, tx);
‚ãÆ----
Ok(app) => app.config.gemini_api_key.clone(),
‚ãÆ----
if api_key.trim().is_empty() {
eprintln!("TTS: No Gemini API key configured");
‚ãÆ----
clear_tts_loading_state(request.req.hwnd);
clear_tts_state(request.req.hwnd);
‚ãÆ----
let socket_result = connect_tts_websocket(&api_key);
‚ãÆ----
eprintln!("TTS: Failed to connect: {}", e);
‚ãÆ----
let app = APP.lock().unwrap();
let voice = app.config.tts_voice.clone();
let conditions = app.config.tts_language_conditions.clone();
let instruction = get_language_instruction_for_text(&request.req.text, &conditions);
‚ãÆ----
(voice, "Normal".to_string(), instruction)
‚ãÆ----
(voice, app.config.tts_speed.clone(), instruction)
‚ãÆ----
if let Err(e) = send_tts_setup(
‚ãÆ----
language_instruction.as_deref(),
‚ãÆ----
eprintln!("TTS: Failed to send setup: {}", e);
let _ = socket.close(None);
‚ãÆ----
if request.generation < manager.interrupt_generation.load(Ordering::SeqCst)
|| manager.shutdown.load(Ordering::SeqCst)
‚ãÆ----
match socket.read() {
‚ãÆ----
let msg = msg.as_str();
if msg.contains("setupComplete") {
‚ãÆ----
if msg.contains("error") || msg.contains("Error") {
eprintln!("TTS: Setup error: {}", msg);
‚ãÆ----
if let Ok(text) = String::from_utf8(data.to_vec()) {
if text.contains("setupComplete") {
‚ãÆ----
if e.kind() == std::io::ErrorKind::WouldBlock =>
‚ãÆ----
if setup_start.elapsed() > Duration::from_secs(10) {
‚ãÆ----
if let Err(e) = send_tts_text(&mut socket, &request.req.text) {
eprintln!("TTS: Failed to send text: {}", e);
‚ãÆ----
if let Some(audio_data) = parse_audio_data(msg) {
let _ = tx.send(AudioEvent::Data(audio_data));
‚ãÆ----
if is_turn_complete(msg) {
‚ãÆ----
if let Some(audio_data) = parse_audio_data(&text) {
‚ãÆ----
if is_turn_complete(&text) {
‚ãÆ----
eprintln!("TTS: Read error: {}", e);
‚ãÆ----
fn handle_google_tts(
‚ãÆ----
let text = request.req.text.clone();
let lang_code = whatlang::detect_lang(&text).unwrap_or(whatlang::Lang::Eng);
let tl = Language::from_639_3(lang_code.code())
.and_then(|l| l.to_639_1())
.unwrap_or("en");
let url = format!(
‚ãÆ----
let resp = match UREQ_AGENT.get(&url).call() {
‚ãÆ----
.into_body()
.into_reader()
.read_to_end(&mut mp3_data)
.is_err()
‚ãÆ----
match decoder.next_frame() {
‚ãÆ----
for chunk in data.chunks(2) {
‚ãÆ----
all_samples.push(sample);
‚ãÆ----
all_samples.extend_from_slice(&data);
‚ãÆ----
if all_samples.is_empty() {
‚ãÆ----
let resampled = resample_audio(&all_samples, source_sample_rate, 24000);
let mut bytes = Vec::with_capacity(resampled.len() * 2);
‚ãÆ----
bytes.extend_from_slice(&sample.to_le_bytes());
‚ãÆ----
let mut bytes = Vec::with_capacity(all_samples.len() * 2);
‚ãÆ----
for chunk in audio_bytes.chunks(chunk_size) {
‚ãÆ----
let _ = tx.send(AudioEvent::Data(chunk.to_vec()));
‚ãÆ----
fn handle_edge_tts(
‚ãÆ----
let manager_clone = manager.clone();
‚ãÆ----
let mut voice = "en-US-AriaNeural".to_string();
‚ãÆ----
.and_then(|info| Language::from_639_3(info.lang().code()))
‚ãÆ----
voice = config.voice_name.clone();
‚ãÆ----
let connection_id = format!(
‚ãÆ----
let wss_url = format!(
‚ãÆ----
let stream = match std::net::TcpStream::connect(format!("{}:443", host)) {
‚ãÆ----
let tls_stream = match connector.connect(host, stream) {
‚ãÆ----
let (mut socket, _) = match client(&wss_url, tls_stream) {
‚ãÆ----
let request_id = format!(
‚ãÆ----
let config_msg = format!(
‚ãÆ----
if socket.send(Message::Text(config_msg.into())).is_err() {
‚ãÆ----
format!("+{}Hz", pitch)
‚ãÆ----
format!("{}Hz", pitch)
‚ãÆ----
format!("+{}%", rate)
‚ãÆ----
format!("{}%", rate)
‚ãÆ----
.replace('&', "&amp;")
.replace('<', "&lt;")
.replace('>', "&gt;")
.replace('"', "&quot;")
.replace('\'', "&apos;");
let ssml = format!(
‚ãÆ----
let ssml_msg = format!(
‚ãÆ----
if socket.send(Message::Text(ssml_msg.into())).is_err() {
‚ãÆ----
if generation < manager_clone.interrupt_generation.load(Ordering::SeqCst) {
‚ãÆ----
if data.len() >= 2 {
‚ãÆ----
if data.len() > audio_start {
‚ãÆ----
if header.windows(11).any(|w| w == b"Path:audio\r") {
mp3_data.extend_from_slice(&data[audio_start..]);
‚ãÆ----
let text = text.as_str();
if text.contains("Path:turn.end") {
‚ãÆ----
Err(tungstenite::Error::Io(ref e)) if e.kind() == std::io::ErrorKind::WouldBlock => {
‚ãÆ----
if mp3_data.is_empty() {
‚ãÆ----
fn resample_audio(samples: &[i16], from_rate: u32, to_rate: u32) -> Vec<i16> {
‚ãÆ----
return samples.to_vec();
‚ãÆ----
let new_len = (samples.len() as f32 * ratio) as usize;
‚ãÆ----
if src_idx >= samples.len() - 1 {
result.push(samples[src_idx.min(samples.len() - 1)]);
‚ãÆ----
result.push(val as i16);
</file>

<file path="src/api/tts/wsola.rs">
use std::f32;
pub struct WsolaStretcher {
‚ãÆ----
impl WsolaStretcher {
pub fn new(sample_rate: u32) -> Self {
‚ãÆ----
.map(|i| {
‚ãÆ----
0.5 * (1.0 - (2.0 * std::f32::consts::PI * t).cos())
‚ãÆ----
.collect();
‚ãÆ----
fn find_best_offset(&self, input_pos: usize, target_hop: usize) -> usize {
let start = target_hop.saturating_sub(self.search_range);
let end = (target_hop + self.search_range).min(self.input_buffer.len().saturating_sub(self.frame_size + input_pos).saturating_sub(1));
‚ãÆ----
if ref_pos + compare_len > self.input_buffer.len() {
‚ãÆ----
if candidate_pos + compare_len > self.input_buffer.len() {
‚ãÆ----
pub fn stretch(&mut self, input: &[i16], speed_ratio: f64) -> Vec<i16> {
if (speed_ratio - 1.0).abs() < 0.05 || input.is_empty() {
if !self.output_overlap.is_empty() {
let result: Vec<i16> = self.output_overlap.drain(..)
.map(|s| s.clamp(-32768.0, 32767.0) as i16)
‚ãÆ----
combined.extend(input.iter().cloned());
‚ãÆ----
return input.to_vec();
‚ãÆ----
if (speed_ratio - self.last_speed).abs() > 0.15 {
self.input_buffer.clear();
self.output_overlap.clear();
‚ãÆ----
self.input_buffer.extend(input.iter().map(|&s| s as f32));
if self.input_buffer.len() < self.frame_size + self.search_range {
‚ãÆ----
let target_analysis_hop = (self.hop_size as f64 * speed_ratio).round() as usize;
‚ãÆ----
let estimated_frames = self.input_buffer.len() / target_analysis_hop.max(1);
let mut output = vec![0.0f32; estimated_frames * synthesis_hop + self.frame_size];
for (i, &v) in self.output_overlap.iter().enumerate() {
if i < output.len() {
‚ãÆ----
if input_pos + self.frame_size + self.search_range + target_analysis_hop > self.input_buffer.len() {
‚ãÆ----
if output_pos + self.frame_size > output.len() {
output.resize(output_pos + self.frame_size * 2, 0.0);
‚ãÆ----
let actual_analysis_hop = self.find_best_offset(input_pos, target_analysis_hop);
‚ãÆ----
let complete_len = output_pos.min(output.len());
‚ãÆ----
if complete_len < output.len() {
self.output_overlap.extend_from_slice(&output[complete_len..]);
‚ãÆ----
let consumed = input_pos.min(self.input_buffer.len());
‚ãÆ----
self.input_buffer.drain(0..consumed);
‚ãÆ----
output[..complete_len].iter()
.map(|&s| s.clamp(-32768.0, 32767.0) as i16)
.collect()
</file>

<file path="src/api/types.rs">
pub struct StreamChunk {
‚ãÆ----
pub struct Choice {
‚ãÆ----
pub struct Delta {
‚ãÆ----
pub struct ChatCompletionResponse {
‚ãÆ----
pub struct ChatChoice {
‚ãÆ----
pub struct ChatMessage {
‚ãÆ----
pub struct ExecutedTool {
‚ãÆ----
pub struct SearchResults {
‚ãÆ----
pub struct SearchResult {
</file>

<file path="src/gui/key_mapping.rs">
use eframe::egui;
pub fn egui_key_to_vk(key: &egui::Key) -> Option<u32> {
‚ãÆ----
egui::Key::Num0 => Some(0x30), egui::Key::Num1 => Some(0x31), egui::Key::Num2 => Some(0x32),
egui::Key::Num3 => Some(0x33), egui::Key::Num4 => Some(0x34), egui::Key::Num5 => Some(0x35),
egui::Key::Num6 => Some(0x36), egui::Key::Num7 => Some(0x37), egui::Key::Num8 => Some(0x38),
egui::Key::Num9 => Some(0x39),
egui::Key::A => Some(0x41), egui::Key::B => Some(0x42), egui::Key::C => Some(0x43),
egui::Key::D => Some(0x44), egui::Key::E => Some(0x45), egui::Key::F => Some(0x46),
egui::Key::G => Some(0x47), egui::Key::H => Some(0x48), egui::Key::I => Some(0x49),
egui::Key::J => Some(0x4A), egui::Key::K => Some(0x4B), egui::Key::L => Some(0x4C),
egui::Key::M => Some(0x4D), egui::Key::N => Some(0x4E), egui::Key::O => Some(0x4F),
egui::Key::P => Some(0x50), egui::Key::Q => Some(0x51), egui::Key::R => Some(0x52),
egui::Key::S => Some(0x53), egui::Key::T => Some(0x54), egui::Key::U => Some(0x55),
egui::Key::V => Some(0x56), egui::Key::W => Some(0x57), egui::Key::X => Some(0x58),
egui::Key::Y => Some(0x59), egui::Key::Z => Some(0x5A),
egui::Key::F1 => Some(0x70), egui::Key::F2 => Some(0x71), egui::Key::F3 => Some(0x72),
egui::Key::F4 => Some(0x73), egui::Key::F5 => Some(0x74), egui::Key::F6 => Some(0x75),
egui::Key::F7 => Some(0x76), egui::Key::F8 => Some(0x77), egui::Key::F9 => Some(0x78),
egui::Key::F10 => Some(0x79), egui::Key::F11 => Some(0x7A), egui::Key::F12 => Some(0x7B),
egui::Key::F13 => Some(0x7C), egui::Key::F14 => Some(0x7D), egui::Key::F15 => Some(0x7E),
egui::Key::F16 => Some(0x7F), egui::Key::F17 => Some(0x80), egui::Key::F18 => Some(0x81),
egui::Key::F19 => Some(0x82), egui::Key::F20 => Some(0x83),
egui::Key::Escape => Some(0x1B),
egui::Key::Insert => Some(0x2D),
egui::Key::Delete => Some(0x2E),
egui::Key::Home => Some(0x24),
egui::Key::End => Some(0x23),
egui::Key::PageUp => Some(0x21),
egui::Key::PageDown => Some(0x22),
egui::Key::ArrowLeft => Some(0x25),
egui::Key::ArrowUp => Some(0x26),
egui::Key::ArrowRight => Some(0x27),
egui::Key::ArrowDown => Some(0x28),
egui::Key::Backspace => Some(0x08),
egui::Key::Enter => Some(0x0D),
egui::Key::Space => Some(0x20),
egui::Key::Tab => Some(0x09),
egui::Key::Backtick => Some(0xC0),
egui::Key::Minus => Some(0xBD),
egui::Key::Plus => Some(0xBB),
egui::Key::OpenBracket => Some(0xDB),
egui::Key::CloseBracket => Some(0xDD),
egui::Key::Backslash => Some(0xDC),
egui::Key::Semicolon => Some(0xBA),
egui::Key::Comma => Some(0xBC),
egui::Key::Period => Some(0xBE),
egui::Key::Slash => Some(0xBF),
‚ãÆ----
pub fn egui_pointer_to_vk(btn: &egui::PointerButton) -> Option<u32> {
‚ãÆ----
egui::PointerButton::Middle => Some(0x04),
egui::PointerButton::Extra1 => Some(0x05),
egui::PointerButton::Extra2 => Some(0x06),
</file>

<file path="src/gui/settings_ui/global/tts_settings.rs">
use eframe::egui;
‚ãÆ----
use crate::gui::locale::LocaleText;
‚ãÆ----
pub fn render_tts_settings_modal(
‚ãÆ----
let male_voices: Vec<_> = VOICES.iter().filter(|(_, g)| *g == "Male").collect();
let female_voices: Vec<_> = VOICES.iter().filter(|(_, g)| *g == "Female").collect();
egui::Window::new(format!("üîä {}", text.tts_settings_title))
.collapsible(false)
.resizable(false)
.title_bar(false)
.default_width(650.0)
.default_height(600.0)
.anchor(egui::Align2::CENTER_CENTER, egui::vec2(0.0, 0.0))
.show(ui.ctx(), |ui| {
ui.set_min_height(500.0);
ui.horizontal(|ui| {
ui.label(egui::RichText::new(format!("üîä {}", text.tts_settings_title)).strong().size(14.0));
ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
if icon_button(ui, Icon::Close).clicked() {
‚ãÆ----
ui.separator();
ui.add_space(8.0);
‚ãÆ----
ui.label(egui::RichText::new(text.tts_method_label).strong());
if ui.radio_value(&mut config.tts_method, TtsMethod::GeminiLive, text.tts_method_standard).clicked() {
‚ãÆ----
if ui.radio_value(&mut config.tts_method, TtsMethod::EdgeTTS, text.tts_method_edge).clicked() {
‚ãÆ----
if ui.radio_value(&mut config.tts_method, TtsMethod::GoogleTranslate, text.tts_method_fast).clicked() {
‚ãÆ----
config.tts_speed = "Normal".to_string();
‚ãÆ----
ui.add_space(10.0);
‚ãÆ----
ui.columns(2, |columns| {
columns[0].label(egui::RichText::new(text.tts_speed_label).strong());
columns[0].horizontal(|ui| {
if ui.radio_value(&mut config.tts_speed, "Slow".to_string(), text.tts_speed_slow).clicked() { changed = true; }
if ui.radio_value(&mut config.tts_speed, "Normal".to_string(), text.tts_speed_normal).clicked() { changed = true; }
if ui.radio_value(&mut config.tts_speed, "Fast".to_string(), text.tts_speed_fast).clicked() { changed = true; }
‚ãÆ----
columns[1].label(egui::RichText::new(text.tts_instructions_label).strong());
‚ãÆ----
for (idx, condition) in config.tts_language_conditions.iter_mut().enumerate() {
columns[1].horizontal(|ui| {
let display_name = supported_languages.iter()
.find(|(code, _)| code.eq_ignore_ascii_case(&condition.language_code))
.map(|(_, name)| *name)
.unwrap_or(&condition.language_name);
ui.label(egui::RichText::new(display_name).strong().color(egui::Color32::from_rgb(100, 180, 100)));
ui.label("‚Üí");
if ui.add(
‚ãÆ----
.desired_width(180.0)
.hint_text(text.tts_instructions_hint)
).changed() {
‚ãÆ----
if icon_button(ui, Icon::Close).on_hover_text("Remove").clicked() {
to_remove = Some(idx);
‚ãÆ----
config.tts_language_conditions.remove(idx);
‚ãÆ----
let used_codes: Vec<_> = config.tts_language_conditions.iter()
.map(|c| c.language_code.as_str())
.collect();
let available: Vec<_> = supported_languages.iter()
.filter(|(code, _)| !used_codes.contains(code))
‚ãÆ----
if !available.is_empty() {
‚ãÆ----
.selected_text(text.tts_add_condition)
.width(140.0)
.show_ui(ui, |ui| {
‚ãÆ----
if ui.selectable_label(false, *name).clicked() {
config.tts_language_conditions.push(crate::config::TtsLanguageCondition {
language_code: code.to_string(),
language_name: name.to_string(),
‚ãÆ----
ui.columns(4, |columns| {
‚ãÆ----
use std::collections::hash_map::RandomState;
‚ãÆ----
if ui.radio(is_selected, "").clicked() {
config.tts_voice = name.to_string();
‚ãÆ----
if ui.button("üîä").on_hover_text("Preview").clicked() {
‚ãÆ----
if !text.tts_preview_texts.is_empty() {
‚ãÆ----
let mut hasher = s.build_hasher();
hasher.write_usize(SystemTime::now().duration_since(UNIX_EPOCH).unwrap_or_default().subsec_nanos() as usize);
let rand_val = hasher.finish();
let len = text.tts_preview_texts.len();
‚ãÆ----
let last = LAST_PREVIEW_IDX.load(Ordering::Relaxed);
‚ãÆ----
LAST_PREVIEW_IDX.store(idx, Ordering::Relaxed);
let preview_text = text.tts_preview_texts[idx].replace("{}", name);
crate::api::tts::TTS_MANAGER.speak_interrupt(&preview_text, 0);
‚ãÆ----
let preview_text = format!("Hello, I am {}. This is a voice preview.", name);
‚ãÆ----
ui.label(egui::RichText::new(name).strong());
‚ãÆ----
let male_mid = (male_voices.len() + 1) / 2;
let male_col1: Vec<_> = male_voices.iter().take(male_mid).collect();
let male_col2: Vec<_> = male_voices.iter().skip(male_mid).collect();
let female_mid = (female_voices.len() + 1) / 2;
let female_col1: Vec<_> = female_voices.iter().take(female_mid).collect();
let female_col2: Vec<_> = female_voices.iter().skip(female_mid).collect();
columns[0].vertical(|ui| {
ui.label(egui::RichText::new(text.tts_male).strong().underline());
ui.add_space(4.0);
‚ãÆ----
render_voice(ui, name, config, text, &mut changed);
‚ãÆ----
columns[1].vertical(|ui| {
ui.label(egui::RichText::new("").strong()); // Empty header for alignment
‚ãÆ----
// Column 2: Female (first half)
columns[2].vertical(|ui| {
ui.label(egui::RichText::new(text.tts_female).strong().underline());
‚ãÆ----
// Column 3: Female (second half)
columns[3].vertical(|ui| {
‚ãÆ----
// Simplified UI for Google Translate
ui.vertical_centered(|ui| {
ui.add_space(20.0);
ui.label(egui::RichText::new(text.tts_google_translate_title).size(18.0).strong());
‚ãÆ----
ui.label(text.tts_google_translate_desc);
‚ãÆ----
ui.label(egui::RichText::new(text.tts_speed_label).strong());
‚ãÆ----
ui.label(egui::RichText::new(text.tts_edge_title).size(18.0).strong());
ui.add_space(5.0);
ui.label(text.tts_edge_desc);
ui.add_space(15.0);
‚ãÆ----
ui.label(egui::RichText::new(text.tts_pitch_label).strong());
if ui.add(egui::Slider::new(&mut config.edge_tts_settings.pitch, -50..=50).suffix(" Hz")).changed() {
‚ãÆ----
ui.label(egui::RichText::new(text.tts_rate_label).strong());
if ui.add(egui::Slider::new(&mut config.edge_tts_settings.rate, -50..=100).suffix("%")).changed() {
‚ãÆ----
ui.label(egui::RichText::new(text.tts_voice_per_language_label).strong());
‚ãÆ----
let cache = crate::api::tts::edge_voices::EDGE_VOICE_CACHE.lock().unwrap();
(cache.loaded, cache.loading, cache.error.clone())
‚ãÆ----
ui.spinner();
ui.label(text.tts_loading_voices);
‚ãÆ----
ui.colored_label(egui::Color32::RED, format!("{} {}", text.tts_failed_load_voices, error).replace("{}", ""));
if ui.button(text.tts_retry_label).clicked() {
// Reset cache and retry
let mut cache = crate::api::tts::edge_voices::EDGE_VOICE_CACHE.lock().unwrap();
‚ãÆ----
// Loaded - show voice configuration
egui::ScrollArea::vertical().max_height(180.0).show(ui, |ui| {
‚ãÆ----
for (idx, voice_config) in config.edge_tts_settings.voice_configs.iter_mut().enumerate() {
‚ãÆ----
// Language name (read-only)
ui.label(egui::RichText::new(&voice_config.language_name).strong().color(egui::Color32::from_rgb(100, 180, 100)));
‚ãÆ----
// Voice dropdown for this language
‚ãÆ----
egui::ComboBox::from_id_salt(format!("edge_voice_{}", idx))
.selected_text(&voice_config.voice_name)
.width(220.0)
‚ãÆ----
let display = format!("{} ({})", voice.short_name, voice.gender);
if ui.selectable_label(voice_config.voice_name == voice.short_name, &display).clicked() {
voice_config.voice_name = voice.short_name.clone();
‚ãÆ----
// Remove button
‚ãÆ----
config.edge_tts_settings.voice_configs.remove(idx);
‚ãÆ----
let used_codes: Vec<_> = config.edge_tts_settings.voice_configs.iter()
‚ãÆ----
let available: Vec<_> = available_langs.iter()
.filter(|(code, _)| !used_codes.contains(&code.as_str()))
‚ãÆ----
.selected_text(text.tts_add_language_label)
.width(150.0)
‚ãÆ----
if ui.selectable_label(false, name).clicked() {
‚ãÆ----
let default_voice = voices.first()
.map(|v| v.short_name.clone())
.unwrap_or_else(|| format!("{}-??-??Neural", code));
config.edge_tts_settings.voice_configs.push(
‚ãÆ----
language_code: code.clone(),
language_name: name.clone(),
‚ãÆ----
if ui.button(text.tts_reset_to_defaults_label).clicked() {
‚ãÆ----
ui.label(text.tts_initializing_voices);
</file>

<file path="src/gui/settings_ui/global/usage_stats.rs">
use eframe::egui;
use crate::gui::locale::LocaleText;
‚ãÆ----
use std::collections::HashMap;
pub fn render_usage_modal(
‚ãÆ----
egui::Window::new(format!("üìä {}", text.usage_statistics_title))
.collapsible(false)
.resizable(false)
.title_bar(false)
.default_width(400.0)
.anchor(egui::Align2::CENTER_CENTER, egui::vec2(0.0, 0.0))
.show(ui.ctx(), |ui| {
ui.horizontal(|ui| {
ui.label(egui::RichText::new(format!("üìä {}", text.usage_statistics_title)).strong().size(14.0));
ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
if icon_button(ui, Icon::Close).clicked() {
‚ãÆ----
ui.separator();
ui.add_space(4.0);
‚ãÆ----
get_all_models_with_ollama()
‚ãÆ----
get_all_models().to_vec()
‚ãÆ----
.max_height(450.0)
.auto_shrink([false, false])
.show(ui, |ui| {
ui.set_width(ui.available_width());
‚ãÆ----
egui::CollapsingHeader::new(egui::RichText::new("‚ö° Groq").strong().size(13.0))
.default_open(true)
‚ãÆ----
egui::Grid::new("groq_grid").striped(true).show(ui, |ui| {
ui.label(egui::RichText::new(text.usage_model_column).strong().size(11.0));
ui.label(egui::RichText::new(text.usage_remaining_column).strong().size(11.0));
ui.end_row();
‚ãÆ----
if shown_models.contains(&model.full_name) { continue; }
shown_models.insert(model.full_name.clone());
ui.label(&model.full_name);
let status = usage_stats.get(&model.full_name).cloned().unwrap_or_else(|| "??? / ?".to_string());
ui.label(status);
‚ãÆ----
if !shown_models.contains("llama-3.1-8b-instant") {
shown_models.insert("llama-3.1-8b-instant".to_string());
ui.label("llama-3.1-8b-instant");
let status = usage_stats.get("llama-3.1-8b-instant").cloned().unwrap_or_else(|| "??? / ?".to_string());
‚ãÆ----
egui::CollapsingHeader::new(egui::RichText::new("‚ú® Google Gemini").strong().size(13.0))
‚ãÆ----
ui.add_space(120.0);
ui.hyperlink_to(text.usage_check_link, "https://aistudio.google.com/usage?timeRange=last-1-day&tab=rate-limit");
‚ãÆ----
egui::CollapsingHeader::new(egui::RichText::new("üåê OpenRouter").strong().size(13.0))
‚ãÆ----
ui.hyperlink_to(text.usage_check_link, "https://openrouter.ai/activity");
‚ãÆ----
egui::CollapsingHeader::new(egui::RichText::new("üè† Ollama (Local)").strong().size(13.0))
‚ãÆ----
ui.label("‚àû Unlimited");
</file>

<file path="src/gui/settings_ui/node_graph/mod.rs">
pub mod body;
pub mod conversion;
pub mod node;
pub mod utils;
pub mod viewer;
‚ãÆ----
pub use node::ChainNode;
pub use utils::request_node_graph_view_reset;
pub use viewer::ChainViewer;
use crate::gui::locale::LocaleText;
use eframe::egui;
use egui_snarl::ui::SnarlStyle;
‚ãÆ----
use std::collections::HashMap;
pub fn render_node_graph(
‚ãÆ----
snarl.show(&mut viewer, &style, egui::Id::new("chain_graph"), ui);
‚ãÆ----
for (out, inp) in snarl.wires() {
‚ãÆ----
to_disconnect.push((out, inp));
‚ãÆ----
input_count.entry(inp).or_default().push(out);
‚ãÆ----
if sources.len() > 1 {
for &src in sources.iter().take(sources.len() - 1) {
to_disconnect.push((src, _inp));
‚ãÆ----
snarl.disconnect(out, inp);
</file>

<file path="src/gui/settings_ui/node_graph/viewer.rs">
use super::body::show_body;
use super::node::ChainNode;
‚ãÆ----
use crate::gui::locale::LocaleText;
use eframe::egui;
‚ãÆ----
pub struct ChainViewer<'a> {
‚ãÆ----
pub fn new(
‚ãÆ----
ui_language: ui_language.to_string(),
‚ãÆ----
preset_type: preset_type.to_string(),
‚ãÆ----
/// Check if a model's provider is enabled
    pub fn is_provider_enabled(&self, provider: &str) -> bool {
‚ãÆ----
pub fn is_provider_enabled(&self, provider: &str) -> bool {
‚ãÆ----
fn title(&mut self, node: &ChainNode) -> String {
‚ãÆ----
self.preset_type.as_str()
‚ãÆ----
block_type.as_str()
‚ãÆ----
format!("{} {}", prefix, type_name)
‚ãÆ----
match self.preset_type.as_str() {
"image" => self.text.node_special_image_to_text.to_string(),
"audio" => self.text.node_special_audio_to_text.to_string(),
_ => self.text.node_special_default.to_string(),
‚ãÆ----
ChainNode::Process { .. } => self.text.node_process_title.to_string(),
‚ãÆ----
fn show_header(
‚ãÆ----
ui.horizontal(|ui| {
‚ãÆ----
draw_icon_static(ui, icon, Some(16.0));
‚ãÆ----
ui.label(format!("{} {}", prefix, type_name));
‚ãÆ----
draw_icon_static(ui, Icon::Settings, Some(16.0));
‚ãÆ----
ui.label(title);
‚ãÆ----
let title = match self.preset_type.as_str() {
‚ãÆ----
ui.label(
egui::RichText::new(title).color(egui::Color32::from_rgb(255, 200, 100)),
‚ãÆ----
fn inputs(&mut self, node: &ChainNode) -> usize {
‚ãÆ----
fn outputs(&mut self, _node: &ChainNode) -> usize {
‚ãÆ----
fn show_input(
‚ãÆ----
// Green color for text connections
PinInfo::circle().with_fill(egui::Color32::from_rgb(100, 200, 100))
‚ãÆ----
fn show_output(
‚ãÆ----
PinInfo::circle().with_fill(egui::Color32::from_rgb(100, 150, 255))
‚ãÆ----
fn has_body(&mut self, _node: &ChainNode) -> bool {
‚ãÆ----
fn show_body(
‚ãÆ----
show_body(self, node_id, ui, snarl);
‚ãÆ----
fn has_graph_menu(&mut self, _pos: egui::Pos2, _snarl: &mut Snarl<ChainNode>) -> bool {
‚ãÆ----
fn show_graph_menu(
‚ãÆ----
let add_special_label = match self.preset_type.as_str() {
‚ãÆ----
if ui.button(add_process_label).clicked() {
snarl.insert_node(pos, ChainNode::default());
‚ãÆ----
ui.close();
‚ãÆ----
if ui.button(add_special_label).clicked() {
‚ãÆ----
snarl.insert_node(pos, node);
‚ãÆ----
fn has_node_menu(&mut self, node: &ChainNode) -> bool {
!node.is_input()
‚ãÆ----
fn show_node_menu(
‚ãÆ----
let delete_label = match self.ui_language.as_str() {
‚ãÆ----
if ui.button(delete_label).clicked() {
snarl.remove_node(node_id);
‚ãÆ----
fn connect(&mut self, from: &OutPin, to: &InPin, snarl: &mut Snarl<ChainNode>) {
let to_node = snarl.get_node(to.id.node);
let from_node = snarl.get_node(from.id.node);
‚ãÆ----
if to_node.is_special() {
if !from_node.is_input() {
‚ãÆ----
snarl.connect(from.id, to.id);
‚ãÆ----
fn disconnect(&mut self, from: &OutPin, to: &InPin, snarl: &mut Snarl<ChainNode>) {
snarl.disconnect(from.id, to.id);
</file>

<file path="src/gui/splash.rs">
use eframe::egui;
‚ãÆ----
use std::f32::consts::PI;
use std::cmp::Ordering;
‚ãÆ----
fn smoothstep(edge0: f32, edge1: f32, x: f32) -> f32 {
let t = ((x - edge0) / (edge1 - edge0)).clamp(0.0, 1.0);
‚ãÆ----
fn lerp(a: f32, b: f32, t: f32) -> f32 {
‚ãÆ----
struct Vec3 { x: f32, y: f32, z: f32 }
impl Vec3 {
‚ãÆ----
fn new(x: f32, y: f32, z: f32) -> Self { Self { x, y, z } }
fn add(self, v: Vec3) -> Self { Self::new(self.x + v.x, self.y + v.y, self.z + v.z) }
fn sub(self, v: Vec3) -> Self { Self::new(self.x - v.x, self.y - v.y, self.z - v.z) }
fn mul(self, s: f32) -> Self { Self::new(self.x * s, self.y * s, self.z * s) }
fn len(self) -> f32 { (self.x*self.x + self.y*self.y + self.z*self.z).sqrt() }
fn normalize(self) -> Self {
let l = self.len();
if l == 0.0 { Self::ZERO } else { self.mul(1.0/l) }
‚ãÆ----
fn lerp(self, target: Vec3, t: f32) -> Self {
‚ãÆ----
lerp(self.x, target.x, t),
lerp(self.y, target.y, t),
lerp(self.z, target.z, t)
‚ãÆ----
fn rotate_x(self, angle: f32) -> Self {
let (s, c) = angle.sin_cos();
‚ãÆ----
fn rotate_y(self, angle: f32) -> Self {
‚ãÆ----
fn rotate_z(self, angle: f32) -> Self {
‚ãÆ----
struct Cloud {
‚ãÆ----
struct Star {
‚ãÆ----
struct MoonFeature {
‚ãÆ----
struct Voxel {
‚ãÆ----
pub struct SplashScreen {
‚ãÆ----
pub enum SplashStatus {
‚ãÆ----
impl SplashScreen {
pub fn new(ctx: &egui::Context) -> Self {
let is_dark = ctx.style().visuals.dark_mode;
‚ãÆ----
start_time: ctx.input(|i| i.time),
‚ãÆ----
loading_text: "TRANSLATING...".to_string(),
‚ãÆ----
pub fn reset_timer(&mut self, ctx: &egui::Context) {
self.start_time = ctx.input(|i| i.time);
‚ãÆ----
fn init_scene(&mut self) {
‚ãÆ----
rng_state = rng_state.wrapping_mul(6364136223846793005).wrapping_add(1);
‚ãÆ----
for (y, row) in map.iter().enumerate() {
for (x, ch) in row.chars().enumerate() {
‚ãÆ----
self.voxels.push(Voxel {
‚ãÆ----
rot: Vec3::new(rng() * 6.0, rng() * 6.0, rng() * 6.0),
‚ãÆ----
color: if rng() > 0.85 { C_WHITE } else { color_theme },
noise_factor: rng(),
‚ãÆ----
spawn_letter(&s_map, -120.0, c_secondary);
spawn_letter(&g_map, -35.0, c_primary);
spawn_letter(&t_map, 50.0, c_secondary);
‚ãÆ----
let h_y = (rng() * 300.0) - 150.0;
let h_radius = 80.0 + rng() * 60.0;
let h_angle = rng() * PI * 2.0;
let target = Vec3::new(h_angle.cos(), 0.0, h_angle.sin()).mul(800.0);
‚ãÆ----
rot: Vec3::new(rng(), rng(), rng()),
‚ãÆ----
self.stars.push(Star {
pos: Vec2::new(rng(), rng() * 0.85),
phase: rng() * PI * 2.0,
brightness: 0.3 + rng() * 0.7,
size: if rng() > 0.95 { 1.5 + rng() } else { 0.8 + rng() * 0.5 },
‚ãÆ----
puffs.push((Vec2::ZERO, 1.0));
let num_puffs = 5 + (rng() * 4.0) as usize;
‚ãÆ----
let angle = rng() * PI * 2.0;
let dist = 15.0 + rng() * 25.0;
let r_mult = 0.4 + rng() * 0.5;
puffs.push((
Vec2::new(angle.cos() * dist, angle.sin() * dist * 0.6),
‚ãÆ----
self.clouds.push(Cloud {
pos: Vec2::new(rng() * 1200.0 - 600.0, rng() * 400.0 - 200.0),
velocity: 5.0 + rng() * 15.0,
scale: 1.2 + rng() * 1.5,
opacity: 0.4 + rng() * 0.4,
‚ãÆ----
let dist = rng().sqrt() * 0.7;
let pos = Vec2::new(angle.cos() * dist, angle.sin() * dist);
self.moon_features.push(MoonFeature {
‚ãÆ----
radius: 0.15 + rng() * 0.25,
‚ãÆ----
let dist = rng().powf(0.8);
‚ãÆ----
radius: 0.02 + rng() * 0.06,
‚ãÆ----
pub fn update(&mut self, ctx: &egui::Context) -> SplashStatus {
self.is_dark = ctx.style().visuals.dark_mode;
if !self.init_done { self.init_scene(); }
let now = ctx.input(|i| i.time);
let dt = ctx.input(|i| i.stable_dt);
if self.exit_start_time.is_none() {
‚ãÆ----
if ctx.input(|i| i.pointer.any_click()) {
self.exit_start_time = Some(now);
‚ãÆ----
let physics_t = t_abs.min(ANIMATION_DURATION);
‚ãÆ----
warp_progress = (dt / EXIT_DURATION).clamp(0.0, 1.0);
‚ãÆ----
ctx.request_repaint();
let viewport_rect = ctx.input(|i| i.viewport().inner_rect.unwrap_or(Rect::from_min_size(Pos2::ZERO, Vec2::ZERO)));
let size = if viewport_rect.width() < 100.0 || viewport_rect.height() < 100.0 {
‚ãÆ----
viewport_rect.size()
‚ãÆ----
if cloud.pos.x > rect.width() / 2.0 + 300.0 {
cloud.pos.x = -rect.width() / 2.0 - 300.0;
‚ãÆ----
if let Some(pointer) = ctx.input(|i| i.pointer.hover_pos()) {
let center = rect.center();
‚ãÆ----
let cam_dist = 600.0 + smoothstep(0.0, ANIMATION_DURATION, physics_t) * 100.0 - cam_z_offset;
‚ãÆ----
if t_abs < 0.8 { self.loading_text = "TRANSLATING...".to_string(); }
else if t_abs < 1.6 { self.loading_text = "OCR...".to_string(); }
else if t_abs < 2.4 { self.loading_text = "TRANSCRIBING...".to_string(); }
else { self.loading_text = "nganlinh4".to_string(); }
‚ãÆ----
self.loading_text = "READY TO ROCK!".to_string();
‚ãÆ----
let progress = smoothstep(my_start, my_end, physics_t);
‚ãÆ----
let current_h_y = v.helix_y + (physics_t * 2.0 + v.noise_factor * 10.0).sin() * 5.0;
‚ãÆ----
let flare = (physics_t - flare_start).powi(2) * 20.0;
‚ãÆ----
v.pos = Vec3::new(current_angle.cos() * current_radius, current_h_y, current_angle.sin() * current_radius);
‚ãÆ----
let helix_pos = Vec3::new(current_angle.cos() * current_radius, current_h_y, current_angle.sin() * current_radius);
‚ãÆ----
let local_linear = ((warp_progress - start_threshold) / move_duration).clamp(0.0, 1.0);
‚ãÆ----
let radial = Vec3::new(v.pos.x, v.pos.y, 0.0).normalize();
‚ãÆ----
let swirl_vec = radial.rotate_z(curl_angle);
‚ãÆ----
target_base = target_base.add(swirl_vec.mul(local_eased * dist_mult));
‚ãÆ----
let pos = helix_pos.lerp(target_base, progress);
‚ãÆ----
let to_mouse = pos.sub(self.mouse_world_pos);
‚ãÆ----
let dist = dist_sq.sqrt();
‚ãÆ----
v.velocity = v.velocity.add(to_mouse.normalize().mul(force * 2.0));
‚ãÆ----
let displacement = pos.sub(target_base);
let spring_force = displacement.mul(-0.1);
v.velocity = v.velocity.add(spring_force);
v.velocity = v.velocity.mul(0.90);
v.pos = pos.add(v.velocity);
v.rot = v.rot.lerp(Vec3::ZERO, 0.1);
‚ãÆ----
let impact = (physics_t - my_end).max(0.0);
let pulse = (impact * 10.0).sin() * (-3.0 * impact).exp() * 0.5;
‚ãÆ----
v.scale = lerp(0.8, 1.0, progress);
‚ãÆ----
pub fn paint(&self, ctx: &egui::Context) {
‚ãÆ----
warp_prog = (dt / EXIT_DURATION).powi(5);
‚ãÆ----
.order(egui::Order::Foreground)
.fixed_pos(Pos2::ZERO)
.show(ctx, |ui| {
ui.allocate_response(size, egui::Sense::click_and_drag().union(egui::Sense::hover()));
‚ãÆ----
let painter = ctx.layer_painter(egui::LayerId::new(egui::Order::Foreground, egui::Id::new("splash_overlay")));
‚ãÆ----
let master_alpha = alpha.clamp(0.0, 1.0);
‚ãÆ----
let t_fade = (t / 0.5).clamp(0.0, 1.0);
‚ãÆ----
lerp(start_col.r() as f32, bg_color.r() as f32, t_fade) as u8,
lerp(start_col.g() as f32, bg_color.g() as f32, t_fade) as u8,
lerp(start_col.b() as f32, bg_color.b() as f32, t_fade) as u8,
‚ãÆ----
let sky_exit_fade = (1.0 - warp_prog * 4.0).clamp(0.0, 1.0);
‚ãÆ----
painter.rect_filled(rect, 0.0, bg_color.linear_multiply(sky_exit_fade));
‚ãÆ----
let c_top = C_SKY_DAY_TOP.linear_multiply(sky_exit_fade);
let c_bot = C_SKY_DAY_BOT.linear_multiply(sky_exit_fade);
‚ãÆ----
mesh.vertices.push(egui::epaint::Vertex { pos: rect.left_top(), uv: Pos2::ZERO, color: c_top });
mesh.vertices.push(egui::epaint::Vertex { pos: rect.right_top(), uv: Pos2::ZERO, color: c_top });
mesh.vertices.push(egui::epaint::Vertex { pos: rect.right_bottom(), uv: Pos2::ZERO, color: c_bot });
mesh.vertices.push(egui::epaint::Vertex { pos: rect.left_bottom(), uv: Pos2::ZERO, color: c_bot });
mesh.add_triangle(0, 1, 2);
mesh.add_triangle(0, 2, 3);
painter.add(mesh);
‚ãÆ----
for (i, star) in self.stars.iter().enumerate() {
let sx = rect.left() + (star.pos.x * rect.width()) + star_offset.x;
let sy = rect.top() + (star.pos.y * rect.height()) + star_offset.y;
let rnd = ((i as f32 * 1.618).fract() + (star.pos.x * 10.0).fract()).fract();
‚ãÆ----
let p = ((warp_prog - start) / dur).clamp(0.0, 1.0);
‚ãÆ----
let twinkle = (star.phase + star_time).sin() * 0.3 + 0.7;
let star_alpha = (star.brightness * twinkle * master_alpha * local_fade).clamp(0.0, 1.0);
‚ãÆ----
painter.circle_filled(
‚ãÆ----
C_WHITE.linear_multiply(star_alpha)
‚ãÆ----
C_WHITE.linear_multiply(day_star_alpha)
‚ãÆ----
mesh.vertices.push(egui::epaint::Vertex { pos: sun_pos, uv: Pos2::ZERO, color: Color32::TRANSPARENT });
‚ãÆ----
let p1 = sun_pos + Vec2::new(angle.cos() * ray_len, angle.sin() * ray_len);
let p2 = sun_pos + Vec2::new(next_angle.cos() * ray_len, next_angle.sin() * ray_len);
mesh.vertices.push(egui::epaint::Vertex { pos: p1, uv: Pos2::ZERO, color: c1 });
mesh.vertices.push(egui::epaint::Vertex { pos: p2, uv: Pos2::ZERO, color: c1 });
‚ãÆ----
let moon_alpha = master_alpha * (1.0 - warp_prog * 3.0).clamp(0.0, 1.0);
‚ãÆ----
let moon_bob = (t * 0.5).sin() * 5.0;
‚ãÆ----
painter.circle_filled(final_moon_pos, moon_rad * 1.6, C_MOON_GLOW.linear_multiply(0.03 * moon_alpha));
painter.circle_filled(final_moon_pos, moon_rad * 1.2, C_MOON_GLOW.linear_multiply(0.08 * moon_alpha));
painter.circle_filled(final_moon_pos, moon_rad, C_MOON_BASE.linear_multiply(moon_alpha));
‚ãÆ----
let rot_cos = feature_rot.cos();
let rot_sin = feature_rot.sin();
‚ãÆ----
let z_depth = (1.0 - dist_sq).sqrt();
‚ãÆ----
C_MOON_SHADOW.linear_multiply(f_alpha * 0.8)
‚ãÆ----
C_MOON_HIGHLIGHT.linear_multiply(f_alpha * 0.4)
‚ãÆ----
C_MOON_SHADOW.linear_multiply(f_alpha * 0.3)
‚ãÆ----
painter.circle_stroke(
‚ãÆ----
Stroke::new(2.0, C_MOON_HIGHLIGHT.linear_multiply(0.4 * moon_alpha))
‚ãÆ----
let sun_bob = (t * 0.5).sin() * 5.0;
‚ãÆ----
painter.circle_filled(final_sun_pos, moon_rad * 2.0, C_SUN_GLOW.linear_multiply(0.1 * moon_alpha));
painter.circle_filled(final_sun_pos, moon_rad * 1.4, C_SUN_GLOW.linear_multiply(0.2 * moon_alpha));
painter.circle_filled(final_sun_pos, moon_rad, C_SUN_BODY.linear_multiply(moon_alpha));
‚ãÆ----
Color32::from_rgb(160, 60, 0).linear_multiply(f_alpha * 0.8)
‚ãÆ----
C_SUN_FLARE.linear_multiply(f_alpha * 0.3)
‚ãÆ----
C_WHITE.linear_multiply(f_alpha * 0.5)
‚ãÆ----
Stroke::new(3.0, C_SUN_HIGHLIGHT.linear_multiply(0.5 * moon_alpha))
‚ãÆ----
painter.with_clip_rect(Rect::from_min_max(rect.min, Pos2::new(rect.max.x, horizon + 30.0)))
‚ãÆ----
painter.clone()
‚ãÆ----
for (i, cloud) in self.clouds.iter().enumerate() {
‚ãÆ----
let rnd = (i as f32 * 0.73).fract();
‚ãÆ----
C_CLOUD_CORE.linear_multiply(cloud_alpha * 0.95)
‚ãÆ----
C_CLOUD_WHITE.linear_multiply(cloud_alpha * 0.95)
‚ãÆ----
cloud_painter.circle_filled(
‚ãÆ----
let render_t = t.min(ANIMATION_DURATION + 5.0);
‚ãÆ----
let rnd = (i as f32 * 0.9).sin() * 0.5 + 0.5;
‚ãÆ----
let perspective = 250.0 / (z_dist - warp_prog * 0.8).max(0.1);
‚ãÆ----
if y > rect.bottom() || y < horizon { continue; }
let w = rect.width() * (2.5 / z_dist);
‚ãÆ----
let alpha_grid = (1.0 - (y - horizon) / (rect.bottom() - horizon)).powf(0.5) * master_alpha * 0.5 * local_fade;
‚ãÆ----
(C_DAY_REP, 4.0 * (1.0 - (y-horizon)/rect.height()))
‚ãÆ----
painter.line_segment(
‚ãÆ----
Stroke::new(thickness, grid_col.linear_multiply(alpha_grid))
‚ãÆ----
let physics_t = t.min(ANIMATION_DURATION);
‚ãÆ----
let cam_dist = (600.0 + smoothstep(0.0, 8.0, physics_t) * 100.0) - cam_fly_dist;
‚ãÆ----
let mut draw_list: Vec<(f32, Pos2, f32, Color32, bool, bool)> = Vec::with_capacity(self.voxels.len());
‚ãÆ----
local_debris_alpha = 1.0 - smoothstep(fade_start, fade_end, physics_t);
‚ãÆ----
v_center = v_center.rotate_x(global_rot.x).rotate_y(global_rot.y).rotate_z(global_rot.z);
‚ãÆ----
let local_linear = ((warp_prog - start_threshold) / move_duration).clamp(0.0, 1.0);
let fade = (local_linear * 1.5).clamp(0.0, 1.0);
‚ãÆ----
let final_col = base_col.linear_multiply(alpha_local);
draw_list.push((z_depth, screen_pos, r, final_col, v.color == C_WHITE || v.color == C_DAY_SEC, v.is_debris));
‚ãÆ----
draw_list.sort_by(|a, b| b.0.partial_cmp(&a.0).unwrap_or(Ordering::Equal));
‚ãÆ----
Color32::from_black_alpha(200).linear_multiply(col.a() as f32 / 255.0)
‚ãÆ----
Color32::from_rgb(100, 120, 150).linear_multiply(col.a() as f32 / 255.0)
‚ãÆ----
Color32::from_rgb(0, 40, 100).linear_multiply(col.a() as f32 / 255.0)
‚ãÆ----
painter.circle_filled(pos, r, shadow_col);
‚ãÆ----
painter.circle_filled(pos + body_offset, r * 0.85, col);
‚ãÆ----
Color32::WHITE.linear_multiply(0.5)
‚ãÆ----
col.linear_multiply(0.5)
‚ãÆ----
painter.circle_filled(pos + gradient_offset, r * 0.5, glow_col);
‚ãÆ----
.linear_multiply(col.a() as f32 / 255.0);
painter.circle_filled(highlight_pos, r * 0.25, highlight_col);
painter.circle_filled(highlight_pos, r * 0.15, Color32::WHITE.linear_multiply(col.a() as f32 / 255.0));
‚ãÆ----
let ui_alpha = 1.0 - (warp_prog * 10.0).clamp(0.0, 1.0);
‚ãÆ----
let ui_color = ui_text_col.linear_multiply(master_alpha * ui_alpha);
‚ãÆ----
C_CYAN.linear_multiply(master_alpha * ui_alpha)
‚ãÆ----
C_DAY_TEXT.linear_multiply(master_alpha * ui_alpha)
‚ãÆ----
C_WHITE.linear_multiply(master_alpha * ui_alpha)
‚ãÆ----
let magenta_color = if self.is_dark { C_MAGENTA.linear_multiply(master_alpha * ui_alpha) } else { C_DAY_REP.linear_multiply(master_alpha * ui_alpha) };
let title_text = format!("SCREEN GOATED TOOLBOX {}", env!("CARGO_PKG_VERSION"));
‚ãÆ----
C_MAGENTA.linear_multiply(master_alpha * ui_alpha)
‚ãÆ----
painter.text(
‚ãÆ----
title_font.clone(),
‚ãÆ----
painter.rect_filled(bar_rect, 2.0, bar_bg_col);
let prog = (physics_t / (ANIMATION_DURATION - 1.0)).clamp(0.0, 1.0);
‚ãÆ----
fill.set_width(bar_rect.width() * prog);
painter.rect_filled(fill, 2.0, magenta_color);
‚ãÆ----
let pulse = (t * 5.0).sin().abs() * 0.7 + 0.3;
‚ãÆ----
click_col.linear_multiply(pulse)
</file>

<file path="src/icon_gen.rs">
use eframe::egui;
pub fn get_tray_icon(is_system_dark: bool) -> tray_icon::Icon {
‚ãÆ----
include_bytes!("../assets/tray_icon.png")
‚ãÆ----
include_bytes!("../assets/tray_icon-light.png")
‚ãÆ----
let img = image::load_from_memory(icon_bytes).expect("Failed to load tray icon");
let img_rgba = img.to_rgba8();
let (width, height) = img_rgba.dimensions();
let rgba = img_rgba.into_raw();
tray_icon::Icon::from_rgba(rgba, width, height).unwrap()
‚ãÆ----
pub fn get_window_icon(is_system_dark: bool) -> egui::IconData {
‚ãÆ----
include_bytes!("../assets/app-icon-small.png")
‚ãÆ----
include_bytes!("../assets/app-icon-small-light.png")
‚ãÆ----
let img = image::load_from_memory(icon_bytes).expect("Failed to load app icon");
‚ãÆ----
rgba: img_rgba.into_vec(),
</file>

<file path="src/overlay/broom_assets.rs">
pub struct BroomRenderParams {
‚ãÆ----
pub fn render_procedural_broom(params: BroomRenderParams) -> Vec<u32> {
let mut pixels = vec![0u32; (BROOM_W * BROOM_H) as usize];
‚ãÆ----
let handle_rad = (params.tilt_angle * 0.25).to_radians();
let h_sin = handle_rad.sin();
let h_cos = handle_rad.cos();
let bristle_target_rad = (params.tilt_angle * 0.5).to_radians();
‚ãÆ----
let b_sin = current_angle.sin();
let b_cos = current_angle.cos();
‚ãÆ----
let start_x = (cx - half_w).round() as i32;
let end_x = (cx + half_w).round() as i32;
let py = cy.round() as i32;
‚ãÆ----
draw_pixel(px, py, c_shadow, true);
‚ãÆ----
let rel_x = (px as f32 - cx).round() as i32;
‚ãÆ----
draw_pixel(px, py, col, false);
‚ãÆ----
for px in (cx - half_w).round() as i32 ..= (cx + half_w).round() as i32 {
draw_pixel(px, cy.round() as i32, c_band, false);
‚ãÆ----
let px = cx.round() as i32;
‚ãÆ----
draw_pixel(px, py, c_handle_dk, false);
draw_pixel(px + 1, py, c_handle_lt, false);
</file>

<file path="src/overlay/favorite_bubble/mod.rs">
pub mod html;
pub mod panel;
pub mod render;
pub mod state;
pub mod utils;
pub mod window;
pub use panel::update_favorites_panel;
</file>

<file path="src/overlay/favorite_bubble/utils.rs">
use windows::Win32::Foundation::HWND;
pub struct HwndWrapper(pub HWND);
unsafe impl Send for HwndWrapper {}
unsafe impl Sync for HwndWrapper {}
‚ãÆ----
fn window_handle(
‚ãÆ----
std::num::NonZeroIsize::new(self.0 .0 as isize).expect("HWND cannot be null"),
‚ãÆ----
unsafe { Ok(raw_window_handle::WindowHandle::borrow_raw(handle)) }
</file>

<file path="src/overlay/html_components/css_modals.rs">
pub fn get() -> String { r###"
‚ãÆ----
"###.to_string() }
</file>

<file path="src/overlay/paint_utils.rs">
pub fn hsv_to_rgb(h: f32, s: f32, v: f32) -> u32 {
‚ãÆ----
let x = c * (1.0 - (h_prime % 2.0 - 1.0).abs());
‚ãÆ----
pub fn sd_rounded_box(px: f32, py: f32, bx: f32, by: f32, r: f32) -> f32 {
let qx = px.abs() - bx + r;
let qy = py.abs() - by + r;
let len_max_q = (qx.max(0.0).powi(2) + qy.max(0.0).powi(2)).sqrt();
let min_max_q = qx.max(qy).min(0.0);
‚ãÆ----
pub unsafe fn draw_direct_sdf_glow(
‚ãÆ----
if pixels_ptr.is_null() { return; }
‚ãÆ----
let eff_radius = CORNER_RADIUS.min(bx).min(by);
let min_dim = (w as f32).min(h as f32);
let dynamic_base_scale = (min_dim * 0.2).clamp(20.0, 60.0);
‚ãÆ----
let time_rad = time_offset.to_radians();
‚ãÆ----
let qx = px.abs() - bx + eff_radius;
let qy = py.abs() - by + eff_radius;
‚ãÆ----
((qx * qx + qy * qy).sqrt()) - eff_radius
‚ãÆ----
qx.max(qy) - eff_radius
‚ãÆ----
let t = (d / 2.0).clamp(0.0, 1.0);
‚ãÆ----
let dist_in = d.abs();
let t_rough = (dist_in / (dynamic_base_scale * 1.4)).clamp(0.0, 1.0);
let base_intensity_rough = (1.0 - t_rough).powi(3);
‚ãÆ----
let angle = py.atan2(px);
let noise = (angle * 4.0 + time_rad * 2.0).sin() * 0.5;
‚ãÆ----
let t = (dist_in / local_glow_width).clamp(0.0, 1.0);
let intensity = (1.0 - t).powi(3);
‚ãÆ----
let deg = angle.to_degrees() + 180.0;
‚ãÆ----
let rgb = if dist_in < 2.5 { 0x00FFFFFF } else { hsv_to_rgb(hue, 0.8, 1.0) };
‚ãÆ----
pub unsafe fn draw_minimal_glow(
‚ãÆ----
for pixel in pixels.iter_mut() {
‚ãÆ----
let scan_y = margin + ((t * scan_range as f32) as i32).clamp(0, scan_range - 1);
</file>

<file path="src/overlay/process/mod.rs">
pub mod chain;
pub mod pipeline;
pub mod types;
pub mod window;
</file>

<file path="src/overlay/process/types.rs">
use std::sync::Mutex;
use crate::overlay::result::layout::calculate_next_window_rect;
‚ãÆ----
pub struct ProcessingState {
‚ãÆ----
unsafe impl Send for ProcessingState {}
unsafe impl Sync for ProcessingState {}
impl ProcessingState {
pub fn new(graphics_mode: String) -> Self {
‚ãÆ----
pub fn cleanup(&mut self) {
if !self.cache_hbm.is_invalid() {
unsafe { let _ = DeleteObject(self.cache_hbm.into()); }
‚ãÆ----
pub fn reset_window_position_queue() {
let mut last = LAST_WINDOW_RECT.lock().unwrap();
‚ãÆ----
pub fn get_next_window_position(initial_rect: RECT) -> RECT {
‚ãÆ----
let s_w = unsafe { GetSystemMetrics(SM_CXSCREEN) };
let s_h = unsafe { GetSystemMetrics(SM_CYSCREEN) };
‚ãÆ----
calculate_next_window_rect(prev, s_w, s_h)
‚ãÆ----
*last = Some(next_rect);
</file>

<file path="src/overlay/process/window.rs">
use windows::Win32::System::LibraryLoader::GetModuleHandleW;
‚ãÆ----
use std::collections::HashMap;
‚ãÆ----
pub unsafe fn create_processing_window(rect: RECT, graphics_mode: String) -> HWND {
let instance = GetModuleHandleW(None).unwrap();
let class_name = w!("SGTProcessingOverlay");
REGISTER_PROC_CLASS.call_once(|| {
‚ãÆ----
wc.lpfnWndProc = Some(processing_wnd_proc);
wc.hInstance = instance.into();
wc.hCursor = LoadCursorW(None, IDC_WAIT).unwrap();
‚ãÆ----
wc.hbrBackground = HBRUSH(std::ptr::null_mut());
RegisterClassW(&wc);
‚ãÆ----
let w = (rect.right - rect.left).abs();
let h = (rect.bottom - rect.top).abs();
‚ãÆ----
let hwnd = CreateWindowExW(
‚ãÆ----
class_name, w!("Processing"), WS_POPUP, rect.left, rect.top, w, h, None, None, Some(instance.into()), None
).unwrap_or_default();
let mut states = PROC_STATES.lock().unwrap();
states.insert(hwnd.0 as isize, ProcessingState::new(graphics_mode));
drop(states);
SetTimer(Some(hwnd), 1, timer_interval, None);
let _ = ShowWindow(hwnd, SW_SHOWNOACTIVATE);
‚ãÆ----
unsafe extern "system" fn processing_wnd_proc(hwnd: HWND, msg: u32, wparam: WPARAM, lparam: LPARAM) -> LRESULT {
‚ãÆ----
let state = states.entry(hwnd.0 as isize).or_insert(ProcessingState::new("standard".to_string()));
‚ãÆ----
let _ = KillTimer(Some(hwnd), 1); state.timer_killed = true;
SetTimer(Some(hwnd), 2, 25, None);
‚ãÆ----
LRESULT(0)
‚ãÆ----
let _ = KillTimer(Some(hwnd), 1); let _ = KillTimer(Some(hwnd), 2);
let _ = DestroyWindow(hwnd);
return LRESULT(0);
‚ãÆ----
let mut rect = RECT::default(); let _ = GetWindowRect(hwnd, &mut rect);
let w = (rect.right - rect.left).abs(); let h = (rect.bottom - rect.top).abs();
‚ãÆ----
let state = states.get_mut(&(hwnd.0 as isize)).unwrap();
‚ãÆ----
(MAX_GLOW_BUFFER_DIM as f32 / w as f32).min(MAX_GLOW_BUFFER_DIM as f32 / h as f32).min(1.0)
‚ãÆ----
let buf_w = ((w as f32) * scale_factor).ceil() as i32;
let buf_h = ((h as f32) * scale_factor).ceil() as i32;
if state.cache_hbm.is_invalid() || state.scaled_w != buf_w || state.scaled_h != buf_h {
state.cleanup();
let screen_dc = GetDC(None);
‚ãÆ----
let res = CreateDIBSection(Some(screen_dc), &bmi, DIB_RGB_COLORS, &mut state.cache_bits, None, 0);
ReleaseDC(None, screen_dc);
if let Ok(hbm) = res { if !hbm.is_invalid() && !state.cache_bits.is_null() { state.cache_hbm = hbm; state.scaled_w = buf_w; state.scaled_h = buf_h; } else { return LRESULT(0); } } else { return LRESULT(0); }
‚ãÆ----
if !is_fading && !state.cache_bits.is_null() {
‚ãÆ----
let scaled_dc = CreateCompatibleDC(Some(screen_dc)); SelectObject(scaled_dc, state.cache_hbm.into());
‚ãÆ----
let dest_hbm = CreateDIBSection(Some(screen_dc), &dest_bmi, DIB_RGB_COLORS, &mut dest_bits, None, 0);
‚ãÆ----
if !hbm.is_invalid() {
let dest_dc = CreateCompatibleDC(Some(screen_dc)); SelectObject(dest_dc, hbm.into());
SetStretchBltMode(dest_dc, HALFTONE); let _ = StretchBlt(dest_dc, 0, 0, w, h, Some(scaled_dc), 0, 0, state.scaled_w, state.scaled_h, SRCCOPY);
let _ = DeleteDC(scaled_dc); (Some((dest_dc, hbm)), w, h)
} else { let _ = DeleteDC(scaled_dc); (None, state.scaled_w, state.scaled_h) }
‚ãÆ----
let (mem_dc, old_hbm, temp_res) = if let Some((dc, hbm)) = final_hbm { (dc, HGDIOBJ::default(), Some(hbm)) } else { let dc = CreateCompatibleDC(Some(screen_dc)); let old = SelectObject(dc, state.cache_hbm.into()); (dc, old, None) };
‚ãÆ----
let _ = UpdateLayeredWindow(hwnd, None, None, Some(&size), Some(mem_dc), Some(&pt_src), COLORREF(0), Some(&blend), ULW_ALPHA);
if temp_res.is_some() { let _ = DeleteDC(mem_dc); if let Some(hbm) = temp_res { let _ = DeleteObject(hbm.into()); } } else { SelectObject(mem_dc, old_hbm); let _ = DeleteDC(mem_dc); }
‚ãÆ----
WM_PAINT => { let mut ps = PAINTSTRUCT::default(); BeginPaint(hwnd, &mut ps); let _ = EndPaint(hwnd, &mut ps); LRESULT(0) }
WM_DESTROY => { let mut states = PROC_STATES.lock().unwrap(); if let Some(mut state) = states.remove(&(hwnd.0 as isize)) { state.cleanup(); } LRESULT(0) }
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
</file>

<file path="src/overlay/result/event_handler/click_actions.rs">
use windows::Win32::UI::Input::KeyboardAndMouse::ReleaseCapture;
use std::mem::size_of;
use windows::Win32::Graphics::Gdi::InvalidateRect;
use windows::core::PCWSTR;
‚ãÆ----
use crate::overlay::result::markdown_view;
use crate::overlay::result::refine_input;
use crate::overlay::utils::to_wstring;
use super::misc::WM_CREATE_WEBVIEW;
pub unsafe fn handle_lbutton_up(hwnd: HWND) -> LRESULT {
let _ = ReleaseCapture();
‚ãÆ----
let mut states = WINDOW_STATES.lock().unwrap();
if let Some(state) = states.get_mut(&(hwnd.0 as isize)) {
‚ãÆ----
if let Some(last) = state.text_history.pop() {
let current_text_for_redo = state.full_text.clone();
prev_text = Some(last.clone());
‚ãÆ----
if !current_text_for_redo.is_empty() {
state.redo_history.push(current_text_for_redo);
‚ãÆ----
let wide_text = to_wstring(&txt);
let _ = SetWindowTextW(hwnd, PCWSTR(wide_text.as_ptr()));
‚ãÆ----
let _ = InvalidateRect(Some(hwnd), None, false);
‚ãÆ----
if let Some(redo_text) = state.redo_history.pop() {
let current_text_for_undo = state.full_text.clone();
next_text = Some(redo_text.clone());
‚ãÆ----
if !current_text_for_undo.is_empty() {
state.text_history.push(current_text_for_undo);
‚ãÆ----
let states = WINDOW_STATES.lock().unwrap();
if let Some(state) = states.get(&(hwnd.0 as isize)) {
‚ãÆ----
states.get(&(hwnd.0 as isize)).map(|s| s.is_hovered).unwrap_or(false)
‚ãÆ----
let app = crate::APP.lock().unwrap();
app.config.ui_language.clone()
‚ãÆ----
let text_len = GetWindowTextLengthW(hwnd) + 1;
let mut buf = vec![0u16; text_len as usize];
GetWindowTextW(hwnd, &mut buf);
let text = String::from_utf16_lossy(&buf[..text_len as usize - 1]).to_string();
‚ãÆ----
SetTimer(Some(hwnd), 1, 1500, None);
‚ãÆ----
(state.is_markdown_mode, state.full_text.clone())
‚ãÆ----
let _ = PostMessageW(Some(hwnd), WM_CREATE_WEBVIEW, WPARAM(0), LPARAM(0));
SetTimer(Some(hwnd), 2, 30, None);
‚ãÆ----
let _ = KillTimer(Some(hwnd), 2);
‚ãÆ----
let _ = TrackMouseEvent(&mut tme);
‚ãÆ----
state.full_text.clone()
‚ãÆ----
if !full_text.is_empty() {
‚ãÆ----
(state.full_text.clone(), state.tts_request_id, state.tts_loading)
‚ãÆ----
} else if current_tts_id != 0 && crate::api::tts::TTS_MANAGER.is_speaking(current_tts_id) {
crate::api::tts::TTS_MANAGER.stop();
‚ãÆ----
} else if !full_text.is_empty() {
‚ãÆ----
let request_id = crate::api::tts::TTS_MANAGER.speak(&full_text, hwnd.0 as isize);
‚ãÆ----
if let Some(state) = states.get(&(hwnd.0 as isize)) { state.linked_window } else { None }
‚ãÆ----
if IsWindow(Some(linked)).as_bool() {
let _ = PostMessageW(Some(linked), WM_CLOSE, WPARAM(0), LPARAM(0));
‚ãÆ----
let _ = PostMessageW(Some(hwnd), WM_CLOSE, WPARAM(0), LPARAM(0));
‚ãÆ----
LRESULT(0)
‚ãÆ----
pub unsafe fn handle_rbutton_up(hwnd: HWND) -> LRESULT {
‚ãÆ----
pub unsafe fn handle_mbutton_up() -> LRESULT {
‚ãÆ----
if let Ok(states) = WINDOW_STATES.lock() {
for (&hwnd_int, _) in states.iter() {
targets.push(HWND(hwnd_int as *mut std::ffi::c_void));
‚ãÆ----
if IsWindow(Some(target)).as_bool() {
let _ = PostMessageW(Some(target), WM_CLOSE, WPARAM(0), LPARAM(0));
</file>

<file path="src/overlay/result/event_handler/misc.rs">
use std::sync::Arc;
use crate::overlay::result::state::WINDOW_STATES;
use crate::overlay::result::paint;
use crate::overlay::result::markdown_view;
use crate::overlay::result::refine_input;
‚ãÆ----
pub unsafe fn handle_erase_bkgnd(_hwnd: HWND, _wparam: WPARAM) -> LRESULT {
LRESULT(1)
‚ãÆ----
pub unsafe fn handle_ctl_color_edit(wparam: WPARAM) -> LRESULT {
let hdc = HDC(wparam.0 as *mut core::ffi::c_void);
SetBkMode(hdc, OPAQUE);
SetBkColor(hdc, COLORREF(0x00FFFFFF));
SetTextColor(hdc, COLORREF(0x00000000));
let hbrush = GetStockObject(WHITE_BRUSH);
LRESULT(hbrush.0 as isize)
‚ãÆ----
pub unsafe fn handle_destroy(hwnd: HWND) -> LRESULT {
‚ãÆ----
let mut states = WINDOW_STATES.lock().unwrap();
if let Some(state) = states.remove(&(hwnd.0 as isize)) {
‚ãÆ----
crate::api::tts::TTS_MANAGER.stop_if_active(state.tts_request_id);
‚ãÆ----
token_to_signal = state.cancellation_token.clone();
‚ãÆ----
token.store(true, std::sync::atomic::Ordering::Relaxed);
windows_to_close = states.iter()
.filter(|(_, s)| {
‚ãÆ----
.map(|(k, _)| HWND(*k as *mut core::ffi::c_void))
.collect();
‚ãÆ----
if !state.content_bitmap.is_invalid() {
let _ = DeleteObject(state.content_bitmap.into());
‚ãÆ----
if !state.bg_bitmap.is_invalid() {
let _ = DeleteObject(state.bg_bitmap.into());
‚ãÆ----
if !state.edit_font.is_invalid() {
let _ = DeleteObject(state.edit_font.into());
‚ãÆ----
let _ = KillTimer(Some(hwnd), 2);
‚ãÆ----
let _ = PostMessageW(Some(other_hwnd), WM_CLOSE, WPARAM(0), LPARAM(0));
‚ãÆ----
LRESULT(0)
‚ãÆ----
pub unsafe fn handle_paint(hwnd: HWND) -> LRESULT {
‚ãÆ----
pub unsafe fn handle_keydown() -> LRESULT {
‚ãÆ----
pub unsafe fn handle_create_webview(hwnd: HWND) -> LRESULT {
‚ãÆ----
let states = WINDOW_STATES.lock().unwrap();
if let Some(state) = states.get(&(hwnd.0 as isize)) {
(state.full_text.clone(), state.is_hovered)
‚ãÆ----
if let Some(state) = states.get_mut(&(hwnd.0 as isize)) {
‚ãÆ----
let _ = InvalidateRect(Some(hwnd), None, false);
</file>

<file path="src/overlay/result/event_handler/mod.rs">
pub mod misc;
pub mod timer_tasks;
pub mod mouse_input;
pub mod click_actions;
pub unsafe extern "system" fn result_wnd_proc(hwnd: HWND, msg: u32, wparam: WPARAM, lparam: LPARAM) -> LRESULT {
‚ãÆ----
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
</file>

<file path="src/overlay/result/event_handler/mouse_input.rs">
use std::mem::size_of;
use std::sync::Arc;
‚ãÆ----
use crate::overlay::result::markdown_view;
use crate::overlay::result::refine_input;
unsafe fn set_rounded_edit_region(h_edit: HWND, w: i32, h: i32) {
let rgn = CreateRoundRectRgn(0, 0, w, h, 12, 12);
let _ = SetWindowRgn(h_edit, Some(rgn), true);
‚ãÆ----
pub unsafe fn handle_set_cursor(hwnd: HWND) -> LRESULT {
let mut cursor_id = PCWSTR(std::ptr::null());
‚ãÆ----
let _ = GetClientRect(hwnd, &mut rect);
‚ãÆ----
let _ = GetCursorPos(&mut pt);
let _ = ScreenToClient(hwnd, &mut pt);
‚ãÆ----
let states = WINDOW_STATES.lock().unwrap();
if let Some(state) = states.get(&(hwnd.0 as isize)) {
‚ãÆ----
SetCursor(Some(LoadCursorW(None, IDC_IBEAM).unwrap()));
return LRESULT(1);
‚ãÆ----
let edge = get_resize_edge(rect.right, rect.bottom, pt.x, pt.y);
‚ãÆ----
if should_show_buttons(rect.right, rect.bottom) {
let copy_rect = get_copy_btn_rect(rect.right, rect.bottom);
let edit_rect = get_edit_btn_rect(rect.right, rect.bottom);
let undo_rect = get_undo_btn_rect(rect.right, rect.bottom);
‚ãÆ----
has_history = !state.text_history.is_empty();
‚ãÆ----
let md_rect = get_markdown_btn_rect(rect.right, rect.bottom);
‚ãÆ----
let dl_rect = get_download_btn_rect(rect.right, rect.bottom);
‚ãÆ----
let speaker_rect = get_speaker_btn_rect(rect.right, rect.bottom);
‚ãÆ----
if !cursor_id.0.is_null() {
SetCursor(Some(LoadCursorW(None, cursor_id).unwrap()));
LRESULT(1)
‚ãÆ----
SetCursor(Some(HCURSOR(std::ptr::null_mut())));
‚ãÆ----
pub unsafe fn handle_lbutton_down(hwnd: HWND, lparam: LPARAM) -> LRESULT {
‚ãÆ----
let edge = get_resize_edge(width, height, x, y);
‚ãÆ----
let _ = GetWindowRect(hwnd, &mut window_rect);
‚ãÆ----
let _ = GetCursorPos(&mut screen_pt);
let mut states = WINDOW_STATES.lock().unwrap();
if let Some(state) = states.get_mut(&(hwnd.0 as isize)) {
‚ãÆ----
SetCapture(hwnd);
LRESULT(0)
‚ãÆ----
pub unsafe fn handle_rbutton_down(hwnd: HWND, _lparam: LPARAM) -> LRESULT {
‚ãÆ----
token_to_match = state.cancellation_token.clone();
‚ãÆ----
for (&h_val, s) in states.iter() {
‚ãÆ----
let h = HWND(h_val as *mut std::ffi::c_void);
‚ãÆ----
let _ = GetWindowRect(h, &mut r);
group_snapshot.push((h, r));
‚ãÆ----
if group_snapshot.len() <= 1 {
group_snapshot.clear();
‚ãÆ----
queue.push_back(hwnd);
visited.insert(hwnd.0);
while let Some(current) = queue.pop_front() {
‚ãÆ----
let _ = GetWindowRect(current, &mut r);
group_snapshot.push((current, r));
if let Some(s) = states.get(&(current.0 as isize)) {
‚ãÆ----
if states.contains_key(&(linked.0 as isize)) {
if !visited.contains(&linked.0) {
visited.insert(linked.0);
queue.push_back(linked);
‚ãÆ----
pub unsafe fn handle_mouse_move(hwnd: HWND, lparam: LPARAM) -> LRESULT {
‚ãÆ----
let hover_edge = get_resize_edge(rect.right, rect.bottom, x as i32, y as i32);
‚ãÆ----
let drag_impulse = if matches!(&state.interaction_mode, InteractionMode::DraggingWindow | InteractionMode::DraggingGroup(_)) { 0.0 } else { (dx * 1.5).clamp(-20.0, 20.0) };
‚ãÆ----
state.physics.current_tilt = state.physics.current_tilt.clamp(-22.5, 22.5);
‚ãÆ----
if !state.text_history.is_empty() && !state.is_browsing {
‚ãÆ----
let redo_rect = get_redo_btn_rect(rect.right, rect.bottom);
if !state.redo_history.is_empty() && !state.is_browsing {
‚ãÆ----
let _ = TrackMouseEvent(&mut tme);
‚ãÆ----
let _ = GetCursorPos(&mut curr_pt);
‚ãÆ----
if dx.abs() > 3 || dy.abs() > 3 { state.has_moved_significantly = true; }
‚ãÆ----
let _ = SetWindowPos(hwnd, Some(HWND::default()), new_x, new_y, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
‚ãÆ----
group_moves.push((*h, new_x, new_y));
‚ãÆ----
ResizeEdge::Right | ResizeEdge::TopRight | ResizeEdge::BottomRight => { new_rect.right = (state.drag_start_window_rect.right + dx).max(state.drag_start_window_rect.left + min_w); }
ResizeEdge::Left | ResizeEdge::TopLeft | ResizeEdge::BottomLeft => { new_rect.left = (state.drag_start_window_rect.left + dx).min(state.drag_start_window_rect.right - min_w); }
‚ãÆ----
ResizeEdge::Bottom | ResizeEdge::BottomRight | ResizeEdge::BottomLeft => { new_rect.bottom = (state.drag_start_window_rect.bottom + dy).max(state.drag_start_window_rect.top + min_h); }
ResizeEdge::Top | ResizeEdge::TopLeft | ResizeEdge::TopRight => { new_rect.top = (state.drag_start_window_rect.top + dy).min(state.drag_start_window_rect.bottom - min_h); }
‚ãÆ----
let _ = SetWindowPos(hwnd, Some(HWND::default()), new_rect.left, new_rect.top, w, h, SWP_NOZORDER | SWP_NOACTIVATE);
‚ãÆ----
let _ = SetWindowPos(state.edit_hwnd, Some(HWND_TOP), 10, 10, edit_w, edit_h, SWP_NOACTIVATE);
set_rounded_edit_region(state.edit_hwnd, edit_w, edit_h);
‚ãÆ----
let _ = InvalidateRect(Some(hwnd), None, false);
‚ãÆ----
let _ = SetWindowPos(h, Some(HWND::default()), x, y, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
‚ãÆ----
pub unsafe fn handle_mouse_leave(hwnd: HWND) -> LRESULT {
</file>

<file path="src/overlay/result/event_handler/timer_tasks.rs">
use windows::Win32::Graphics::Gdi::InvalidateRect;
use windows::core::PCWSTR;
‚ãÆ----
use crate::overlay::result::markdown_view;
use crate::overlay::result::refine_input;
use super::super::logic;
use crate::overlay::utils::to_wstring;
‚ãÆ----
pub unsafe fn handle_timer(hwnd: HWND, wparam: WPARAM) -> LRESULT {
‚ãÆ----
let _ = GetCursorPos(&mut cursor_pos);
‚ãÆ----
let _ = GetWindowRect(hwnd, &mut window_rect);
‚ãÆ----
let states = WINDOW_STATES.lock().unwrap();
if let Some(state) = states.get(&(hwnd.0 as isize)) {
‚ãÆ----
let mut states = WINDOW_STATES.lock().unwrap();
if let Some(state) = states.get_mut(&(hwnd.0 as isize)) {
‚ãÆ----
let _ = InvalidateRect(Some(hwnd), None, false);
‚ãÆ----
return LRESULT(0);
‚ãÆ----
.duration_since(UNIX_EPOCH)
.map(|d| d.as_millis() as u32)
.unwrap_or(0);
‚ãÆ----
if state.pending_text.is_some() &&
(state.last_text_update_time == 0 || now.wrapping_sub(state.last_text_update_time) > 16) {
pending_update = state.pending_text.take();
‚ãÆ----
if submitted && !input_text.trim().is_empty() {
‚ãÆ----
text_to_refine = state.full_text.clone();
state.text_history.push(text_to_refine.clone());
state.redo_history.clear();
state.input_text = text_to_refine.clone();
‚ãÆ----
state.pending_text = Some(String::new());
‚ãÆ----
states.get(&(hwnd.0 as isize)).map(|s| s.is_hovered).unwrap_or(false)
‚ãÆ----
let wide_text = to_wstring(&txt);
let _ = SetWindowTextW(hwnd, PCWSTR(wide_text.as_ptr()));
‚ãÆ----
state.full_text = txt.clone();
‚ãÆ----
(Some(state.full_text.clone()), state.is_hovered)
‚ãÆ----
if trigger_refine && !user_input.trim().is_empty() {
‚ãÆ----
if let Some(s) = states.get(&(hwnd.0 as isize)) {
(s.context_data.clone(), s.model_id.clone(), s.provider.clone(), s.streaming_enabled, s.preset_prompt.clone())
‚ãÆ----
(RefineContext::None, "scout".to_string(), "groq".to_string(), false, "".to_string())
‚ãÆ----
let (final_prev_text, final_user_prompt) = if text_to_refine.trim().is_empty() && !preset_prompt.is_empty() {
‚ãÆ----
let capture_hwnd = HWND(hwnd_val as *mut std::ffi::c_void);
‚ãÆ----
let app = crate::APP.lock().unwrap();
(app.config.api_key.clone(), app.config.gemini_api_key.clone())
‚ãÆ----
&app.config.ui_language.clone()
‚ãÆ----
if let Some(state) = states.get_mut(&(capture_hwnd.0 as isize)) {
‚ãÆ----
if chunk.starts_with(crate::api::WIPE_SIGNAL) {
acc_text.clear();
acc_text.push_str(&chunk[crate::api::WIPE_SIGNAL.len()..]);
‚ãÆ----
acc_text.push_str(chunk);
‚ãÆ----
state.pending_text = Some(acc_text.clone());
state.full_text = acc_text.clone();
‚ãÆ----
state.full_text = final_text.clone();
state.pending_text = Some(final_text);
‚ãÆ----
.map(|m| m.full_name)
.unwrap_or_else(|| model_id.to_string());
(app.config.ui_language.clone(), full_name)
‚ãÆ----
let err_msg = crate::overlay::utils::get_error_message(&e.to_string(), &lang, Some(&model_full_name));
state.pending_text = Some(err_msg.clone());
‚ãÆ----
LRESULT(0)
</file>

<file path="src/overlay/result/layout.rs">
pub fn should_show_buttons(window_w: i32, _window_h: i32) -> bool {
‚ãÆ----
fn rects_overlap(a: &RECT, b: &RECT, gap: i32) -> bool {
‚ãÆ----
fn get_all_active_window_rects() -> Vec<RECT> {
‚ãÆ----
if let Ok(states) = WINDOW_STATES.lock() {
for (&hwnd_key, _state) in states.iter() {
let hwnd = HWND(hwnd_key as *mut std::ffi::c_void);
‚ãÆ----
if IsWindow(Some(hwnd)).as_bool() {
‚ãÆ----
if GetWindowRect(hwnd, &mut rect).is_ok() {
rects.push(rect);
‚ãÆ----
fn would_overlap_existing(proposed: &RECT, existing: &[RECT], gap: i32) -> bool {
existing.iter().any(|r| rects_overlap(proposed, r, gap))
‚ãÆ----
pub fn calculate_next_window_rect(prev: RECT, screen_w: i32, screen_h: i32) -> RECT {
‚ãÆ----
let w = (prev.right - prev.left).abs();
let h = (prev.bottom - prev.top).abs();
let existing_windows = get_all_active_window_rects();
‚ãÆ----
&& !would_overlap_existing(&right_candidate, &existing_windows, gap) {
‚ãÆ----
&& !would_overlap_existing(&bottom_candidate, &existing_windows, gap) {
‚ãÆ----
&& !would_overlap_existing(&left_candidate, &existing_windows, gap) {
‚ãÆ----
&& !would_overlap_existing(&top_candidate, &existing_windows, gap) {
‚ãÆ----
&& !would_overlap_existing(&diag, &existing_windows, gap) {
‚ãÆ----
&& !would_overlap_existing(&cascade, &existing_windows, gap) {
‚ãÆ----
pub fn get_copy_btn_rect(window_w: i32, window_h: i32) -> RECT {
‚ãÆ----
pub fn get_edit_btn_rect(window_w: i32, window_h: i32) -> RECT {
let speaker_rect = get_speaker_btn_rect(window_w, window_h);
‚ãÆ----
pub fn get_markdown_btn_rect(window_w: i32, window_h: i32) -> RECT {
let edit_rect = get_edit_btn_rect(window_w, window_h);
‚ãÆ----
pub fn get_download_btn_rect(window_w: i32, window_h: i32) -> RECT {
let md_rect = get_markdown_btn_rect(window_w, window_h);
‚ãÆ----
pub fn get_undo_btn_rect(window_w: i32, window_h: i32) -> RECT {
let dl_rect = get_download_btn_rect(window_w, window_h);
‚ãÆ----
pub fn get_redo_btn_rect(window_w: i32, window_h: i32) -> RECT {
let undo_rect = get_undo_btn_rect(window_w, window_h);
‚ãÆ----
pub fn get_speaker_btn_rect(window_w: i32, window_h: i32) -> RECT {
let copy_rect = get_copy_btn_rect(window_w, window_h);
‚ãÆ----
pub fn get_resize_edge(width: i32, height: i32, x: i32, y: i32) -> ResizeEdge {
</file>

<file path="src/overlay/result/logic.rs">
fn rand_float(min: f32, max: f32) -> f32 {
‚ãÆ----
SEED = SEED.wrapping_mul(1103515245).wrapping_add(12345);
‚ãÆ----
pub fn handle_timer(hwnd: HWND, wparam: WPARAM) {
‚ãÆ----
let mut states = WINDOW_STATES.lock().unwrap();
if let Some(state) = states.get_mut(&(hwnd.0 as isize)) {
‚ãÆ----
for mut pt in p.particles.drain(..) {
‚ãÆ----
if pt.life > 0.0 { keep.push(pt); }
‚ãÆ----
let _ = GetClientRect(hwnd, &mut client_rect);
‚ãÆ----
let _ = InvalidateRect(Some(hwnd), Some(&bottom_region), false);
‚ãÆ----
let _ = InvalidateRect(Some(hwnd), Some(&left_margin), false);
‚ãÆ----
let _ = InvalidateRect(Some(hwnd), Some(&right_margin), false);
‚ãÆ----
let _ = InvalidateRect(Some(hwnd), None, false);
‚ãÆ----
let _ = SetLayeredWindowAttributes(hwnd, COLORREF(0), 0, LWA_ALPHA);
‚ãÆ----
let states = WINDOW_STATES.lock().unwrap();
if let Some(state) = states.get(&(hwnd.0 as isize)) { state.linked_window } else { None }
‚ãÆ----
if IsWindow(Some(linked)).as_bool() {
let _ = SetLayeredWindowAttributes(linked, COLORREF(0), 0, LWA_ALPHA);
let _ = PostMessageW(Some(linked), WM_CLOSE, WPARAM(0), LPARAM(0));
‚ãÆ----
let _ = PostMessageW(Some(hwnd), WM_CLOSE, WPARAM(0), LPARAM(0));
‚ãÆ----
let _ = KillTimer(Some(hwnd), 1);
‚ãÆ----
state.physics.particles.push(DustParticle {
x: cx + rand_float(-10.0, 10.0),
‚ãÆ----
vx: rand_float(-2.0, 2.0),
vy: rand_float(-2.0, -5.0),
‚ãÆ----
size: rand_float(1.0, 3.0),
</file>

<file path="src/overlay/result/mod.rs">
pub mod state;
pub mod paint;
mod logic;
pub mod layout;
mod window;
mod event_handler;
pub mod markdown_view;
pub mod refine_input;
</file>

<file path="src/win_types.rs">
use windows::Win32::UI::WindowsAndMessaging::HHOOK;
use windows::Win32::Graphics::Gdi::HBITMAP;
‚ãÆ----
pub struct SendHwnd(pub HWND);
unsafe impl Send for SendHwnd {}
unsafe impl Sync for SendHwnd {}
impl Default for SendHwnd {
fn default() -> Self {
SendHwnd(HWND::default())
‚ãÆ----
impl SendHwnd {
pub fn is_invalid(&self) -> bool {
self.0.is_invalid()
‚ãÆ----
pub fn as_isize(&self) -> isize {
‚ãÆ----
pub fn from_isize(val: isize) -> Self {
SendHwnd(HWND(val as *mut std::ffi::c_void))
‚ãÆ----
pub struct SendHandle(pub HANDLE);
unsafe impl Send for SendHandle {}
unsafe impl Sync for SendHandle {}
impl SendHandle {
‚ãÆ----
pub struct SendHhook(pub HHOOK);
unsafe impl Send for SendHhook {}
unsafe impl Sync for SendHhook {}
impl Default for SendHhook {
‚ãÆ----
SendHhook(HHOOK::default())
‚ãÆ----
pub struct SendHbitmap(pub HBITMAP);
unsafe impl Send for SendHbitmap {}
unsafe impl Sync for SendHbitmap {}
impl Default for SendHbitmap {
‚ãÆ----
SendHbitmap(HBITMAP::default())
‚ãÆ----
impl SendHbitmap {
</file>

<file path=".gitignore">
/target
Cargo.lock
.env
.DS_Store
*.swp
*.swo
tools/

# Cursor build artifacts
build_cursor.exe
cursor_data.txt
broom.cur
screen-goated-toolbox-*.exe

# Patched dependencies (cloned by scripts/setup-egui-snarl.ps1)
libs/egui-snarl/

# PromptDJ artifacts
src/overlay/prompt_dj/dist/

# Agent specific files
.agent/
</file>

<file path="build.rs">
use std::fs;
‚ãÆ----
use std::path::Path;
fn main() {
let manifest_dir = std::env::var("CARGO_MANIFEST_DIR").unwrap();
println!("cargo::rustc-check-cfg=cfg(nopack)");
let assets_dir = Path::new(&manifest_dir).join("assets");
‚ãÆ----
.join("assets")
.join("tray-icon.png");
if tray_source.exists() {
let tray_icon_path = assets_dir.join("tray_icon.png");
‚ãÆ----
let resized = img.resize(32, 32, image::imageops::FilterType::Lanczos3);
let _ = resized.save_with_format(&tray_icon_path, image::ImageFormat::Png);
‚ãÆ----
let app_icon_path = assets_dir.join("app-icon-small.png");
let app_icon_small_path = assets_dir.join("app-icon-small.png");
if app_icon_path.exists() {
‚ãÆ----
let resized = img.resize(256, 256, image::imageops::FilterType::Lanczos3);
let _ = resized.save(&app_icon_small_path);
‚ãÆ----
if app_icon_small_path.exists() {
let ico_path = assets_dir.join("app.ico");
create_multi_size_ico(&app_icon_small_path, &ico_path);
‚ãÆ----
let ico_path = Path::new(&manifest_dir).join("assets").join("app.ico");
let rc_path = Path::new(&manifest_dir).join("app.rc");
if ico_path.exists() && rc_path.exists() {
let out_dir = std::env::var("OUT_DIR").unwrap();
let res_path = Path::new(&out_dir).join("resources.o");
‚ãÆ----
.arg(&rc_path)
.arg("-o")
.arg(&res_path)
.status();
‚ãÆ----
Ok(s) if s.success() => {
println!("cargo:rustc-link-arg={}", res_path.display());
‚ãÆ----
panic!("windres failed with exit code: {}", s);
‚ãÆ----
panic!("Failed to execute windres: {}", e);
‚ãÆ----
println!("cargo:rerun-if-changed=assets/app-icon-small.png");
println!("cargo:rerun-if-changed=icon.png");
println!("cargo:rerun-if-changed=app.rc");
println!("cargo:rerun-if-changed=build.rs");
‚ãÆ----
fn create_multi_size_ico(png_path: &Path, ico_path: &Path) {
let img = image::open(png_path).expect("Failed to open PNG");
let mut file = fs::File::create(ico_path).expect("Failed to create ICO");
‚ãÆ----
let num_images = sizes.len() as u16;
file.write_all(&[0, 0]).unwrap();
file.write_all(&[1, 0]).unwrap();
file.write_all(&num_images.to_le_bytes()).unwrap();
‚ãÆ----
let resized = img.resize(size, size, image::imageops::FilterType::Lanczos3);
‚ãÆ----
.write_to(&mut buffer, image::ImageFormat::Png)
.unwrap();
data = buffer.into_inner();
‚ãÆ----
let rgba = resized.to_rgba8();
data.extend_from_slice(&40u32.to_le_bytes());
data.extend_from_slice(&(size as i32).to_le_bytes());
data.extend_from_slice(&(size as i32 * 2).to_le_bytes());
data.extend_from_slice(&[1, 0]);
data.extend_from_slice(&[32, 0]);
data.extend_from_slice(&[0, 0, 0, 0]);
‚ãÆ----
for row in (0..rgba.height()).rev() {
for col in 0..rgba.width() {
let pixel = rgba.get_pixel(col, row);
data.push(pixel[2]);
data.push(pixel[1]);
data.push(pixel[0]);
data.push(pixel[3]);
‚ãÆ----
data.push(0);
‚ãÆ----
images_data.push(data);
‚ãÆ----
for (i, size) in sizes.iter().enumerate() {
‚ãÆ----
let data_size = images_data[i].len() as u32;
file.write_all(&[width]).unwrap();
file.write_all(&[height]).unwrap();
file.write_all(&[0]).unwrap();
‚ãÆ----
file.write_all(&[32, 0]).unwrap();
file.write_all(&data_size.to_le_bytes()).unwrap();
file.write_all(&offset.to_le_bytes()).unwrap();
‚ãÆ----
file.write_all(&data).unwrap();
</file>

<file path="promptdj-midi/.gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="promptdj-midi/components/PlayPauseButton.ts">
import { svg, css, html, LitElement } from 'lit';
import { customElement, property } from 'lit/decorators.js';
import type { PlaybackState } from '../types';
‚ãÆ----
export class PlayPauseButton extends LitElement
‚ãÆ----
private renderSvg()
private renderPause()
private renderPlay()
private renderLoading()
private renderIcon()
override render()
‚ãÆ----
interface HTMLElementTagNameMap {
    'play-pause-button': PlayPauseButton
  }
</file>

<file path="promptdj-midi/components/PlayPauseMorphWrapper.tsx">
import { createRoot, Root } from 'react-dom/client';
import PlayPauseMorphType4 from './react/PlayPauseMorphType4.jsx';
import LoadingIndicator from './react/LoadingIndicator.jsx';
‚ãÆ----
static get observedAttributes()
connectedCallback()
attributeChangedCallback(name: string, _oldVal: string | null, newVal: string | null)
disconnectedCallback()
</file>

<file path="promptdj-midi/components/react/LoadingIndicator.css">
.loading-indicator {
.loading-indicator-canvas {
</file>

<file path="promptdj-midi/components/react/LoadingIndicator.jsx">
const LoadingIndicator = ({
‚ãÆ----
const canvasRef = useRef(null);
const animationRef = useRef(null);
const [isLoaded, setIsLoaded] = useState(false);
// Colors from Figma design - all 4 variants
‚ãÆ----
// Container colors
‚ãÆ----
const animationState = useRef({
‚ãÆ----
const getShapeColor = useCallback(() => {
‚ãÆ----
const drawMaterial3Container = useCallback((ctx) => {
‚ãÆ----
const canvasSize = Math.round(size * scaleFactor);
‚ãÆ----
const radius = Math.min(canvasSize, canvasSize) * 0.45;
ctx.save();
ctx.translate(centerX, centerY);
ctx.beginPath();
ctx.arc(0, 0, radius, 0, 2 * Math.PI);
‚ãÆ----
ctx.fill();
ctx.restore();
‚ãÆ----
const applyMaterial3ExpressiveEffects = useCallback((ctx) => {
‚ãÆ----
const bounce = Math.sin(bouncePhase * Math.PI * 2.5);
‚ãÆ----
ctx.rotate((state.rotationAngle * Math.PI) / 180);
‚ãÆ----
scaleVariation = 0.015 + Math.sin(state.animationTime * 4) * 0.005;
‚ãÆ----
scaleVariation = 0.015 + Math.sin(bouncePhase * Math.PI) * 0.025;
‚ãÆ----
syncedScale = baseScale + Math.sin(state.animationTime * 1.2) * 0.05;
‚ãÆ----
ctx.scale(syncedScale, syncedScale);
‚ãÆ----
state.pulseValue = 0.7 + Math.sin(state.animationTime * 3) * 0.2;
‚ãÆ----
const drawPolygonWithEffects = useCallback((polygon, ctx) => {
const color = getShapeColor();
drawPolygon(polygon, color, ctx);
‚ãÆ----
const drawCubicsWithEffects = useCallback((cubics, ctx) => {
‚ãÆ----
drawCubics(cubics, color, ctx);
‚ãÆ----
const drawCurrentShape = useCallback((ctx) => {
‚ãÆ----
ctx.clearRect(0, 0, canvasSize, canvasSize);
‚ãÆ----
drawMaterial3Container(ctx);
‚ãÆ----
ctx.translate(canvasSize / 2, canvasSize / 2);
applyMaterial3ExpressiveEffects(ctx);
‚ãÆ----
drawPolygonWithEffects(shape, ctx);
‚ãÆ----
const drawMorphedShape = useCallback((ctx) => {
‚ãÆ----
const morphedCubics = state.currentMorph.asCubics(state.morphProgress);
drawCubicsWithEffects(morphedCubics, ctx);
‚ãÆ----
const drawPolygon = useCallback((polygon, color, ctx) => {
‚ãÆ----
drawCubics(polygon.cubics, color, ctx);
‚ãÆ----
const drawCubics = useCallback((cubics, color, ctx) => {
‚ãÆ----
ctx.moveTo(firstCubic.anchor0X, firstCubic.anchor0Y);
‚ãÆ----
ctx.bezierCurveTo(
‚ãÆ----
ctx.closePath();
‚ãÆ----
const generateRandomShapeOrder = useCallback((shapeCount) => {
const indices = Array.from({ length: shapeCount }, (_, i) => i);
‚ãÆ----
const j = Math.floor(Math.random() * (i + 1));
‚ãÆ----
const startAnimation = useCallback((ctx, Morph) => {
‚ãÆ----
state.shapeOrder = generateRandomShapeOrder(state.morphShapes.length);
‚ãÆ----
const animate = () => {
‚ãÆ----
state.currentMorph = new Morph(startShape, endShape);
‚ãÆ----
morphIncrement = Math.max(morphIncrement, 0.001);
‚ãÆ----
drawMorphedShape(ctx);
‚ãÆ----
drawCurrentShape(ctx);
‚ãÆ----
animationRef.current = requestAnimationFrame(animate);
‚ãÆ----
animate();
‚ãÆ----
const initializeAnimation = useCallback(async (ctx) => {
‚ãÆ----
const [, , { RoundedPolygon }, { Morph }] = await Promise.all([
‚ãÆ----
shapes.push(createFallbackShape(i, RoundedPolygon));
‚ãÆ----
setIsLoaded(true);
startAnimation(ctx, Morph);
‚ãÆ----
console.error('‚ùå Failed to load REAL animation modules:', error);
setIsLoaded(false);
‚ãÆ----
const createFallbackShape = (index, RoundedPolygon) => {
‚ãÆ----
case 0: return new RoundedPolygon(new Float32Array([0, -20, 17, 10, -17, 10]), 6);
case 1: return new RoundedPolygon(new Float32Array([-15, -15, 15, -15, 15, 15, -15, 15]), 8);
case 2: return new RoundedPolygon(new Float32Array([0, -17, 16, -5, 10, 14, -10, 14, -16, -5]), 5);
case 3: return createStarPolygon(15, 5, RoundedPolygon);
case 4: return new RoundedPolygon(new Float32Array([20, 0, 10, 17, -10, 17, -20, 0, -10, -17, 10, -17]), 4);
case 5: return createCirclePolygon(15, 8, RoundedPolygon);
case 6: return createStarPolygon(18, 6, RoundedPolygon);
case 7: return createDiamondShape(18, RoundedPolygon);
case 8: return createCrossShape(16, RoundedPolygon);
case 9: return createArrowShape(18, RoundedPolygon);
case 10: return createStarPolygon(14, 4, RoundedPolygon);
case 11: return createOvalShape(18, 12, RoundedPolygon);
case 12: return createTearDropShape(16, RoundedPolygon);
case 13: return createMoonShape(16, RoundedPolygon);
case 14: return createFlowerShape(15, RoundedPolygon);
case 15: return createHouseShape(16, RoundedPolygon);
case 16: return createSpadeShape(16, RoundedPolygon);
case 17: return createInfinityShape(18, RoundedPolygon);
case 18: return createGearShape(16, RoundedPolygon);
case 19: return createSunShape(17, RoundedPolygon);
case 20: return createBoltShape(18, RoundedPolygon);
case 21: return createWaveShape(20, RoundedPolygon);
case 22: return createRingShape(16, RoundedPolygon);
case 23: return createPillShape(18, RoundedPolygon);
case 24: return createBoneShape(18, RoundedPolygon);
case 25: return createMountainShape(14, RoundedPolygon);
case 26: return createFishShape(18, RoundedPolygon);
case 27: return createTreeShape(17, RoundedPolygon);
case 28: return createCactusShape(15, RoundedPolygon);
case 29: return createCupShape(15, RoundedPolygon);
case 30: return createBottleShape(14, RoundedPolygon);
case 31: return createBookShape(16, RoundedPolygon);
case 32: return createPhoneShape(14, RoundedPolygon);
case 33: return createCameraShape(16, RoundedPolygon);
case 34: return createPuzzlePieceShape(16, RoundedPolygon);
case 35: return createAnchorShape(16, RoundedPolygon);
case 36: return createCrownShape(17, RoundedPolygon);
case 37: return createStarPolygon(12, 8, RoundedPolygon);
default: return createCirclePolygon(15, 8, RoundedPolygon);
‚ãÆ----
const createCirclePolygon = (radius, sides, RoundedPolygon) => {
const vertices = new Float32Array(sides * 2);
‚ãÆ----
vertices[i * 2] = Math.cos(angle) * radius;
vertices[i * 2 + 1] = Math.sin(angle) * radius;
‚ãÆ----
return new RoundedPolygon(vertices, 3);
‚ãÆ----
const createStarPolygon = (radius, points, RoundedPolygon) => {
const vertices = new Float32Array(points * 4);
‚ãÆ----
vertices[vertexIndex++] = Math.cos(outerAngle) * radius;
vertices[vertexIndex++] = Math.sin(outerAngle) * radius;
‚ãÆ----
vertices[vertexIndex++] = Math.cos(innerAngle) * innerRadius;
vertices[vertexIndex++] = Math.sin(innerAngle) * innerRadius;
‚ãÆ----
return new RoundedPolygon(vertices, 2);
‚ãÆ----
const createDiamondShape = (size, RoundedPolygon) => {
const vertices = new Float32Array([0, -size, size, 0, 0, size, -size, 0]);
return new RoundedPolygon(vertices, 4);
‚ãÆ----
const createCrossShape = (size, RoundedPolygon) => {
‚ãÆ----
const vertices = new Float32Array([
‚ãÆ----
const createArrowShape = (size, RoundedPolygon) => {
‚ãÆ----
const createOvalShape = (width, height, RoundedPolygon) => {
‚ãÆ----
vertices[i * 2] = Math.cos(angle) * width;
vertices[i * 2 + 1] = Math.sin(angle) * height;
‚ãÆ----
return new RoundedPolygon(vertices, 1);
‚ãÆ----
const createTearDropShape = (size, RoundedPolygon) => {
‚ãÆ----
return new RoundedPolygon(vertices, 6);
‚ãÆ----
const createMoonShape = (size, RoundedPolygon) => {
‚ãÆ----
return new RoundedPolygon(vertices, 5);
‚ãÆ----
const createFlowerShape = (size, RoundedPolygon) => {
‚ãÆ----
const vertices = new Float32Array(petals * 4);
‚ãÆ----
const petalTipX = Math.cos(angle) * size;
const petalTipY = Math.sin(angle) * size;
const petalBaseX = Math.cos(angle) * size * 0.3;
const petalBaseY = Math.sin(angle) * size * 0.3;
‚ãÆ----
const createHouseShape = (size, RoundedPolygon) => {
‚ãÆ----
const createSpadeShape = (size, RoundedPolygon) => {
‚ãÆ----
const createInfinityShape = (size, RoundedPolygon) => {
‚ãÆ----
return new RoundedPolygon(vertices, 8);
‚ãÆ----
const createGearShape = (size, RoundedPolygon) => {
‚ãÆ----
const vertices = new Float32Array(teeth * 4);
‚ãÆ----
vertices[vertexIndex++] = Math.cos(baseAngle) * innerRadius;
vertices[vertexIndex++] = Math.sin(baseAngle) * innerRadius;
vertices[vertexIndex++] = Math.cos(toothAngle) * outerRadius;
vertices[vertexIndex++] = Math.sin(toothAngle) * outerRadius;
‚ãÆ----
const createSunShape = (size, RoundedPolygon) => {
‚ãÆ----
const vertices = new Float32Array(rays * 4);
‚ãÆ----
vertices[vertexIndex++] = Math.cos(rayAngle) * outerRadius;
vertices[vertexIndex++] = Math.sin(rayAngle) * outerRadius;
‚ãÆ----
const createBoltShape = (size, RoundedPolygon) => {
‚ãÆ----
const createLeafShape = (size, RoundedPolygon) => {
‚ãÆ----
const createEyeShape = (size, RoundedPolygon) => {
‚ãÆ----
const createWaveShape = (size, RoundedPolygon) => {
‚ãÆ----
return new RoundedPolygon(vertices, 7);
‚ãÆ----
const createRingShape = (size, RoundedPolygon) => {
‚ãÆ----
const vertices = new Float32Array((outerSides + innerSides) * 2);
‚ãÆ----
vertices[vertexIndex++] = Math.cos(angle) * outerRadius;
vertices[vertexIndex++] = Math.sin(angle) * outerRadius;
‚ãÆ----
vertices[vertexIndex++] = Math.cos(angle) * innerRadius;
vertices[vertexIndex++] = Math.sin(angle) * innerRadius;
‚ãÆ----
const createCrescentShape = (size, RoundedPolygon) => {
‚ãÆ----
const createPillShape = (size, RoundedPolygon) => {
‚ãÆ----
const createBoneShape = (size, RoundedPolygon) => {
‚ãÆ----
const createKeyShape = (size, RoundedPolygon) => {
‚ãÆ----
const createLockShape = (size, RoundedPolygon) => {
‚ãÆ----
const createMountainShape = (size, RoundedPolygon) => {
‚ãÆ----
const createFishShape = (size, RoundedPolygon) => {
‚ãÆ----
const createBirdShape = (size, RoundedPolygon) => {
‚ãÆ----
const createTreeShape = (size, RoundedPolygon) => {
‚ãÆ----
const createCactusShape = (size, RoundedPolygon) => {
‚ãÆ----
const createCupShape = (size, RoundedPolygon) => {
‚ãÆ----
const createBottleShape = (size, RoundedPolygon) => {
‚ãÆ----
const createBookShape = (size, RoundedPolygon) => {
‚ãÆ----
const createPhoneShape = (size, RoundedPolygon) => {
‚ãÆ----
const createCameraShape = (size, RoundedPolygon) => {
‚ãÆ----
const createPuzzlePieceShape = (size, RoundedPolygon) => {
‚ãÆ----
const createRocketShape = (size, RoundedPolygon) => {
‚ãÆ----
const createAnchorShape = (size, RoundedPolygon) => {
‚ãÆ----
const createCrownShape = (size, RoundedPolygon) => {
‚ãÆ----
useEffect(() => {
‚ãÆ----
const ctx = canvas.getContext('2d');
‚ãÆ----
ctx.scale(dpr, dpr);
initializeAnimation(ctx);
‚ãÆ----
cancelAnimationFrame(animationRef.current);
‚ãÆ----
const ctx = canvasRef.current.getContext('2d');
</file>

<file path="promptdj-midi/components/react/LoadingIndicator/cubic.js">
export class Cubic {
‚ãÆ----
constructor(points = new Float32Array(8), anchor0Y, control0X, control0Y, control1X, control1Y, anchor1X, anchor1Y) {
‚ãÆ----
this.points = new Float32Array([
‚ãÆ----
throw new Error("Points array size should be 8");
‚ãÆ----
this.points = points instanceof Float32Array ? points : new Float32Array(points);
‚ãÆ----
get anchor0X() { return this.points[0]; }
get anchor0Y() { return this.points[1]; }
get control0X() { return this.points[2]; }
get control0Y() { return this.points[3]; }
get control1X() { return this.points[4]; }
get control1Y() { return this.points[5]; }
get anchor1X() { return this.points[6]; }
get anchor1Y() { return this.points[7]; }
pointOnCurve(t) {
‚ãÆ----
return new Point(
‚ãÆ----
zeroLength() {
return Math.abs(this.anchor0X - this.anchor1X) < DistanceEpsilon &&
Math.abs(this.anchor0Y - this.anchor1Y) < DistanceEpsilon;
‚ãÆ----
convexTo(next) {
const prevVertex = new Point(this.anchor0X, this.anchor0Y);
const currVertex = new Point(this.anchor1X, this.anchor1Y);
const nextVertex = new Point(next.anchor1X, next.anchor1Y);
return convex(prevVertex, currVertex, nextVertex);
‚ãÆ----
zeroIsh(value) {
return Math.abs(value) < DistanceEpsilon;
‚ãÆ----
calculateBounds(bounds = new Float32Array(4), approximate = false) {
if (this.zeroLength()) {
‚ãÆ----
let minX = Math.min(this.anchor0X, this.anchor1X);
let minY = Math.min(this.anchor0Y, this.anchor1Y);
let maxX = Math.max(this.anchor0X, this.anchor1X);
let maxY = Math.max(this.anchor0Y, this.anchor1Y);
‚ãÆ----
bounds[0] = Math.min(minX, this.control0X, this.control1X);
bounds[1] = Math.min(minY, this.control0Y, this.control1Y);
bounds[2] = Math.max(maxX, this.control0X, this.control1X);
bounds[3] = Math.max(maxY, this.control0Y, this.control1Y);
‚ãÆ----
if (this.zeroIsh(xa)) {
‚ãÆ----
const x = this.pointOnCurve(t).x;
minX = Math.min(minX, x);
maxX = Math.max(maxX, x);
‚ãÆ----
const sqrtXs = Math.sqrt(xs);
‚ãÆ----
const x = this.pointOnCurve(t1).x;
‚ãÆ----
const x = this.pointOnCurve(t2).x;
‚ãÆ----
if (this.zeroIsh(ya)) {
‚ãÆ----
const y = this.pointOnCurve(t).y;
minY = Math.min(minY, y);
maxY = Math.max(maxY, y);
‚ãÆ----
const sqrtYs = Math.sqrt(ys);
‚ãÆ----
const y = this.pointOnCurve(t1).y;
‚ãÆ----
const y = this.pointOnCurve(t2).y;
‚ãÆ----
split(t) {
‚ãÆ----
const p = this.pointOnCurve(t);
const c1 = createCubic(
‚ãÆ----
const c2 = createCubic(
‚ãÆ----
reverse() {
return createCubic(
‚ãÆ----
plus(o) { return new Cubic(this.points.map((p, i) => p + o.points[i])); }
times(x) { return new Cubic(this.points.map(p => p * x)); }
div(x) { return this.times(1 / x); }
toString() {
‚ãÆ----
equals(other) {
‚ãÆ----
transformed(f) {
const newCubic = new MutableCubic();
newCubic.points.set(this.points);
newCubic.transform(f);
return new Cubic(newCubic.points);
‚ãÆ----
static straightLine(x0, y0, x1, y1) {
‚ãÆ----
interpolate(x0, x1, 1 / 3), interpolate(y0, y1, 1 / 3),
interpolate(x0, x1, 2 / 3), interpolate(y0, y1, 2 / 3),
‚ãÆ----
static circularArc(centerX, centerY, x0, y0, x1, y1) {
const p0d = directionVector(x0 - centerX, y0 - centerY);
const p1d = directionVector(x1 - centerX, y1 - centerY);
const rotatedP0 = p0d.rotate90();
const rotatedP1 = p1d.rotate90();
const clockwise = rotatedP0.dotProduct(x1 - centerX, y1 - centerY) >= 0;
const cosa = p0d.dotProduct(p1d);
if (cosa > 0.999) return Cubic.straightLine(x0, y0, x1, y1);
const k = math_distance(x0 - centerX, y0 - centerY) * 4 / 3 *
(Math.sqrt(2 * (1 - cosa)) - Math.sqrt(1 - cosa * cosa)) / (1 - cosa) *
‚ãÆ----
static empty(x0, y0) {
return createCubic(x0, y0, x0, y0, x0, y0, x0, y0);
‚ãÆ----
export function createCubic(
‚ãÆ----
return new Cubic(new Float32Array([
‚ãÆ----
export class MutableCubic extends Cubic {
transformOnePoint(f, ix) {
const result = f.transform(this.points[ix], this.points[ix + 1]);
‚ãÆ----
transform(f) {
this.transformOnePoint(f, 0);
this.transformOnePoint(f, 2);
this.transformOnePoint(f, 4);
this.transformOnePoint(f, 6);
‚ãÆ----
interpolate(c1, c2, progress) {
‚ãÆ----
this.points[i] = interpolate(c1.points[i], c2.points[i], progress);
</file>

<file path="promptdj-midi/components/react/LoadingIndicator/featureMapper.js">
export class ProgressableFeature {
‚ãÆ----
class DistanceVertex {
‚ãÆ----
export function featureMapper(features1, features2) {
‚ãÆ----
filteredFeatures1.push(f);
‚ãÆ----
filteredFeatures2.push(f);
‚ãÆ----
const featureProgressMapping = doMapping(filteredFeatures1, filteredFeatures2);
‚ãÆ----
debugLog(LOG_TAG, featureProgressMapping.map(p => `${p.first} -> ${p.second}`).join(', '));
‚ãÆ----
const dm = new DoubleMapper(...featureProgressMapping);
‚ãÆ----
const toFixed = (n) => n.toFixed(3);
const mapValues = Array.from({ length: N + 1 }, (_, i) => toFixed(dm.map(i / N))).join(', ');
const mapBackValues = Array.from({ length: N + 1 }, (_, i) => toFixed(dm.mapBack(i / N))).join(', ');
debugLog(LOG_TAG, `Map: ${mapValues}\nMb : ${mapBackValues}`);
‚ãÆ----
function doMapping(features1, features2) {
‚ãÆ----
debugLog(LOG_TAG, `Shape1 progresses: ${features1.map(f => f.progress).join(', ')}`);
debugLog(LOG_TAG, `Shape2 progresses: ${features2.map(f => f.progress).join(', ')}`);
‚ãÆ----
const d = featureDistSquared(f1.feature, f2.feature);
‚ãÆ----
distanceVertexList.push(new DistanceVertex(d, f1, f2));
‚ãÆ----
distanceVertexList.sort((a, b) => a.distance - b.distance);
‚ãÆ----
const helper = new MappingHelper();
distanceVertexList.forEach(vertex => helper.addMapping(vertex.f1, vertex.f2));
‚ãÆ----
function binarySearchBy(sortedArray, key, selector) {
‚ãÆ----
const mid = Math.floor((low + high) / 2);
const midVal = selector(sortedArray[mid]);
‚ãÆ----
function progressDistance(p1, p2) {
const d = Math.abs(p1 - p2);
return Math.min(d, 1 - d);
‚ãÆ----
function progressInRange(p, start, end) {
‚ãÆ----
class MappingHelper {
‚ãÆ----
this.usedF1 = new Set();
this.usedF2 = new Set();
‚ãÆ----
addMapping(f1, f2) {
if (this.usedF1.has(f1) || this.usedF2.has(f2)) return;
const index = binarySearchBy(this.mapping, f1.progress, item => item.first);
‚ãÆ----
progressDistance(f1.progress, before.first) < DistanceEpsilon ||
progressDistance(f1.progress, after.first) < DistanceEpsilon ||
progressDistance(f2.progress, before.second) < DistanceEpsilon ||
progressDistance(f2.progress, after.second) < DistanceEpsilon
‚ãÆ----
if (n > 1 && !progressInRange(f2.progress, before.second, after.second)) {
‚ãÆ----
this.mapping.splice(insertionIndex, 0, { first: f1.progress, second: f2.progress });
this.usedF1.add(f1);
this.usedF2.add(f2);
‚ãÆ----
function featureDistSquared(f1, f2) {
‚ãÆ----
if (DEBUG) debugLog(LOG_TAG, "*** Feature distance ‚àû for convex-vs-concave corners");
‚ãÆ----
const p1 = featureRepresentativePoint(f1);
const p2 = featureRepresentativePoint(f2);
‚ãÆ----
function featureRepresentativePoint(feature) {
‚ãÆ----
return new Point(x, y);
</file>

<file path="promptdj-midi/components/react/LoadingIndicator/floatMapping.js">
export function progressInRange(progress, progressFrom, progressTo) {
‚ãÆ----
export function linearMap(xValues, yValues, x) {
if (isNaN(x) || !xValues || !yValues || xValues.length === 0 || yValues.length === 0) {
console.error(`‚ùå linearMap: Invalid input - x=${x}, xValues=${xValues}, yValues=${yValues}`);
‚ãÆ----
if (xValues.some(isNaN) || yValues.some(isNaN)) {
console.error(`‚ùå linearMap: NaN values in arrays - xValues=${xValues}, yValues=${yValues}`);
‚ãÆ----
throw new Error(`Invalid progress: ${x}`);
‚ãÆ----
x = Math.max(0, Math.min(1, x));
‚ãÆ----
if (progressInRange(x, xValues[i], xValues[(i + 1) % xValues.length])) {
‚ãÆ----
const dist = progressDistance(x, xValues[i]);
‚ãÆ----
const segmentSizeX = positiveModulo(xValues[segmentEndIndex] - xValues[segmentStartIndex], 1);
const segmentSizeY = positiveModulo(yValues[segmentEndIndex] - yValues[segmentStartIndex], 1);
‚ãÆ----
positiveModulo(x - xValues[segmentStartIndex], 1) / segmentSizeX;
return positiveModulo(yValues[segmentStartIndex] + segmentSizeY * positionInSegment, 1);
‚ãÆ----
export class DoubleMapper {
‚ãÆ----
this.#sourceValues = new Array(mappings.length);
this.#targetValues = new Array(mappings.length);
‚ãÆ----
validateProgress(this.#sourceValues);
validateProgress(this.#targetValues);
‚ãÆ----
map(x) {
return linearMap(this.#sourceValues, this.#targetValues, x);
‚ãÆ----
mapBack(x) {
return linearMap(this.#targetValues, this.#sourceValues, x);
‚ãÆ----
static Identity = new DoubleMapper({
‚ãÆ----
export function validateProgress(p) {
‚ãÆ----
throw new Error(`FloatMapping - Progress outside of range: ${p.join(', ')}`);
‚ãÆ----
if (progressDistance(curr, prev) <= DistanceEpsilon) {
throw new Error(`FloatMapping - Progress repeats a value: ${p.join(', ')}`);
‚ãÆ----
throw new Error(`FloatMapping - Progress wraps more than once: ${p.join(', ')}`);
‚ãÆ----
export function progressDistance(p1, p2) {
const d = Math.abs(p1 - p2);
return Math.min(d, 1 - d);
</file>

<file path="promptdj-midi/components/react/LoadingIndicator/measuredPolygon.js">
export class MeasuredCubic {
‚ãÆ----
throw new Error(
‚ãÆ----
this.measuredSize = this.#measurer.measureCubic(cubic);
‚ãÆ----
updateProgressRange(
‚ãÆ----
throw new Error("endOutlineProgress is expected to be equal or greater than startOutlineProgress");
‚ãÆ----
cutAtProgress(cutOutlineProgress) {
const boundedCutOutlineProgress = Math.max(
‚ãÆ----
Math.min(cutOutlineProgress, this.endOutlineProgress)
‚ãÆ----
const t = this.#measurer.findCubicCutPoint(this.cubic, relativeProgress * this.measuredSize);
‚ãÆ----
throw new Error(`Cubic cut point ${t} is expected to be between 0 and 1`);
‚ãÆ----
debugLog(LOG_TAG,
‚ãÆ----
const [c1, c2] = this.cubic.split(t);
‚ãÆ----
new MeasuredCubic(c1, this.startOutlineProgress, boundedCutOutlineProgress, this.#measurer),
new MeasuredCubic(c2, boundedCutOutlineProgress, this.endOutlineProgress, this.#measurer)
‚ãÆ----
toString() {
‚ãÆ----
export class MeasuredPolygon {
‚ãÆ----
throw new Error("Outline progress size is expected to be the cubics size + 1");
‚ãÆ----
throw new Error("First outline progress value is expected to be zero");
‚ãÆ----
if (Math.abs(outlineProgress[outlineProgress.length - 1] - 1.0) > DistanceEpsilon) {
throw new Error("Last outline progress value is expected to be one");
‚ãÆ----
debugLog(LOG_TAG, `CTOR: cubics = ${cubics.join(", ")}\nCTOR: op = ${outlineProgress.join(", ")}`);
‚ãÆ----
measuredCubics.push(
new MeasuredCubic(
‚ãÆ----
measuredCubics[measuredCubics.length - 1].updateProgressRange(undefined, 1.0);
‚ãÆ----
cutAndShift(cuttingPoint) {
‚ãÆ----
throw new Error("Cutting point is expected to be between 0 and 1");
‚ãÆ----
const targetIndex = this.#cubics.findIndex(it =>
‚ãÆ----
if (Math.abs(cuttingPoint - 1.0) < DistanceEpsilon) {
‚ãÆ----
throw new Error(`Cutting point ${cuttingPoint} not found in any cubic range.`);
‚ãÆ----
this.#cubics.forEach((cubic, index) => debugLog(LOG_TAG, `cut&Shift | cubic #${index} : ${cubic} `));
debugLog(LOG_TAG, `cut&Shift, cuttingPoint = ${cuttingPoint}, target = (${targetIndex}) ${target}`);
‚ãÆ----
const [b1, b2] = target.cutAtProgress(cuttingPoint);
if (DEBUG) debugLog(LOG_TAG, `Split | ${target} -> ${b1} & ${b2}`);
‚ãÆ----
retCubics.push(this.#cubics[(i + targetIndex) % this.#cubics.length].cubic);
‚ãÆ----
retCubics.push(b1.cubic);
‚ãÆ----
retOutlineProgress.push(
positiveModulo(this.#cubics[cubicIndex].endOutlineProgress - cuttingPoint, 1.0)
‚ãÆ----
retOutlineProgress.push(1.0);
const newFeatures = this.features.map(f =>
new ProgressableFeature(
positiveModulo(f.progress - cuttingPoint, 1.0),
‚ãÆ----
return new MeasuredPolygon(this.#measurer, newFeatures, retCubics, retOutlineProgress);
‚ãÆ----
get size() { return this.#cubics.length; }
get(index) { return this.#cubics[index]; }
‚ãÆ----
static measurePolygon(measurer, polygon) {
‚ãÆ----
if (feature.isCorner && cubicIndex === Math.floor(feature.cubics.length / 2)) {
featureToCubic.push({ feature, index: cubics.length });
‚ãÆ----
cubics.push(feature.cubics[cubicIndex]);
‚ãÆ----
const measure = measurer.measureCubic(cubic);
‚ãÆ----
throw new Error("Measured cubic is expected to be greater or equal to zero");
‚ãÆ----
measures.push(totalMeasure);
‚ãÆ----
const outlineProgress = measures.map(m => totalMeasure === 0 ? 0 : m / totalMeasure);
‚ãÆ----
if (DEBUG) debugLog(LOG_TAG, `Total size: ${totalMeasure}`);
const features = featureToCubic.map(({ feature, index }) => {
const progress = positiveModulo(
‚ãÆ----
return new ProgressableFeature(progress, feature);
‚ãÆ----
return new MeasuredPolygon(measurer, features, cubics, outlineProgress);
‚ãÆ----
export class Measurer {
measureCubic(c) {
throw new Error("Not implemented");
‚ãÆ----
findCubicCutPoint(c, m) {
‚ãÆ----
export class LengthMeasurer extends Measurer {
‚ãÆ----
let prev = new Point(cubic.anchor0X, cubic.anchor0Y);
‚ãÆ----
const point = cubic.pointOnCurve(progress);
const segment = point.minus(prev).getDistance();
</file>

<file path="promptdj-midi/components/react/LoadingIndicator/morph-fixed.js">
export class Morph {
‚ãÆ----
this.#morphMatch = Morph.match(start, end);
‚ãÆ----
get morphMatch() {
‚ãÆ----
bounds(progress) {
‚ãÆ----
const points = new Float32Array(8);
‚ãÆ----
points[j] = interpolate(pair.first.points[j], pair.second.points[j], progress);
‚ãÆ----
minX = Math.min(minX, x);
maxX = Math.max(maxX, x);
minY = Math.min(minY, y);
maxY = Math.max(maxY, y);
‚ãÆ----
bounds[3] = Math.max(maxY, bounds[3]);
‚ãÆ----
asCubics(progress) {
‚ãÆ----
const cubic = new Cubic(points);
‚ãÆ----
result.push(lastCubic);
‚ãÆ----
result.push(
createCubic(
‚ãÆ----
forEachCubic(progress, callback, mutableCubic = new MutableCubic()) {
‚ãÆ----
mutableCubic.interpolate(pair.first, pair.second, progress);
callback(mutableCubic);
‚ãÆ----
static match(p1, p2) {
const measuredPolygon1 = MeasuredPolygon.measurePolygon(new LengthMeasurer(), p1);
const measuredPolygon2 = MeasuredPolygon.measurePolygon(new LengthMeasurer(), p2);
‚ãÆ----
const doubleMapper = featureMapper(features1, features2);
const polygon2CutPoint = doubleMapper.map(0);
if (DEBUG) debugLog(LOG_TAG, `polygon2CutPoint = ${polygon2CutPoint}`);
‚ãÆ----
const bs2 = measuredPolygon2.cutAndShift(polygon2CutPoint);
‚ãÆ----
const b1 = bs1.get(index);
debugLog(LOG_TAG, `bs1[${index}] = ${b1.startOutlineProgress} .. ${b1.endOutlineProgress}`);
‚ãÆ----
const b2 = bs2.get(index);
debugLog(LOG_TAG, `bs2[${index}] = ${b2.startOutlineProgress} .. ${b2.endOutlineProgress}`);
‚ãÆ----
let b1 = bs1.get(i1++);
let b2 = bs2.get(i2++);
‚ãÆ----
doubleMapper.mapBack(
positiveModulo(b2.endOutlineProgress + polygon2CutPoint, 1.0)
‚ãÆ----
const minb = Math.min(b1a, b2a);
if (DEBUG) debugLog(LOG_TAG, `${b1a} ${b2a} | ${minb}`);
‚ãÆ----
if (DEBUG) debugLog(LOG_TAG, "Cut 1");
[seg1, newb1] = b1.cutAtProgress(minb);
‚ãÆ----
newb1 = bs1.get(i1++);
‚ãÆ----
if (DEBUG) debugLog(LOG_TAG, "Cut 2");
[seg2, newb2] = b2.cutAtProgress(
positiveModulo(doubleMapper.map(minb) - polygon2CutPoint, 1.0)
‚ãÆ----
newb2 = bs2.get(i2++);
‚ãÆ----
ret.push({ first: seg1.cubic, second: seg2.cubic });
</file>

<file path="promptdj-midi/components/react/LoadingIndicator/roundedPolygon.js">
export class Feature {
‚ãÆ----
transformed(f) {
throw new Error("Not implemented");
‚ãÆ----
Feature.Corner = class Corner extends Feature {
‚ãÆ----
return new Feature.Corner(this.cubics.map(c => c.transformed(f)), this.convex);
‚ãÆ----
Feature.Edge = class Edge extends Feature {
‚ãÆ----
return new Feature.Edge(this.cubics.map(c => c.transformed(f)));
‚ãÆ----
export class RoundedPolygon {
‚ãÆ----
get centerX() { return this.center.x; }
get centerY() { return this.center.y; }
‚ãÆ----
const vertices = verticesFromNumVerts(arg1, radius, centerX, centerY);
‚ãÆ----
computeFeaturesFromVertices(vertices, rounding, perVertexRounding, centerX, centerY));
} else if (Array.isArray(arg1) && (arg1.length === 0 || arg1[0] instanceof Feature)) {
‚ãÆ----
if (features.length < 2 && features.length > 0) throw new Error("Polygons must have at least 2 features");
‚ãÆ----
vertices.push(cubic.anchor0X, cubic.anchor0Y);
‚ãÆ----
const calculatedCenter = calculateCenter(vertices);
const cX = !isNaN(centerX) ? centerX : calculatedCenter.x;
const cY = !isNaN(centerY) ? centerY : calculatedCenter.y;
center = new Point(cX, cY);
} else if (arg1 instanceof Float32Array || Array.isArray(arg1)) {
‚ãÆ----
computeFeaturesFromVertices(arg1, rounding, perVertexRounding, centerX, centerY));
‚ãÆ----
throw new Error("Invalid arguments for RoundedPolygon constructor");
‚ãÆ----
cubics.push(new Cubic(new Float32Array([
‚ãÆ----
if (!cubic.zeroLength()) {
if (lastCubic) cubics.push(lastCubic);
‚ãÆ----
const newPoints = lastCubic.points.slice();
‚ãÆ----
lastCubic = new Cubic(newPoints);
‚ãÆ----
if (Math.abs(cubic.anchor0X - prevCubic.anchor1X) > DistanceEpsilon ||
Math.abs(cubic.anchor0Y - prevCubic.anchor1Y) > DistanceEpsilon) {
throw new Error(
‚ãÆ----
const newCenter = f.transform(this.center.x, this.center.y);
const newFeatures = this.features.map(feat => feat.transformed(f));
return new RoundedPolygon(newFeatures, newCenter.first, newCenter.second);
‚ãÆ----
normalized() {
const bounds = this.calculateBounds();
‚ãÆ----
const side = Math.max(width, height);
‚ãÆ----
return this.transformed((x, y) => ({
‚ãÆ----
calculateMaxBounds(bounds = new Float32Array(4)) {
if (bounds.length < 4) throw new Error("Required bounds size of 4");
‚ãÆ----
const anchorDistance = distanceSquared(cubic.anchor0X - this.centerX, cubic.anchor0Y - this.centerY);
const middlePoint = cubic.pointOnCurve(0.5);
const middleDistance = distanceSquared(middlePoint.x - this.centerX, middlePoint.y - this.centerY);
maxDistSquared = Math.max(maxDistSquared, anchorDistance, middleDistance);
‚ãÆ----
const dist = Math.sqrt(maxDistSquared);
‚ãÆ----
calculateBounds(bounds = new Float32Array(4), approximate = true) {
‚ãÆ----
const tempBounds = new Float32Array(4);
‚ãÆ----
cubic.calculateBounds(tempBounds, approximate);
minX = Math.min(minX, tempBounds[0]);
minY = Math.min(minY, tempBounds[1]);
maxX = Math.max(maxX, tempBounds[2]);
maxY = Math.max(maxY, tempBounds[3]);
‚ãÆ----
equals(other) {
‚ãÆ----
return JSON.stringify(this.features) === JSON.stringify(other.features);
‚ãÆ----
function calculateCenter(vertices) {
‚ãÆ----
return new Point(
‚ãÆ----
function verticesFromNumVerts(numVertices, radius, centerX, centerY) {
const result = new Float32Array(numVertices * 2);
const centerPoint = new Point(centerX, centerY);
‚ãÆ----
const vertex = radialToCartesian(radius, angle).plus(centerPoint);
‚ãÆ----
function computeFeaturesFromVertices(vertices, rounding, perVertexRounding, centerX, centerY) {
if (vertices.length < 6) throw new Error("Polygons must have at least 3 vertices");
if (vertices.length % 2 !== 0) throw new Error("The vertices array should have even size");
‚ãÆ----
throw new Error("perVertexRounding list size must match the number of vertices");
‚ãÆ----
roundedCorners.push(
new RoundedCorner(
new Point(vertices[prevI * 2], vertices[prevI * 2 + 1]),
new Point(vertices[i * 2], vertices[i * 2 + 1]),
new Point(vertices[nextI * 2], vertices[nextI * 2 + 1]),
‚ãÆ----
const cutAdjusts = roundedCorners.map((rc, i) => {
‚ãÆ----
const sideSize = distance(
‚ãÆ----
allowedCuts.push(
‚ãÆ----
corners.push(roundedCorners[i].getCubics(allowedCuts[0], allowedCuts[1]));
‚ãÆ----
const currVertex = new Point(vertices[i * 2], vertices[i * 2 + 1]);
const prevVertex = new Point(vertices[prevI * 2], vertices[prevI * 2 + 1]);
const nextVertex = new Point(vertices[nextI * 2], vertices[nextI * 2 + 1]);
const isConvex = convex(prevVertex, currVertex, nextVertex);
tempFeatures.push(new Feature.Corner(corners[i], isConvex));
‚ãÆ----
tempFeatures.push(new Feature.Edge([
Cubic.straightLine(
‚ãÆ----
const center = (isNaN(centerX) || isNaN(centerY)) ?
calculateCenter(vertices) :
new Point(centerX, centerY);
‚ãÆ----
class RoundedCorner {
‚ãÆ----
const v01 = p0.minus(p1);
const v21 = p2.minus(p1);
const d01 = v01.getDistance();
const d21 = v21.getDistance();
‚ãÆ----
this.d1 = v01.times(1 / d01);
this.d2 = v21.times(1 / d21);
‚ãÆ----
this.cosAngle = this.d1.dotProduct(this.d2);
this.sinAngle = Math.sqrt(1 - square(this.cosAngle));
‚ãÆ----
get expectedCut() {
‚ãÆ----
getCubics(allowedCut0, allowedCut1) {
const allowedCut = Math.min(allowedCut0, allowedCut1);
‚ãÆ----
return [Cubic.empty(this.p1.x, this.p1.y)];
‚ãÆ----
const actualRoundCut = Math.min(allowedCut, this.expectedRoundCut);
‚ãÆ----
const centerDistance = Math.sqrt(square(actualR) + square(actualRoundCut));
const center = this.p1.plus(this.d1.plus(this.d2).times(0.5).getDirection().times(centerDistance));
const circleIntersection0 = this.p1.plus(this.d1.times(actualRoundCut));
const circleIntersection2 = this.p1.plus(this.d2.times(actualRoundCut));
‚ãÆ----
).reverse();
‚ãÆ----
Cubic.circularArc(
‚ãÆ----
const sideDirection = sideStart.minus(corner).getDirection();
const curveStart = corner.plus(sideDirection.times(actualRoundCut * (1 + actualSmoothingValue)));
const p = circleSegmentIntersection.times(1 - actualSmoothingValue).plus(
circleSegmentIntersection.plus(otherCircleSegmentIntersection).times(0.5 * actualSmoothingValue)
‚ãÆ----
const curveEnd = circleCenter.plus(
directionVector(p.x - circleCenter.x, p.y - circleCenter.y).times(actualR)
‚ãÆ----
const circleTangent = curveEnd.minus(circleCenter).rotate90();
const anchorEnd = lineIntersection(sideStart, sideDirection, curveEnd, circleTangent) ||
‚ãÆ----
const anchorStart = curveStart.plus(anchorEnd.times(2)).times(1 / 3);
return new Cubic(new Float32Array([
‚ãÆ----
function lineIntersection(p0, d0, p1, d1) {
const rotatedD1 = d1.rotate90();
const den = d0.dotProduct(rotatedD1);
if (Math.abs(den) < DistanceEpsilon) return null;
const num = p1.minus(p0).dotProduct(rotatedD1);
if (Math.abs(den) < DistanceEpsilon * Math.abs(num)) return null;
‚ãÆ----
return p0.plus(d0.times(k));
</file>

<file path="promptdj-midi/components/react/LoadingIndicator/utils.js">
export class Point {
‚ãÆ----
rotate90() {
return new Point(-this.y, this.x);
‚ãÆ----
dotProduct(otherX, otherY) {
‚ãÆ----
getDistance() {
return Math.sqrt(this.x * this.x + this.y * this.y);
‚ãÆ----
plus(other) {
return new Point(this.x + other.x, this.y + other.y);
‚ãÆ----
minus(other) {
return new Point(this.x - other.x, this.y - other.y);
‚ãÆ----
times(scalar) {
return new Point(this.x * scalar, this.y * scalar);
‚ãÆ----
clockwise(other) {
‚ãÆ----
add(other) { return this.plus(other); }
subtract(other) { return this.minus(other); }
scale(factor) { return this.times(factor); }
getDirection() {
const d = this.getDistance();
return d > DistanceEpsilon ? this.scale(1 / d) : new Point(0, 0);
‚ãÆ----
transformed(f) {
const result = f(this.x, this.y);
return new Point(result.x, result.y);
‚ãÆ----
equals(other) {
‚ãÆ----
return Math.abs(this.x - other.x) < DistanceEpsilon && Math.abs(this.y - other.y) < DistanceEpsilon;
‚ãÆ----
export function distance(x, y) {
return Math.sqrt(x * x + y * y);
‚ãÆ----
export function distanceSquared(x, y) {
‚ãÆ----
export function directionVector(x, y) {
‚ãÆ----
const d = distance(x, y);
‚ãÆ----
throw new Error("Required distance greater than zero");
‚ãÆ----
return new Point(x / d, y / d);
‚ãÆ----
return new Point(Math.cos(angleRadians), Math.sin(angleRadians));
‚ãÆ----
export const Zero = new Point(0, 0);
export function radialToCartesian(radius, angleRadians, center = Zero) {
return directionVector(angleRadians).times(radius).plus(center);
‚ãÆ----
export function square(x) {
‚ãÆ----
export function interpolate(start, stop, fraction) {
‚ãÆ----
export function positiveModulo(num, mod) {
‚ãÆ----
export function collinearIsh(aX, aY, bX, bY, cX, cY, tolerance = DistanceEpsilon) {
const ab = new Point(bX - aX, bY - aY).rotate90();
const ac = new Point(cX - aX, cY - aY);
const dotProduct = Math.abs(ab.dotProduct(ac));
const relativeTolerance = tolerance * ab.getDistance() * ac.getDistance();
‚ãÆ----
export function convex(previous, current, next) {
return current.minus(previous).clockwise(next.minus(current));
‚ãÆ----
export function findMinimum(v0, v1, tolerance = 1e-3, f) {
‚ãÆ----
if (f(c1) < f(c2)) {
‚ãÆ----
export function debugLog(tag, messageFactory) {
‚ãÆ----
console.log(`${tag}: ${messageFactory()}`);
</file>

<file path="promptdj-midi/components/react/material-switch.css">
md-switch {
.material-switch-container {
.material-switch-container:has(md-switch[disabled]) {
.material-switch-label {
.material-switch-container:has(md-switch[disabled]) .material-switch-label {
md-switch:focus-visible {
md-switch[icons]:focus-visible svg[slot="on-icon"] {
md-switch[icons]:focus-visible svg[slot="off-icon"] {
md-switch[icons]:focus-visible[selected] svg[slot="on-icon"] {
md-switch[icons]:focus-visible:not([selected]) svg[slot="off-icon"] {
‚ãÆ----
.material-switch-compact md-switch {
.material-switch-large md-switch {
md-switch[icons] svg[slot="on-icon"],
md-switch[icons] svg[slot="on-icon"] {
md-switch[icons] svg[slot="off-icon"] {
</file>

<file path="promptdj-midi/components/react/PlayPauseMorphType4.jsx">
function lerpPoints(a, b, t) {
‚ãÆ----
const n = Math.min(a.length, b.length);
const out = new Array(n);
‚ãÆ----
function splitByLargestJump(points) {
‚ãÆ----
const a = points.slice(0, idx);
const b = points.slice(idx);
‚ãÆ----
function resamplePoints(points, count) {
‚ãÆ----
const res = new Array(count);
‚ãÆ----
const i0 = Math.floor(t);
const i1 = Math.min(points.length - 1, i0 + 1);
‚ãÆ----
function useSampledPoints(playD, pauseD, samples) {
const playRef = useRef(null);
const pauseRef = useRef(null);
const [playPts, setPlayPts] = useState(null);
const [pausePts, setPausePts] = useState(null);
‚ãÆ----
useLayoutEffect(() => {
‚ãÆ----
const sample = (pathEl) => {
‚ãÆ----
try { len = pathEl.getTotalLength(); } catch { len = 0; }
if (!len || !isFinite(len)) len = 1;
‚ãÆ----
const { x, y } = pathEl.getPointAtLength(t);
pts.push([+x, +y]);
‚ãÆ----
const pPts = sample(p1);
const qPts = sample(p2);
setPlayPts(pPts);
setPausePts(qPts);
‚ãÆ----
function normalizePolygon(points) {
‚ãÆ----
const pts = points.slice().map(([x, y]) => ({ x, y, a: Math.atan2(y - cy, x - cx) }));
pts.sort((p, q) => p.a - q.a);
return pts.map(p => [p.x, p.y]);
‚ãÆ----
function toCssPolygon(points) {
‚ãÆ----
const norm = normalizePolygon(points);
const coords = norm.map(([px, py]) => {
‚ãÆ----
return `${x.toFixed(2)}% ${y.toFixed(2)}%`;
‚ãÆ----
return `polygon(${coords.join(', ')})`;
‚ãÆ----
export default function PlayPauseMorphType4({
‚ãÆ----
const [uncontrolledPlaying, setUncontrolledPlaying] = useState(false);
‚ãÆ----
const cfg = useMemo(() => ({ ...TYPE4_DEFAULTS, ...(config || {}) }), [config]);
const { hidden, playPts, pausePts } = useSampledPoints(PLAY_D, PAUSE_D, cfg.samples);
const split = useMemo(() => {
‚ãÆ----
const qSplit = splitByLargestJump(pausePts);
‚ãÆ----
const avgX = (pts) => pts.reduce((sum, p) => sum + p[0], 0) / pts.length;
if (avgX(qA_raw) > avgX(qB_raw)) {
‚ãÆ----
playPts.forEach(([x]) => {
‚ãÆ----
const pA_raw = playPts.filter(([x]) => x < centerX + overlapWidth);
const pB_raw = playPts.filter(([x]) => x > centerX - overlapWidth);
const perPart = Math.max(20, Math.floor(cfg.samples / 2));
‚ãÆ----
playA: resamplePoints(pA_raw, perPart),
playB: resamplePoints(pB_raw, perPart),
pauseA: resamplePoints(qA_raw, perPart),
pauseB: resamplePoints(qB_raw, perPart),
‚ãÆ----
const containerRef = useRef(null);
const boxRef1 = useRef(null);
const boxRef2 = useRef(null);
const [ready, setReady] = useState(false);
const animTokenRef = useRef(0);
useEffect(() => { setReady(!!(playPts && pausePts)); }, [playPts, pausePts]);
const handleClick = useCallback(() => {
‚ãÆ----
try { onToggle.length > 0 ? onToggle(next) : onToggle(); } catch { onToggle(); }
‚ãÆ----
if (!isControlled) setUncontrolledPlaying(next);
‚ãÆ----
const pulseAnim = useMemo(() => 'ppm4_pulse_' + Math.random().toString(36).slice(2), []);
useEffect(() => {
const el = document.createElement('style');
el.setAttribute('data-ppm4', pulseAnim);
‚ãÆ----
document.head.appendChild(el);
return () => { try { document.head.removeChild(el); } catch(_){} };
‚ãÆ----
const anim1Ref = useRef(null);
const anim2Ref = useRef(null);
const animContainerRef = useRef(null);
‚ãÆ----
try { animContainerRef.current.cancel(); } catch {}
‚ãÆ----
const validParts = parts.filter(p => p.el && typeof p.el.animate === 'function');
‚ãÆ----
const startPaths = new Map();
validParts.forEach(({ el, fromPts, lastClipRef }) => {
const cs = getComputedStyle(el);
‚ãÆ----
currentClip = lastClipRef.current || toCssPolygon(fromPts);
‚ãÆ----
startPaths.set(el, currentClip);
‚ãÆ----
validParts.forEach(({ el, animRef }) => {
el.getAnimations?.().forEach(a => a.cancel());
‚ãÆ----
try { animRef.current.cancel(); } catch {}
‚ãÆ----
animContainerRef.current = containerEl.animate(
‚ãÆ----
{ duration: Math.max(250, Math.min(1600, cfg.duration)), easing: cfg.easing, fill: 'forwards' }
‚ãÆ----
validParts.forEach(({ fromPts, toPts, el, animRef, lastClipRef }) => {
const fromPath = startPaths.get(el);
const toPath = toCssPolygon(toPts);
‚ãÆ----
const overshoot = Math.max(0, Math.min(0.35, cfg.morphOvershoot || 0));
const midOffset = Math.max(0.05, Math.min(0.95, cfg.morphMidOffset || 0.7));
‚ãÆ----
frames.push({ clipPath: fromPath, offset: 0 });
‚ãÆ----
const midPts = lerpPoints(fromPts, toPts, 1 + overshoot);
const midPath = toCssPolygon(midPts);
‚ãÆ----
if (Array.isArray(cfg.keyframeEasings) && cfg.keyframeEasings[0]) midFrame.easing = cfg.keyframeEasings[0];
frames.push(midFrame);
‚ãÆ----
if (Array.isArray(cfg.keyframeEasings)) {
‚ãÆ----
frames.push(endFrame);
‚ãÆ----
const anim = el.animate(frames, { duration: Math.max(250, Math.min(1600, cfg.duration)), easing: cfg.easing, fill: 'forwards' });
‚ãÆ----
anim.onfinish = () => {
‚ãÆ----
const lastClip1Ref = useRef(null);
const lastClip2Ref = useRef(null);
const defaultStart = useMemo(() => {
‚ãÆ----
toCssPolygon(playing ? split.playA : split.pauseA),
toCssPolygon(playing ? split.playB : split.pauseB),
‚ãÆ----
return [toCssPolygon(playing ? playPts : pausePts)];
</file>

<file path="promptdj-midi/components/WeightKnob.ts">
import { css, html, LitElement } from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { styleMap } from 'lit/directives/style-map.js';
‚ãÆ----
export class WeightKnob extends LitElement
‚ãÆ----
constructor()
connectedCallback(): void
disconnectedCallback(): void
private setupDragListeners()
private teardownDragListeners()
private handlePointerDown(e: PointerEvent)
private handlePointerMove(e: PointerEvent)
private endDrag()
private handlePointerUp()
private handlePointerCancel()
private onLostPointerCapture()
private onWindowBlur()
private handleWheel(e: WheelEvent)
private describeArc(
    centerX: number,
    centerY: number,
    startAngle: number,
    endAngle: number,
    radius: number,
): string
override render()
private renderStaticSvg()
‚ãÆ----
interface HTMLElementTagNameMap {
    'weight-knob': WeightKnob;
  }
</file>

<file path="promptdj-midi/index.css">
html,
body {
body.dragging {
body.dragging * {
</file>

<file path="promptdj-midi/index.html">
<!doctype html>
<html>
<head>
  <link rel="stylesheet" href="/index.css">
  <link rel="stylesheet"
    href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
  <script type="importmap">
      {
        "imports": {
          "@google/genai": "https://esm.sh/@google/genai@^1.0.0",
          "lit/": "https://esm.sh/lit@^3.3.0/",
          "lit": "https://esm.sh/lit@^3.3.0"
        }
      }
    </script>
</head>
<body>
  <script type="module" src="/index.tsx"></script>
</body>
</html>
</file>

<file path="promptdj-midi/metadata.json">
{
  "name": "PromptDJ MIDI",
  "description": "Control real time music with a MIDI controller.",
  "requestFramePermissions": [],
  "prompt": ""
}
</file>

<file path="promptdj-midi/package.json">
{
  "name": "promptdj-midi",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@google/genai": "^1.0.0",
    "lit": "^3.3.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1"
  },
  "devDependencies": {
    "@types/node": "^22.14.0",
    "@types/react": "^18.3.12",
    "@types/react-dom": "^18.3.1",
    "typescript": "~5.8.2",
    "vite": "^5.4.0"
  }
}
</file>

<file path="promptdj-midi/README.md">
<div align="center">
<img width="1200" height="475" alt="GHBanner" src="https://github.com/user-attachments/assets/0aa67016-6eaf-458a-adb2-6e31a0763ed6" />
</div>

# Run and deploy your AI Studio app

This contains everything you need to run your app locally.

View your app in AI Studio: https://ai.studio/apps/bundled/promptdj-midi

## Run Locally

**Prerequisites:**  Node.js


1. Install dependencies:
   `npm install`
2. Set the `GEMINI_API_KEY` in [.env.local](.env.local) to your Gemini API key
3. Run the app:
   `npm run dev`
</file>

<file path="promptdj-midi/styles/material-tokens.css">
:root {
[data-theme="dark"] {
.md-display-large {
.md-display-medium {
.md-display-small {
.md-headline-large {
.md-headline-medium {
.md-headline-small {
.md-title-large {
.md-title-medium {
.md-title-small {
.md-body-large {
.md-body-medium {
.md-body-small {
.md-label-large {
.md-label-medium {
.md-label-small {
.md-fade-in {
.md-slide-in {
.md-slide-up {
‚ãÆ----
.md-button {
.md-button:disabled {
.md-filled-button {
.md-filled-button:hover:not(:disabled) {
.md-filled-button:active:not(:disabled) {
.md-outlined-button {
.md-outlined-button:hover:not(:disabled) {
.md-outlined-button:active:not(:disabled) {
.md-text-button {
.md-text-button:hover:not(:disabled) {
.md-text-button:active:not(:disabled) {
.md-elevated-button {
.md-elevated-button:hover:not(:disabled) {
.md-elevated-button:active:not(:disabled) {
.md-tonal-button {
.md-tonal-button:hover:not(:disabled) {
.md-tonal-button:active:not(:disabled) {
.md-card {
.md-elevated-card {
.md-elevated-card:hover {
.md-filled-card {
.md-outlined-card {
.md-text-field {
.md-text-field-input {
.md-text-field-input:focus {
.md-text-field-input:disabled {
.md-text-field-label {
.md-text-field-error {
</file>

<file path="promptdj-midi/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "experimentalDecorators": true,
    "useDefineForClassFields": false,
    "module": "ESNext",
    "lib": [
      "ES2022",
      "DOM",
      "DOM.Iterable"
    ],
    "skipLibCheck": true,
    "types": [
      "node"
    ],
    "moduleResolution": "bundler",
    "isolatedModules": true,
    "moduleDetection": "force",
    "allowJs": true,
    "jsx": "react-jsx",
    "paths": {
      "@/*": [
        "./*"
      ]
    },
    "allowImportingTsExtensions": true,
    "noEmit": true
  }
}
</file>

<file path="promptdj-midi/types.ts">
export interface Prompt {
  readonly promptId: string;
  text: string;
  weight: number;
  cc: number;
  color: string;
}
export interface ControlChange {
  channel: number;
  cc: number;
  value: number;
}
export type PlaybackState = 'stopped' | 'playing' | 'loading' | 'paused';
</file>

<file path="promptdj-midi/utils/audio.ts">
import {Blob} from '@google/genai';
function encode(bytes: Uint8Array)
function decode(base64: string)
function createBlob(data: Float32Array): Blob
‚ãÆ----
// convert float32 -1 to 1 to int16 -32768 to 32767
‚ãÆ----
async function decodeAudioData(
  data: Uint8Array,
  ctx: AudioContext,
  sampleRate: number,
  numChannels: number,
): Promise<AudioBuffer>
</file>

<file path="promptdj-midi/utils/AudioAnalyser.ts">
export class AudioAnalyser extends EventTarget
‚ãÆ----
constructor(context: AudioContext)
getCurrentLevel()
loop()
‚ãÆ----
stop()
</file>

<file path="promptdj-midi/utils/AudioProcessing.ts">
function writeString(view: DataView, offset: number, string: string)
export function audioBufferToWav(buffer: AudioBuffer): Blob
export function trimSilence(buffer: AudioBuffer, threshold = 0.02): AudioBuffer
export async function processAudioBlob(blob: Blob, context: AudioContext): Promise<Blob>
</file>

<file path="promptdj-midi/utils/LiveMusicHelper.ts">
import type { PlaybackState, Prompt } from '../types';
import type { AudioChunk, GoogleGenAI, LiveMusicFilteredPrompt, LiveMusicServerMessage, LiveMusicSession } from '@google/genai';
import { decode, decodeAudioData } from './audio';
import { throttle } from './throttle';
export class LiveMusicHelper extends EventTarget
‚ãÆ----
constructor(ai: GoogleGenAI, model: string)
private debug(...args: any[])
private getSession(): Promise<LiveMusicSession>
private async connect(): Promise<LiveMusicSession>
private setPlaybackState(state: PlaybackState)
private async processAudioChunks(audioChunks: AudioChunk[])
public get activePrompts()
‚ãÆ----
public async play()
public pause()
public stop()
public async playPause()
</file>

<file path="promptdj-midi/utils/throttle.ts">
export function throttle<T extends (...args: Parameters<T>) => ReturnType<T>>(
  func: T,
  delay: number,
): (...args: Parameters<T>) => ReturnType<T>
</file>

<file path="promptdj-midi/vite.config.ts">
import path from 'path';
import { defineConfig, loadEnv } from 'vite';
</file>

<file path="src/api/realtime_audio/capture.rs">
use anyhow::Result;
‚ãÆ----
use std::time::Duration;
use super::REALTIME_RMS;
‚ãÆ----
pub fn start_per_app_capture(
‚ãÆ----
use std::collections::VecDeque;
‚ãÆ----
if wasapi::initialize_mta().is_err() {
eprintln!("Per-app capture: Failed to initialize MTA");
‚ãÆ----
eprintln!(
‚ãÆ----
if let Err(e) = audio_client.initialize_client(&desired_format, &Direction::Capture, &mode)
‚ãÆ----
eprintln!("Hint: Per-app capture requires Windows 10 version 1903 or later");
‚ãÆ----
let capture_client = match audio_client.get_audiocaptureclient() {
‚ãÆ----
eprintln!("Per-app capture: Failed to get capture client: {:?}", e);
‚ãÆ----
let event_handle = match audio_client.set_get_eventhandle() {
‚ãÆ----
eprintln!("Per-app capture: Failed to get event handle: {:?}", e);
‚ãÆ----
if let Err(e) = audio_client.start_stream() {
eprintln!("Per-app capture: Failed to start stream: {:?}", e);
‚ãÆ----
while !stop_signal.load(Ordering::Relaxed) {
if event_handle.wait_for_event(100).is_err() {
‚ãÆ----
match capture_client.read_from_device_to_deque(&mut capture_buffer) {
‚ãÆ----
if !capture_buffer.is_empty() {
‚ãÆ----
let sample_count = capture_buffer.len() / bytes_per_sample;
‚ãÆ----
while capture_buffer.len() >= bytes_per_sample {
let low = capture_buffer.pop_front().unwrap_or(0);
let high = capture_buffer.pop_front().unwrap_or(0);
‚ãÆ----
samples.push(sample);
‚ãÆ----
if let Ok(mut buf) = audio_buffer.lock() {
buf.extend(&samples);
‚ãÆ----
if !samples.is_empty() {
‚ãÆ----
samples.iter().map(|&s| (s as f64 / 32768.0).powi(2)).sum();
let rms = (sum_sq / samples.len() as f64).sqrt() as f32;
REALTIME_RMS.store(rms.to_bits(), Ordering::Relaxed);
‚ãÆ----
eprintln!("Per-app capture: Read error: {:?}", e);
‚ãÆ----
let _ = audio_client.stop_stream();
‚ãÆ----
Ok(())
‚ãÆ----
pub fn start_device_loopback_capture(
‚ãÆ----
let host = cpal::host_from_id(cpal::HostId::Wasapi).unwrap_or(cpal::default_host());
‚ãÆ----
.default_output_device()
.ok_or_else(|| anyhow::anyhow!("No output device available"))?;
let config = device.default_output_config()?;
let sample_rate = config.sample_rate();
let channels = config.channels() as usize;
let audio_buffer_clone = audio_buffer.clone();
‚ãÆ----
let stop_signal_audio = stop_signal.clone();
let err_fn = |err| eprintln!("Audio stream error: {}", err);
let stream = match config.sample_format() {
cpal::SampleFormat::F32 => device.build_input_stream(
&config.into(),
‚ãÆ----
if stop_signal_audio.load(Ordering::Relaxed) {
‚ãÆ----
.chunks(channels)
.map(|frame| {
let sum: f32 = frame.iter().sum();
‚ãÆ----
(avg.clamp(-1.0, 1.0) * i16::MAX as f32) as i16
‚ãÆ----
.collect();
‚ãÆ----
let new_len = (mono_samples.len() as f64 * resample_ratio) as usize;
‚ãÆ----
.map(|i| {
‚ãÆ----
let idx1 = (idx0 + 1).min(mono_samples.len() - 1);
‚ãÆ----
.collect()
‚ãÆ----
if let Ok(mut buf) = audio_buffer_clone.lock() {
buf.extend(resampled.iter().cloned());
‚ãÆ----
if !resampled.is_empty() {
‚ãÆ----
.iter()
.map(|&s| (s as f64 / 32768.0).powi(2))
.sum();
let rms = (sum_sq / resampled.len() as f64).sqrt() as f32;
‚ãÆ----
cpal::SampleFormat::I16 => device.build_input_stream(
‚ãÆ----
let sum: i32 = frame.iter().map(|&s| s as i32).sum();
‚ãÆ----
_ => return Err(anyhow::anyhow!("Unsupported audio format")),
‚ãÆ----
stream.play()?;
Ok(stream)
‚ãÆ----
pub fn start_mic_capture(
‚ãÆ----
.default_input_device()
.ok_or_else(|| anyhow::anyhow!("No microphone available. Please connect a microphone."))?;
let config = device.default_input_config()?;
</file>

<file path="src/api/realtime_audio/mod.rs">
mod capture;
mod state;
mod transcription;
mod translation;
mod utils;
mod websocket;
use windows::Win32::UI::WindowsAndMessaging::WM_APP;
‚ãÆ----
pub use transcription::start_realtime_transcription;
pub use translation::translate_with_google_gtx;
</file>

<file path="src/api/realtime_audio/state.rs">
pub struct RealtimeState {
‚ãÆ----
impl RealtimeState {
pub fn new() -> Self {
‚ãÆ----
fn update_display_transcript(&mut self) {
self.display_transcript = self.full_transcript.clone();
‚ãÆ----
fn update_display_translation(&mut self) {
let full = if self.committed_translation.is_empty() {
self.uncommitted_translation.clone()
} else if self.uncommitted_translation.is_empty() {
self.committed_translation.clone()
‚ãÆ----
format!(
‚ãÆ----
pub fn append_transcript(&mut self, new_text: &str) {
self.full_transcript.push_str(new_text);
‚ãÆ----
self.update_display_transcript();
‚ãÆ----
pub fn source_ends_with_sentence(&self) -> bool {
‚ãÆ----
if self.last_committed_pos >= self.full_transcript.len() {
‚ãÆ----
.trim()
.chars()
.last()
.map(|c| sentence_delimiters.contains(&c))
.unwrap_or(false)
‚ãÆ----
pub fn should_force_commit_on_timeout(&self) -> bool {
if self.uncommitted_translation.is_empty() {
‚ãÆ----
let user_silent = now.duration_since(self.last_transcript_append_time)
‚ãÆ----
let ai_silent = now.duration_since(self.last_translation_update_time)
‚ãÆ----
let source_ready = self.source_ends_with_sentence()
|| self.last_committed_pos < self.full_transcript.len();
‚ãÆ----
pub fn force_commit_all(&mut self) {
‚ãÆ----
let trans_segment = self.uncommitted_translation.trim().to_string();
if !trans_segment.is_empty() {
let source_segment = if self.last_committed_pos < self.full_transcript.len() {
‚ãÆ----
.to_string()
‚ãÆ----
"[continued]".to_string()
‚ãÆ----
self.add_to_history(source_segment, trans_segment.clone());
if self.committed_translation.is_empty() {
‚ãÆ----
self.committed_translation.push(' ');
self.committed_translation.push_str(&trans_segment);
‚ãÆ----
self.last_committed_pos = self.full_transcript.len();
self.uncommitted_translation.clear();
‚ãÆ----
self.update_display_translation();
‚ãÆ----
pub fn get_translation_chunk(&self) -> Option<(String, bool)> {
‚ãÆ----
.is_char_boundary(self.last_committed_pos)
‚ãÆ----
if text.trim().is_empty() {
‚ãÆ----
let has_finished_sentence = text.chars().any(|c| sentence_delimiters.contains(&c));
Some((text.trim().to_string(), has_finished_sentence))
‚ãÆ----
pub fn is_transcript_unchanged(&self) -> bool {
self.full_transcript.len() == self.last_processed_len
‚ãÆ----
pub fn update_last_processed_len(&mut self) {
self.last_processed_len = self.full_transcript.len();
‚ãÆ----
pub fn commit_finished_sentences(&mut self) -> bool {
‚ãÆ----
let uncommitted_len = self.uncommitted_translation.len();
‚ãÆ----
if temp_src_pos >= self.full_transcript.len() {
‚ãÆ----
if temp_trans_pos >= self.uncommitted_translation.len() {
‚ãÆ----
.char_indices()
.find(|(_, c)| sentence_delimiters.contains(c))
.map(|(i, c)| i + c.len_utf8());
‚ãÆ----
.find(|(i, c)| *i >= MIN_CLAUSE_LENGTH && clause_delimiters.contains(c))
.map(|(i, c)| i + c.len_utf8())
‚ãÆ----
matches.push((s_abs, t_abs, is_clause));
‚ãÆ----
if let Some(&(final_src_pos, final_trans_pos, _)) = matches.last() {
‚ãÆ----
.to_string();
‚ãÆ----
if !source_segment.is_empty() && !trans_segment.is_empty() {
‚ãÆ----
.trim_start()
‚ãÆ----
pub fn start_new_translation(&mut self) {
‚ãÆ----
pub fn append_translation(&mut self, new_text: &str) {
self.uncommitted_translation.push_str(new_text);
‚ãÆ----
pub fn add_to_history(&mut self, source: String, translation: String) {
self.translation_history.push((source, translation));
while self.translation_history.len() > 3 {
self.translation_history.remove(0);
‚ãÆ----
pub fn get_history_messages(&self, target_language: &str) -> Vec<serde_json::Value> {
‚ãÆ----
messages.push(serde_json::json!({
‚ãÆ----
pub type SharedRealtimeState = Arc<Mutex<RealtimeState>>;
</file>

<file path="src/api/realtime_audio/translation.rs">
use isolang;
use std::io::BufRead;
‚ãÆ----
use urlencoding;
‚ãÆ----
use crate::api::client::UREQ_AGENT;
use crate::config::Preset;
use crate::APP;
use super::state::SharedRealtimeState;
‚ãÆ----
pub fn run_translation_loop(
‚ãÆ----
let translation_block = match preset.blocks.get(1) {
Some(b) => b.clone(),
‚ãÆ----
.lock()
.ok()
.and_then(|lang| {
if lang.is_empty() {
‚ãÆ----
Some(lang.clone())
‚ãÆ----
from_ui.unwrap_or_else(|| {
if !translation_block.selected_language.is_empty() {
translation_block.selected_language.clone()
‚ãÆ----
.get("language")
.cloned()
.or_else(|| translation_block.language_vars.get("language1").cloned())
.unwrap_or_else(|| "English".to_string())
‚ãÆ----
while !stop_signal.load(Ordering::Relaxed) {
if translation_hwnd.0 != 0 as _ && !unsafe { IsWindow(Some(translation_hwnd)).as_bool() } {
‚ãÆ----
if crate::overlay::realtime_webview::LANGUAGE_CHANGE.load(Ordering::SeqCst) {
if let Ok(new_lang) = crate::overlay::realtime_webview::NEW_TARGET_LANGUAGE.lock() {
if !new_lang.is_empty() {
target_language = new_lang.clone();
if let Ok(mut s) = state.lock() {
s.translation_history.clear();
‚ãÆ----
crate::overlay::realtime_webview::LANGUAGE_CHANGE.store(false, Ordering::SeqCst);
‚ãÆ----
if crate::overlay::realtime_webview::TRANSLATION_MODEL_CHANGE.load(Ordering::SeqCst) {
‚ãÆ----
.store(false, Ordering::SeqCst);
‚ãÆ----
let should_force = { state.lock().unwrap().should_force_commit_on_timeout() };
‚ãÆ----
s.force_commit_all();
let display = s.display_translation.clone();
update_translation_text(translation_hwnd, &display);
refresh_transcription_window();
‚ãÆ----
if last_run.elapsed() >= interval {
if !crate::overlay::realtime_webview::TRANS_VISIBLE.load(Ordering::SeqCst) {
‚ãÆ----
let s = state.lock().unwrap();
if s.is_transcript_unchanged() {
‚ãÆ----
match s.get_translation_chunk() {
Some((text, has_finished)) => (Some(text), has_finished, false),
‚ãÆ----
let mut s = state.lock().unwrap();
s.update_last_processed_len();
s.start_new_translation();
‚ãÆ----
let app = APP.lock().unwrap();
let groq = app.config.api_key.clone();
let gemini = app.config.gemini_api_key.clone();
let model = app.config.realtime_translation_model.clone();
drop(app);
let history = if let Ok(s) = state.lock() {
s.get_history_messages(&target_language)
‚ãÆ----
let current_model = translation_model.as_str();
‚ãÆ----
if let Some(text) = translate_with_google_gtx(&chunk, &target_language) {
‚ãÆ----
s.append_translation(&text);
‚ãÆ----
if has_finished && s.commit_finished_sentences() {
‚ãÆ----
("https://generativelanguage.googleapis.com/v1beta/openai/chat/completions".to_string(), "gemma-3-27b-it".to_string(), gemini_key.clone())
‚ãÆ----
"https://api.groq.com/openai/v1/chat/completions".to_string(),
"llama-3.1-8b-instant".to_string(),
groq_key.clone(),
‚ãÆ----
let system_instruction = format!("You are a professional translator. Translate text to {} to append suitably to the context. Output ONLY the translation, nothing else.", target_language);
‚ãÆ----
messages.extend(history_messages.clone());
messages.push(serde_json::json!({"role": "user", "content": format!("{}\n\nTranslate to {}:\n{}", system_instruction, target_language, chunk)}));
‚ãÆ----
messages.push(
‚ãÆ----
messages.push(serde_json::json!({"role": "user", "content": format!("Translate to {}:\n{}", target_language, chunk)}));
‚ãÆ----
if !api_key.is_empty() {
‚ãÆ----
.post(&url)
.header("Authorization", &format!("Bearer {}", api_key))
.header("Content-Type", "application/json")
.send_json(payload)
‚ãÆ----
resp.headers().get("x-ratelimit-remaining-requests").and_then(|v| v.to_str().ok())
‚ãÆ----
.headers().get("x-ratelimit-limit-requests").and_then(|v| v.to_str().ok())
.unwrap_or("?");
if let Ok(mut app) = APP.lock() {
app.model_usage_stats.insert(
‚ãÆ----
format!("{} / {}", remaining, limit),
‚ãÆ----
let reader = std::io::BufReader::new(resp.into_body().into_reader());
‚ãÆ----
for line in reader.lines().flatten() {
if stop_signal.load(Ordering::Relaxed) {
‚ãÆ----
if line.starts_with("data: ") {
let json_str = &line["data: ".len()..];
if json_str.trim() == "[DONE]" {
‚ãÆ----
.get("choices")
.and_then(|c| c.as_array())
.and_then(|a| a.first())
.and_then(|f| f.get("delta"))
.and_then(|d| d.get("content"))
.and_then(|t| t.as_str())
‚ãÆ----
full_translation.push_str(content);
‚ãÆ----
s.append_translation(content);
‚ãÆ----
update_translation_text(
‚ãÆ----
if has_finished && !full_translation.is_empty() {
‚ãÆ----
if s.commit_finished_sentences() {
‚ãÆ----
handle_fallback_translation(
‚ãÆ----
fn handle_fallback_translation(
‚ãÆ----
.duration_since(std::time::UNIX_EPOCH)
.unwrap()
.as_nanos();
pool[(nanos as usize) % pool.len()]
‚ãÆ----
let mut app = APP.lock().unwrap();
app.config.realtime_translation_model = alt_model.to_string();
‚ãÆ----
let _ = PostMessageW(
Some(translation_hwnd),
‚ãÆ----
WPARAM(flag),
LPARAM(0),
‚ãÆ----
if let Some(text) = translate_with_google_gtx(chunk, target_language) {
‚ãÆ----
.to_string(),
"gemma-3-27b-it".to_string(),
gemini_key.to_string(),
‚ãÆ----
groq_key.to_string(),
‚ãÆ----
if !alt_key.is_empty() {
‚ãÆ----
let alt_sys = format!("You are a professional translator. Translate text to {} to append suitably to the context. Output ONLY the translation, nothing else.", target_language);
‚ãÆ----
alt_msgs.extend(history_messages.iter().cloned());
alt_msgs.push(serde_json::json!({"role": "user", "content": format!("{}\n\nTranslate to {}:\n{}", alt_sys, target_language, chunk)}));
‚ãÆ----
alt_msgs.push(serde_json::json!({"role": "system", "content": alt_sys}));
‚ãÆ----
alt_msgs.push(serde_json::json!({"role": "user", "content": format!("Translate to {}:\n{}", target_language, chunk)}));
‚ãÆ----
.post(&alt_url)
.header("Authorization", &format!("Bearer {}", alt_key))
‚ãÆ----
if let Some(remaining) = resp.headers().get("x-ratelimit-remaining-requests").and_then(|v| v.to_str().ok()) {
let limit = resp.headers().get("x-ratelimit-limit-requests").and_then(|v| v.to_str().ok()).unwrap_or("?");
‚ãÆ----
.and_then(|a| a.as_array())
.and_then(|v| v.first())
‚ãÆ----
.and_then(|s| s.as_str())
‚ãÆ----
full_t.push_str(txt);
‚ãÆ----
s.append_translation(txt);
let d = s.display_translation.clone();
update_translation_text(translation_hwnd, &d);
‚ãÆ----
if has_finished && !full_t.is_empty() {
‚ãÆ----
pub fn translate_with_google_gtx(text: &str, target_lang: &str) -> Option<String> {
‚ãÆ----
.and_then(|lang| lang.to_639_1())
.map(|code| code.to_string())
.unwrap_or_else(|| "en".to_string());
‚ãÆ----
let url = format!(
‚ãÆ----
.get(&url)
.header("User-Agent", "Mozilla/5.0")
.call()
‚ãÆ----
if let Ok(json) = resp.into_body().read_json::<serde_json::Value>() {
if let Some(sentences) = json.get(0).and_then(|v| v.as_array()) {
‚ãÆ----
if let Some(segment) = sentence_node.get(0).and_then(|s| s.as_str()) {
full_text.push_str(segment);
‚ãÆ----
if !full_text.is_empty() {
return Some(full_text);
</file>

<file path="src/api/tts/player.rs">
use std::collections::VecDeque;
‚ãÆ----
use std::time::Duration;
‚ãÆ----
use super::manager::TtsManager;
‚ãÆ----
use super::wsola::WsolaStretcher;
pub fn run_player_thread(manager: Arc<TtsManager>) {
let audio_player = AudioPlayer::new(PLAYBACK_SAMPLE_RATE, manager.clone());
‚ãÆ----
if manager.shutdown.load(Ordering::SeqCst) {
‚ãÆ----
let mut pq = manager.playback_queue.lock().unwrap();
while pq.is_empty() && !manager.shutdown.load(Ordering::SeqCst) {
let result = manager.playback_signal.wait(pq).unwrap();
‚ãÆ----
pq.pop_front()
‚ãÆ----
manager.is_playing.store(true, Ordering::SeqCst);
‚ãÆ----
match rx.recv() {
‚ãÆ----
if generation < manager.interrupt_generation.load(Ordering::SeqCst) {
audio_player.stop();
clear_tts_state(hwnd);
‚ãÆ----
clear_tts_loading_state(hwnd);
‚ãÆ----
audio_player.play(&data, is_realtime);
‚ãÆ----
audio_player.drain();
‚ãÆ----
manager.is_playing.store(false, Ordering::SeqCst);
‚ãÆ----
struct AudioPlayer {
‚ãÆ----
impl AudioPlayer {
fn new(sample_rate: u32, manager: Arc<TtsManager>) -> Self {
‚ãÆ----
let buffer_clone = shared_buffer.clone();
‚ãÆ----
let shutdown_clone = shutdown.clone();
‚ãÆ----
if let Ok(app) = crate::APP.lock() {
let id = app.config.tts_output_device.clone();
if id.is_empty() {
‚ãÆ----
Some(id)
‚ãÆ----
if wasapi::initialize_mta().is_err() {
eprintln!("TTS: Failed to initialize COM");
‚ãÆ----
buffer_clone.clone(),
shutdown_clone.clone(),
‚ãÆ----
eprintln!(
‚ãÆ----
_thread: Some(thread),
‚ãÆ----
fn create_excluded_stream(
‚ãÆ----
Ok(())
‚ãÆ----
unsafe fn run_wasapi_excluded(
‚ãÆ----
let _ = CoInitializeEx(None, COINIT_APARTMENTTHREADED).ok();
‚ãÆ----
CoCreateInstance(&MMDeviceEnumerator, None, CLSCTX_ALL)?;
‚ãÆ----
enumerator.GetDevice(&id_hstring)?
‚ãÆ----
enumerator.GetDefaultAudioEndpoint(eRender, eConsole)?
‚ãÆ----
let client: IAudioClient = device.Activate(CLSCTX_ALL, None)?;
let mix_format_ptr = client.GetMixFormat()?;
‚ãÆ----
client.Initialize(
‚ãÆ----
let buffer_size = client.GetBufferSize()?;
let render_client: IAudioRenderClient = client.GetService()?;
client.Start()?;
‚ãÆ----
let mut last_gen = manager.interrupt_generation.load(Ordering::SeqCst);
while !shutdown.load(Ordering::Relaxed) {
let current_gen = manager.interrupt_generation.load(Ordering::SeqCst);
‚ãÆ----
if let Ok(mut deck) = shared_buffer.lock() {
deck.clear();
‚ãÆ----
let padding = client.GetCurrentPadding()?;
let available = buffer_size.saturating_sub(padding);
‚ãÆ----
let buffer_ptr = render_client.GetBuffer(available)?;
let mut deck = shared_buffer.lock().unwrap();
‚ãÆ----
if let Some(sample) = deck.pop_front() {
‚ãÆ----
render_client.ReleaseBuffer(available, 0)?;
‚ãÆ----
client.Stop()?;
‚ãÆ----
fn play(&self, audio_data: &[u8], is_realtime: bool) {
‚ãÆ----
let base_speed = REALTIME_TTS_SPEED.load(Ordering::Relaxed);
let auto_enabled = REALTIME_TTS_AUTO_SPEED.load(Ordering::Relaxed);
‚ãÆ----
.lock()
.map(|q| q.len())
.unwrap_or(0);
‚ãÆ----
let boost = (queue_len as u32 * 15).min(60);
(base_speed + boost).min(200)
‚ãÆ----
let old_speed = CURRENT_TTS_SPEED.swap(speed, Ordering::Relaxed);
‚ãÆ----
use crate::overlay::realtime_webview::state::TRANSLATION_HWND;
‚ãÆ----
use windows::Win32::UI::WindowsAndMessaging::PostMessageW;
if !std::ptr::addr_of!(REALTIME_HWND).read().is_invalid() {
let _ = PostMessageW(
Some(REALTIME_HWND),
‚ãÆ----
WPARAM(speed as usize),
LPARAM(0),
‚ãÆ----
if !std::ptr::addr_of!(TRANSLATION_HWND).read().is_invalid() {
‚ãÆ----
Some(TRANSLATION_HWND),
‚ãÆ----
.chunks_exact(2)
.map(|chunk| i16::from_le_bytes([chunk[0], chunk[1]]))
.collect();
if input_samples.is_empty() {
‚ãÆ----
let stretched_samples = if (speed_ratio - 1.0).abs() < 0.05 {
‚ãÆ----
if let Ok(mut wsola) = self.wsola.lock() {
let result = wsola.stretch(&input_samples, speed_ratio);
if result.is_empty() {
‚ãÆ----
let output_samples: Vec<i16> = stretched_samples.iter().flat_map(|&s| [s, s]).collect();
if let Ok(mut buf) = self.shared_buffer.lock() {
buf.extend(output_samples);
‚ãÆ----
fn drain(&self) {
‚ãÆ----
let len = self.shared_buffer.lock().map(|b| b.len()).unwrap_or(0);
‚ãÆ----
fn stop(&self) {
‚ãÆ----
buf.clear();
‚ãÆ----
impl Drop for AudioPlayer {
fn drop(&mut self) {
self.shutdown.store(true, Ordering::SeqCst);
</file>

<file path="src/config/io.rs">
use std::path::PathBuf;
use crate::config::config::Config;
‚ãÆ----
pub fn get_config_path() -> PathBuf {
‚ãÆ----
.unwrap_or_default()
.join("screen-goated-toolbox");
‚ãÆ----
config_dir.join("config_v3.json")
‚ãÆ----
pub fn load_config() -> Config {
let path = get_config_path();
if !path.exists() {
‚ãÆ----
migrate_config(&mut config);
‚ãÆ----
fn migrate_config(config: &mut Config) {
let default_presets = get_default_presets();
‚ãÆ----
config.presets.iter().map(|p| p.id.clone()).collect();
‚ãÆ----
.iter()
.filter(|p| p.is_builtin() && !existing_ids.contains(&p.id))
.cloned()
.collect();
if !new_presets.is_empty() {
config.presets.extend(new_presets);
‚ãÆ----
if !preset.is_builtin() {
‚ãÆ----
if let Some(default_preset) = default_presets.iter().find(|p| p.id == preset.id) {
‚ãÆ----
if preset.blocks.is_empty() && !preset.is_master {
preset.blocks.push(ProcessingBlock {
block_type: preset.preset_type.clone(),
‚ãÆ----
pub fn save_config(config: &Config) {
‚ãÆ----
pub fn get_all_languages() -> &'static Vec<String> {
</file>

<file path="src/config/mod.rs">
mod config;
mod io;
pub mod preset;
pub mod types;
pub use config::Config;
‚ãÆ----
pub use types::ThemeMode;
pub use types::Hotkey;
</file>

<file path="src/config/preset/block.rs">
use std::collections::HashMap;
use crate::config::types::BlockType;
‚ãÆ----
pub struct ProcessingBlock {
‚ãÆ----
fn generate_block_id() -> String {
format!(
‚ãÆ----
fn default_true() -> bool {
‚ãÆ----
fn default_render_mode() -> String {
"stream".to_string()
‚ãÆ----
impl Default for ProcessingBlock {
fn default() -> Self {
‚ãÆ----
id: generate_block_id(),
block_type: "text".to_string(),
model: "text_accurate_kimi".to_string(),
prompt: "Translate to {language1}. Output ONLY the translation.".to_string(),
selected_language: "Vietnamese".to_string(),
‚ãÆ----
render_mode: "stream".to_string(),
‚ãÆ----
pub struct BlockBuilder {
‚ãÆ----
impl BlockBuilder {
pub fn text(model: &str) -> Self {
‚ãÆ----
model: model.to_string(),
‚ãÆ----
pub fn image(model: &str) -> Self {
‚ãÆ----
block_type: "image".to_string(),
‚ãÆ----
pub fn audio(model: &str) -> Self {
‚ãÆ----
block_type: "audio".to_string(),
‚ãÆ----
pub fn input_adapter() -> Self {
‚ãÆ----
block_type: "input_adapter".to_string(),
‚ãÆ----
pub fn prompt(mut self, prompt: &str) -> Self {
self.block.prompt = prompt.to_string();
‚ãÆ----
pub fn language(mut self, lang: &str) -> Self {
self.block.selected_language = lang.to_string();
‚ãÆ----
.insert("language1".to_string(), lang.to_string());
‚ãÆ----
pub fn streaming(mut self, enabled: bool) -> Self {
‚ãÆ----
pub fn markdown(mut self) -> Self {
self.block.render_mode = "markdown".to_string();
‚ãÆ----
pub fn show_overlay(mut self, show: bool) -> Self {
‚ãÆ----
pub fn auto_copy(mut self) -> Self {
‚ãÆ----
pub fn auto_speak(mut self) -> Self {
‚ãÆ----
pub fn build(self) -> ProcessingBlock {
‚ãÆ----
impl ProcessingBlock {
pub fn is_input_adapter(&self) -> bool {
‚ãÆ----
pub fn is_image(&self) -> bool {
‚ãÆ----
pub fn is_text(&self) -> bool {
‚ãÆ----
pub fn is_audio(&self) -> bool {
‚ãÆ----
pub fn block_type_enum(&self) -> BlockType {
</file>

<file path="src/config/preset/defaults/master.rs">
use crate::config::preset::Preset;
use crate::config::preset::PresetBuilder;
pub fn create_master_presets() -> Vec<Preset> {
vec![
</file>

<file path="src/config/preset/mod.rs">
mod block;
pub mod defaults;
mod preset;
‚ãÆ----
pub use defaults::get_default_presets;
</file>

<file path="src/config/types/enums.rs">
pub enum ThemeMode {
‚ãÆ----
pub enum BlockType {
‚ãÆ----
impl BlockType {
pub fn from_str(s: &str) -> Self {
‚ãÆ----
pub fn get_system_ui_language() -> String {
let sys_locale = sys_locale::get_locale().unwrap_or_default();
let lang_code = sys_locale.split('-').next().unwrap_or("en").to_lowercase();
match lang_code.as_str() {
"vi" => "vi".to_string(),
"ko" => "ko".to_string(),
"ja" => "ja".to_string(),
"zh" => "zh".to_string(),
_ => "en".to_string(),
</file>

<file path="src/config/types/hotkey.rs">
pub struct Hotkey {
‚ãÆ----
impl Hotkey {
pub fn new(code: u32, name: &str, modifiers: u32) -> Self {
‚ãÆ----
name: name.to_string(),
</file>

<file path="src/config/types/mod.rs">
mod enums;
mod hotkey;
mod tts;
‚ãÆ----
pub use hotkey::Hotkey;
</file>

<file path="src/config/types/tts.rs">
pub enum TtsMethod {
‚ãÆ----
pub struct EdgeTtsVoiceConfig {
‚ãÆ----
impl EdgeTtsVoiceConfig {
pub fn new(language_code: &str, language_name: &str, voice_name: &str) -> Self {
‚ãÆ----
language_code: language_code.to_string(),
language_name: language_name.to_string(),
voice_name: voice_name.to_string(),
‚ãÆ----
pub struct EdgeTtsSettings {
‚ãÆ----
impl Default for EdgeTtsSettings {
fn default() -> Self {
‚ãÆ----
voice_configs: default_edge_tts_voice_configs(),
‚ãÆ----
pub fn default_edge_tts_voice_configs() -> Vec<EdgeTtsVoiceConfig> {
vec![
‚ãÆ----
pub struct TtsLanguageCondition {
‚ãÆ----
impl TtsLanguageCondition {
pub fn new(language_code: &str, language_name: &str, instruction: &str) -> Self {
‚ãÆ----
instruction: instruction.to_string(),
‚ãÆ----
pub fn default_tts_language_conditions() -> Vec<TtsLanguageCondition> {
vec![TtsLanguageCondition::new(
</file>

<file path="src/gui/app/init.rs">
use crate::gui::settings_ui::ViewMode;
use crate::gui::utils::get_monitor_names;
‚ãÆ----
use auto_launch::AutoLaunch;
use eframe::egui;
use std::sync::atomic::Ordering;
use std::sync::mpsc::channel;
‚ãÆ----
impl SettingsApp {
pub fn new(
‚ãÆ----
let app_path = std::env::current_exe().unwrap();
‚ãÆ----
let auto = AutoLaunch::new(app_name, app_path.to_str().unwrap(), args);
‚ãÆ----
use winreg::RegKey;
‚ãÆ----
if let Ok(key) = hkcu.open_subkey_with_flags(
‚ãÆ----
if key.get_value::<String, &str>(app_name).is_ok() {
‚ãÆ----
run_at_startup = auto.is_enabled().unwrap_or(false);
‚ãÆ----
let _ = auto.enable();
‚ãÆ----
let (tx, rx) = channel();
let tx_tray = tx.clone();
let ctx_tray = ctx.clone();
‚ãÆ----
while let Ok(event) = TrayIconEvent::receiver().recv() {
‚ãÆ----
let _ = tx_tray.send(UserEvent::Tray(event));
ctx_tray.request_repaint();
‚ãÆ----
let ctx_restore = ctx.clone();
‚ãÆ----
match OpenEventW(
‚ãÆ----
w!("Global\\ScreenGoatedToolboxRestoreEvent"),
‚ãÆ----
let result = WaitForSingleObject(event_handle, INFINITE);
‚ãÆ----
let class_name = w!("eframe");
let mut hwnd = FindWindowW(class_name, None).unwrap_or_default();
if hwnd.is_invalid() {
let title = w!("Screen Goated Toolbox (SGT by nganlinh4)");
hwnd = FindWindowW(None, title).unwrap_or_default();
‚ãÆ----
if !hwnd.is_invalid() {
let _ = ShowWindow(hwnd, SW_RESTORE);
let _ = ShowWindow(hwnd, SW_SHOW);
let _ = SetForegroundWindow(hwnd);
let _ = SetFocus(Some(hwnd));
‚ãÆ----
RESTORE_SIGNAL.store(true, Ordering::SeqCst);
ctx_restore.request_repaint();
let _ = ResetEvent(event_handle);
‚ãÆ----
let _ = CloseHandle(event_handle);
‚ãÆ----
let tx_menu = tx.clone();
let ctx_menu = ctx.clone();
‚ãÆ----
while let Ok(event) = MenuEvent::receiver().recv() {
match event.id.0.as_str() {
‚ãÆ----
let hwnd = FindWindowW(class_name, None).unwrap_or_default();
let hwnd = if hwnd.is_invalid() {
‚ãÆ----
FindWindowW(None, title).unwrap_or_default()
‚ãÆ----
let _ = tx_menu.send(UserEvent::Menu(event.clone()));
ctx_menu.request_repaint();
‚ãÆ----
let _ = tx_menu.send(UserEvent::Menu(event));
‚ãÆ----
let view_mode = if config.presets.is_empty() {
‚ãÆ----
ViewMode::Preset(if config.active_preset_idx < config.presets.len() {
‚ãÆ----
let cached_monitors = get_monitor_names();
let (up_tx, up_rx) = channel();
‚ãÆ----
let devices_clone = cached_audio_devices.clone();
‚ãÆ----
if let Ok(mut lock) = devices_clone.lock() {
‚ãÆ----
let current_admin_state = if cfg!(target_os = "windows") {
‚ãÆ----
let initial_ui_language = config.ui_language.clone();
‚ãÆ----
.duration_since(std::time::UNIX_EPOCH)
.unwrap()
.as_millis() as u32;
tray_favorite_bubble_item.set_checked(config.show_favorite_bubble);
‚ãÆ----
let initial_has_favorites = config.presets.iter().any(|p| p.is_favorite);
‚ãÆ----
auto_launcher: Some(auto),
‚ãÆ----
Some(crate::gui::splash::SplashScreen::new(&ctx))
‚ãÆ----
updater: Some(Updater::new(up_tx)),
</file>

<file path="src/gui/app/logic.rs">
use crate::gui::app::utils::simple_rand;
‚ãÆ----
use crate::gui::locale::LocaleText;
use crate::icon_gen;
‚ãÆ----
use eframe::egui;
use std::sync::atomic::Ordering;
‚ãÆ----
use windows::Win32::Foundation::POINT;
‚ãÆ----
use windows::Win32::UI::WindowsAndMessaging::GetCursorPos;
impl SettingsApp {
pub(crate) fn check_updater(&mut self) {
while let Ok(status) = self.update_rx.try_recv() {
‚ãÆ----
let ui_lang = self.config.ui_language.clone();
‚ãÆ----
format!("{} v{}", locale.update_available_notification, version);
‚ãÆ----
pub(crate) fn update_theme_and_tray(&mut self, ctx: &egui::Context) {
let now = ctx.input(|i| i.time);
‚ãÆ----
ctx.set_visuals(egui::Visuals::dark());
‚ãÆ----
ctx.set_visuals(egui::Visuals::light());
‚ãÆ----
let _ = tray.set_icon(Some(new_icon));
‚ãÆ----
self.last_ui_language = self.config.ui_language.clone();
‚ãÆ----
self.tray_settings_item.set_text(new_locale.tray_settings);
self.tray_quit_item.set_text(new_locale.tray_quit);
‚ãÆ----
if self.tray_icon.is_none() {
‚ãÆ----
ctx.send_viewport_cmd(egui::ViewportCommand::Visible(true));
‚ãÆ----
.with_tooltip("Screen Goated Toolbox (nganlinh4)")
.with_icon(icon)
.build()
‚ãÆ----
self.tray_icon = Some(tray);
‚ãÆ----
ctx.request_repaint_after(std::time::Duration::from_secs(1));
‚ãÆ----
pub(crate) fn update_startup(&mut self, ctx: &egui::Context) {
‚ãÆ----
let _ = GetCursorPos(&mut cursor_pos);
let h_monitor = MonitorFromPoint(cursor_pos, MONITOR_DEFAULTTONEAREST);
‚ãÆ----
let _ = GetMonitorInfoW(h_monitor, &mut mi);
‚ãÆ----
let pixels_per_point = ctx.pixels_per_point();
‚ãÆ----
ctx.send_viewport_cmd(egui::ViewportCommand::OuterPosition(egui::pos2(
‚ãÆ----
ctx.send_viewport_cmd(egui::ViewportCommand::InnerSize(egui::vec2(
‚ãÆ----
ctx.request_repaint();
‚ãÆ----
splash.reset_timer(ctx);
‚ãÆ----
let should_be_visible = !self.config.start_in_tray || self.tray_icon.is_none();
ctx.send_viewport_cmd(egui::ViewportCommand::Visible(should_be_visible));
‚ãÆ----
let has_favorites = self.config.presets.iter().any(|p| p.is_favorite);
‚ãÆ----
pub(crate) fn update_bubble_sync(&mut self) {
let current_has_favorites = self.config.presets.iter().any(|p| p.is_favorite);
‚ãÆ----
.set_enabled(current_has_favorites);
‚ãÆ----
pub(crate) fn update_splash(&mut self, ctx: &egui::Context) {
‚ãÆ----
match splash.update(ctx) {
‚ãÆ----
pub(crate) fn check_restore_signal(&mut self, ctx: &egui::Context) {
if RESTORE_SIGNAL.swap(false, Ordering::SeqCst) {
self.restore_window(ctx);
‚ãÆ----
pub(crate) fn update_tips_logic(&mut self, ctx: &egui::Context) {
‚ãÆ----
.get(self.current_tip_idx)
.unwrap_or(&"")
.to_string();
let display_duration = (2.0 + (current_tip.len() as f64 * 0.06)) as f32;
‚ãÆ----
// Fading In
self.tip_fade_state = (elapsed / fade_duration as f32).min(1.0);
‚ãÆ----
// Fully visible, wait for duration
‚ãÆ----
self.tip_is_fading_in = false; // Start fading out
self.tip_timer = now; // Reset timer for fade-out
‚ãÆ----
// Fading Out
self.tip_fade_state = (1.0 - (elapsed / fade_duration as f32)).max(0.0);
‚ãÆ----
// Switch to next random tip
self.rng_seed = simple_rand(self.rng_seed);
if !text.tips_list.is_empty() {
let next = (self.rng_seed as usize) % text.tips_list.len();
// Avoid repeating same tip if possible
if next == self.current_tip_idx && text.tips_list.len() > 1 {
self.current_tip_idx = (next + 1) % text.tips_list.len();
‚ãÆ----
self.tip_timer = now; // Reset timer
self.tip_is_fading_in = true; // Start fading in
‚ãÆ----
pub(crate) fn update_hotkey_recording(&mut self, ctx: &egui::Context) {
‚ãÆ----
ctx.input(|i| {
if i.key_pressed(egui::Key::Escape) {
‚ãÆ----
// Check Keyboard Events
‚ãÆ----
if let Some(vk) = egui_key_to_vk(key) {
if !matches!(vk, 16 | 17 | 18 | 91 | 92) {
‚ãÆ----
format!("{:?}", key).trim_start_matches("Key").to_string();
key_recorded = Some((vk, modifiers_bitmap, key_name));
‚ãÆ----
if key_recorded.is_none() {
‚ãÆ----
if i.pointer.button_pressed(btn) {
if let Some(vk) = egui_pointer_to_vk(&btn) {
‚ãÆ----
key_recorded = Some((vk, modifiers_bitmap, name));
‚ãÆ----
if let Some(msg) = self.check_hotkey_conflict(vk, mods, preset_idx) {
self.hotkey_conflict_msg = Some(msg);
‚ãÆ----
name_parts.push("Ctrl".to_string());
‚ãÆ----
name_parts.push("Alt".to_string());
‚ãÆ----
name_parts.push("Shift".to_string());
‚ãÆ----
name_parts.push("Win".to_string());
‚ãÆ----
name_parts.push(key_name);
‚ãÆ----
name: name_parts.join(" + "),
‚ãÆ----
if let Some(preset) = self.config.presets.get_mut(preset_idx) {
‚ãÆ----
.iter()
.any(|h| h.code == vk && h.modifiers == mods)
‚ãÆ----
preset.hotkeys.push(new_hotkey);
self.save_and_sync();
‚ãÆ----
pub(crate) fn handle_events(&mut self, ctx: &egui::Context) {
while let Ok(event) = self.event_rx.try_recv() {
‚ãÆ----
match menu_event.id.0.as_str() {
‚ãÆ----
.set_checked(self.config.show_favorite_bubble);
‚ãÆ----
pub(crate) fn handle_close_request(&mut self, ctx: &egui::Context) {
if ctx.input(|i| i.viewport().close_requested()) {
‚ãÆ----
ctx.send_viewport_cmd(egui::ViewportCommand::CancelClose);
ctx.send_viewport_cmd(egui::ViewportCommand::Visible(false));
</file>

<file path="src/gui/app/types.rs">
use crate::config::Config;
use crate::gui::settings_ui::node_graph::ChainNode;
use crate::gui::settings_ui::ViewMode;
‚ãÆ----
use auto_launch::AutoLaunch;
use egui_snarl::Snarl;
use std::sync::atomic::AtomicBool;
use std::sync::mpsc::Receiver;
‚ãÆ----
pub enum UserEvent {
‚ãÆ----
pub struct SettingsApp {
</file>

<file path="src/gui/mod.rs">
mod app;
pub mod icons;
mod key_mapping;
pub mod locale;
pub mod settings_ui;
pub mod splash;
pub mod utils;
pub use app::signal_restore_window;
pub use app::SettingsApp;
pub use utils::configure_fonts;
</file>

<file path="src/gui/settings_ui/footer.rs">
use eframe::egui;
use crate::gui::locale::LocaleText;
‚ãÆ----
pub fn render_footer(
‚ãÆ----
ui.horizontal(|ui| {
ui.allocate_ui(egui::vec2(180.0, ui.available_height()), |ui| {
ui.horizontal_centered(|ui| {
let is_admin = cfg!(target_os = "windows") && crate::gui::utils::is_running_as_admin();
‚ãÆ----
.size(11.0)
.color(egui::Color32::from_rgb(34, 139, 34))
‚ãÆ----
.color(ui.visuals().weak_text_color())
‚ãÆ----
ui.label(footer_text);
‚ãÆ----
let version_text = format!("{} v{}", text.footer_version, env!("CARGO_PKG_VERSION"));
let version_galley = ui.painter().layout_no_wrap(
version_text.clone(),
‚ãÆ----
ui.visuals().weak_text_color()
‚ãÆ----
let version_width = version_galley.rect.width() + 10.0;
let available_w = ui.available_width() - version_width;
ui.allocate_ui(egui::vec2(available_w, ui.available_height()), |ui| {
ui.vertical_centered(|ui| {
let tip_color = ui.visuals().text_color().linear_multiply(tip_alpha);
‚ãÆ----
let is_dark_mode = ui.visuals().dark_mode;
let layout_job = format_footer_tip(&current_tip, tip_color, is_dark_mode, tip_alpha);
let text_galley = ui.painter().layout_job(layout_job);
let total_width = icon_size + icon_spacing + text_galley.rect.width();
let (response, painter) = ui.allocate_painter(
egui::vec2(total_width + 8.0, ui.available_height().max(18.0)),
‚ãÆ----
egui::pos2(rect.left(), rect.center().y - icon_size / 2.0),
‚ãÆ----
paint_icon(&painter, icon_rect, Icon::Lightbulb, icon_color);
‚ãÆ----
icon_rect.right() + icon_spacing,
rect.center().y - text_galley.rect.height() / 2.0
‚ãÆ----
painter.galley(text_pos, text_galley, egui::Color32::WHITE);
if response.on_hover_text(text.tips_click_hint).clicked() {
‚ãÆ----
ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
ui.label(egui::RichText::new(version_text).size(11.0).color(ui.visuals().weak_text_color()));
‚ãÆ----
fn format_footer_tip(text: &str, base_color: egui::Color32, is_dark_mode: bool, alpha_factor: f32) -> LayoutJob {
‚ãÆ----
base_color.r(),
base_color.g(),
base_color.b(),
(base_color.a() as f32 * alpha_factor) as u8,
‚ãÆ----
bold_color.r(),
bold_color.g(),
bold_color.b(),
‚ãÆ----
let mut chars = text.chars().peekable();
‚ãÆ----
while let Some(ch) = chars.next() {
if ch == '*' && chars.peek() == Some(&'*') {
chars.next();
if !current_text.is_empty() {
let mut fmt = text_format.clone();
‚ãÆ----
job.append(&current_text, 0.0, fmt);
current_text.clear();
‚ãÆ----
current_text.push(ch);
</file>

<file path="src/gui/settings_ui/global/mod.rs">
use super::node_graph::request_node_graph_view_reset;
use crate::config::Config;
‚ãÆ----
use crate::gui::locale::LocaleText;
‚ãÆ----
use auto_launch::AutoLaunch;
use eframe::egui;
use std::collections::HashMap;
mod tts_settings;
mod update_section;
mod usage_stats;
use tts_settings::render_tts_settings_modal;
use update_section::render_update_section_content;
use usage_stats::render_usage_modal;
‚ãÆ----
pub fn render_global_settings(
‚ãÆ----
let is_dark = ui.visuals().dark_mode;
‚ãÆ----
ui.add_space(5.0);
‚ãÆ----
.fill(card_bg)
.stroke(card_stroke)
.inner_margin(12.0)
.corner_radius(10.0)
.show(ui, |ui| {
ui.horizontal(|ui| {
ui.label(
‚ãÆ----
.strong()
.size(14.0),
‚ãÆ----
ui.add_space(16.0);
‚ãÆ----
.checkbox(&mut config.use_groq, text.use_groq_checkbox)
.changed()
‚ãÆ----
.checkbox(&mut config.use_gemini, text.use_gemini_checkbox)
‚ãÆ----
.checkbox(&mut config.use_openrouter, text.use_openrouter_checkbox)
‚ãÆ----
if ui.checkbox(&mut config.use_ollama, "Ollama").changed() {
‚ãÆ----
ui.add_space(6.0);
‚ãÆ----
ui.label(text.groq_label);
if ui.link(text.get_key_link).clicked() {
‚ãÆ----
.add(
‚ãÆ----
.password(!*show_api_key)
.desired_width(API_KEY_FIELD_WIDTH),
‚ãÆ----
if icon_button(ui, eye_icon).clicked() {
‚ãÆ----
ui.add_space(8.0);
‚ãÆ----
ui.label(text.gemini_api_key_label);
if ui.link(text.gemini_get_key_link).clicked() {
‚ãÆ----
.password(!*show_gemini_api_key)
‚ãÆ----
ui.label(text.openrouter_api_key_label);
if ui.link(text.openrouter_get_key_link).clicked() {
‚ãÆ----
.password(!*show_openrouter_api_key)
‚ãÆ----
ui.label("Ollama URL:");
if ui.link(text.ollama_url_guide).clicked() {
‚ãÆ----
.ctx()
.memory(|mem| mem.data.get_temp::<String>(egui::Id::new("ollama_status")))
‚ãÆ----
ui.label(egui::RichText::new(&status).size(11.0));
‚ãÆ----
ui.add_space(10.0);
‚ãÆ----
egui::RichText::new(format!("üìä {}", text.usage_statistics_title))
.color(egui::Color32::WHITE)
.strong(),
‚ãÆ----
.fill(stats_bg)
.corner_radius(10.0),
‚ãÆ----
.on_hover_cursor(egui::CursorIcon::PointingHand)
.on_hover_text(text.usage_statistics_tooltip)
.clicked()
‚ãÆ----
egui::RichText::new(format!("üîä {}", text.tts_settings_button))
‚ãÆ----
.fill(tts_bg)
‚ãÆ----
render_usage_modal(
‚ãÆ----
if render_tts_settings_modal(ui, config, text, show_tts_modal) {
‚ãÆ----
render_update_section_content(ui, updater, update_status, text);
‚ãÆ----
.checkbox(&mut startup_toggle, text.startup_label)
‚ãÆ----
let _ = launcher.disable();
‚ãÆ----
let _ = launcher.enable();
‚ãÆ----
ui.indent("admin_indent", |ui| {
‚ãÆ----
if ui.checkbox(&mut is_admin_mode, checkbox_label).clicked() {
‚ãÆ----
ui.add_enabled_ui(false, |ui| {
ui.checkbox(&mut _is_admin_mode_disabled, checkbox_label);
‚ãÆ----
.size(11.0)
.color(egui::Color32::from_rgb(200, 100, 50)),
‚ãÆ----
.color(egui::Color32::from_rgb(34, 139, 34)),
‚ãÆ----
.checkbox(&mut config.start_in_tray, text.start_in_tray_label)
‚ãÆ----
ui.label(text.graphics_mode_label);
let current_label = match config.ui_language.as_str() {
‚ãÆ----
.selected_text(current_label)
.show_ui(ui, |ui| {
‚ãÆ----
.selectable_label(
‚ãÆ----
config.graphics_mode = "standard".to_string();
‚ãÆ----
config.graphics_mode = "minimal".to_string();
‚ãÆ----
ui.add_space(80.0);
‚ãÆ----
.color(egui::Color32::WHITE),
‚ãÆ----
.fill(reset_bg)
.corner_radius(8.0),
‚ãÆ----
let saved_groq_key = config.api_key.clone();
let saved_gemini_key = config.gemini_api_key.clone();
let saved_openrouter_key = config.openrouter_api_key.clone();
let saved_language = config.ui_language.clone();
‚ãÆ----
let saved_ollama_base_url = config.ollama_base_url.clone();
‚ãÆ----
request_node_graph_view_reset(ui.ctx());
</file>

<file path="src/gui/settings_ui/mod.rs">
mod footer;
mod global;
pub mod help_assistant;
mod history;
pub mod node_graph;
mod preset;
mod sidebar;
pub use footer::render_footer;
pub use global::render_global_settings;
pub use history::render_history_panel;
pub use preset::render_preset_editor;
pub use sidebar::get_localized_preset_name;
pub use sidebar::render_sidebar;
‚ãÆ----
pub enum ViewMode {
</file>

<file path="src/gui/settings_ui/node_graph/conversion.rs">
use super::node::ChainNode;
use crate::config::ProcessingBlock;
use eframe::egui;
‚ãÆ----
pub fn blocks_to_snarl(
‚ãÆ----
let positions: Vec<egui::Pos2> = if !connections.is_empty() {
‚ãÆ----
adj.entry(from).or_default().push(to);
‚ãÆ----
let mut depths = vec![0; blocks.len()];
‚ãÆ----
queue.push_back((0, 0));
let mut visited = vec![false; blocks.len()];
‚ãÆ----
while let Some((u, d)) = queue.pop_front() {
‚ãÆ----
layer_nodes.entry(d).or_default().push(u);
if let Some(children) = adj.get(&u) {
‚ãÆ----
if v < blocks.len() && !visited[v] {
‚ãÆ----
queue.push_back((v, d + 1));
‚ãÆ----
let mut pos_map = vec![egui::pos2(0.0, 0.0); blocks.len()];
for (depth, nodes) in layer_nodes.iter() {
let count = nodes.len();
‚ãÆ----
for (i, &node_idx) in nodes.iter().enumerate() {
‚ãÆ----
for i in 0..blocks.len() {
‚ãÆ----
.iter()
.enumerate()
.map(|(i, _)| egui::pos2(start_x + i as f32 * spacing_x, start_y))
.collect()
‚ãÆ----
let has_input_adapter = blocks.iter().any(|b| b.block_type == "input_adapter");
‚ãÆ----
block_type: preset_type.to_string(),
‚ãÆ----
virtual_input_id = Some(snarl.insert_node(pos, node));
‚ãÆ----
for (i, block) in blocks.iter().enumerate() {
‚ãÆ----
.any(|(from, to)| *to == i && blocks[*from].block_type == "input_adapter");
‚ãÆ----
if virtual_input_id.is_some() {
‚ãÆ----
let node_id = snarl.insert_node(pos, node);
node_ids.push(node_id);
‚ãÆ----
if !node_ids.is_empty() {
‚ãÆ----
snarl.connect(from, to);
‚ãÆ----
if !connections.is_empty() {
‚ãÆ----
if from_idx < node_ids.len() && to_idx < node_ids.len() {
‚ãÆ----
} else if blocks.len() > 1 {
for i in 0..node_ids.len() - 1 {
‚ãÆ----
pub fn snarl_to_graph(snarl: &Snarl<ChainNode>) -> (Vec<ProcessingBlock>, Vec<(usize, usize)>) {
‚ãÆ----
for (node_id, node) in snarl.node_ids() {
if node.is_input() {
input_node_id = Some(node_id);
‚ãÆ----
queue.push_back((start_id, true));
while let Some((node_id, _is_first)) = queue.pop_front() {
if node_to_idx.contains_key(&node_id) {
‚ãÆ----
if let Some(node) = snarl.get_node(node_id) {
let block = node.to_block();
let idx = blocks.len();
node_to_idx.insert(node_id, idx);
blocks.push(block);
‚ãÆ----
for (from, to) in snarl.wires() {
‚ãÆ----
queue.push_back((to.node, false));
‚ãÆ----
(node_to_idx.get(&from.node), node_to_idx.get(&to.node))
‚ãÆ----
connections.push((from_idx, to_idx));
</file>

<file path="src/gui/settings_ui/node_graph/node.rs">
use crate::config::ProcessingBlock;
use std::collections::HashMap;
‚ãÆ----
pub enum ChainNode {
‚ãÆ----
impl Default for ChainNode {
fn default() -> Self {
‚ãÆ----
id: format!(
‚ãÆ----
block_type: "text".to_string(),
model: "text_accurate_kimi".to_string(),
prompt: "Translate to {language1}. Output ONLY the translation.".to_string(),
‚ãÆ----
render_mode: "stream".to_string(),
‚ãÆ----
impl ChainNode {
pub fn is_input(&self) -> bool {
matches!(self, ChainNode::Input { .. })
‚ãÆ----
pub fn is_special(&self) -> bool {
matches!(self, ChainNode::Special { .. })
‚ãÆ----
pub fn to_block(&self) -> ProcessingBlock {
‚ãÆ----
id: id.clone(),
block_type: "input_adapter".to_string(),
‚ãÆ----
render_mode: render_mode.clone(),
‚ãÆ----
block_type: block_type.clone(),
model: model.clone(),
prompt: prompt.clone(),
selected_language: language_vars.get("language1").cloned().unwrap_or_default(),
language_vars: language_vars.clone(),
‚ãÆ----
pub fn from_block(block: &ProcessingBlock, role: &str) -> Self {
let mut language_vars = block.language_vars.clone();
if !language_vars.contains_key("language1") && !block.selected_language.is_empty() {
language_vars.insert("language1".to_string(), block.selected_language.clone());
‚ãÆ----
id: block.id.clone(),
block_type: block.block_type.clone(),
‚ãÆ----
render_mode: block.render_mode.clone(),
‚ãÆ----
model: block.model.clone(),
prompt: block.prompt.clone(),
‚ãÆ----
pub fn id(&self) -> &str {
‚ãÆ----
pub fn set_auto_copy(&mut self, val: bool) {
</file>

<file path="src/history.rs">
use chrono::Local;
‚ãÆ----
use std::fs;
use std::path::PathBuf;
‚ãÆ----
use std::thread;
‚ãÆ----
pub enum HistoryType {
‚ãÆ----
pub struct HistoryItem {
‚ãÆ----
pub enum HistoryAction {
‚ãÆ----
pub struct HistoryManager {
‚ãÆ----
impl HistoryManager {
pub fn new(max_items: usize) -> Self {
let (tx, rx) = channel();
let (_, db_path, _) = get_paths();
let initial_items = if db_path.exists() {
let file = fs::File::open(&db_path).ok();
‚ãÆ----
serde_json::from_reader(f).unwrap_or_default()
‚ãÆ----
let items_clone = items.clone();
‚ãÆ----
process_queue(rx, items_clone, max_items);
‚ãÆ----
pub fn save_image(&self, img: ImageBuffer<Rgba<u8>, Vec<u8>>, text: String) {
let _ = self.tx.send(HistoryAction::SaveImage { img, text });
‚ãÆ----
pub fn save_audio(&self, wav_data: Vec<u8>, text: String) {
let _ = self.tx.send(HistoryAction::SaveAudio { wav_data, text });
‚ãÆ----
pub fn save_text(&self, result_text: String, input_text: String) {
if !result_text.trim().is_empty() {
let _ = self.tx.send(HistoryAction::SaveText {
‚ãÆ----
pub fn delete(&self, id: i64) {
let _ = self.tx.send(HistoryAction::Delete(id));
let mut guard = self.items.lock().unwrap();
if let Some(pos) = guard.iter().position(|x| x.id == id) {
guard.remove(pos);
‚ãÆ----
pub fn clear_all(&self) {
let _ = self.tx.send(HistoryAction::ClearAll);
‚ãÆ----
guard.clear();
‚ãÆ----
pub fn request_prune(&self, limit: usize) {
let _ = self.tx.send(HistoryAction::Prune(limit));
‚ãÆ----
fn get_paths() -> (PathBuf, PathBuf, PathBuf) {
‚ãÆ----
.unwrap_or_default()
.join("screen-goated-toolbox");
let media_dir = config_dir.join("history_media");
let db_path = config_dir.join("history.json");
‚ãÆ----
fn save_db(items: &Vec<HistoryItem>) {
‚ãÆ----
fn process_queue(
‚ãÆ----
let (_, _, media_dir) = get_paths();
while let Ok(action) = rx.recv() {
‚ãÆ----
let mut items = cache.lock().unwrap();
‚ãÆ----
let timestamp = now.format("%Y-%m-%d %H:%M:%S").to_string();
let filename = format!("img_{}.png", now.format("%Y%m%d_%H%M%S_%f"));
let path = media_dir.join(&filename);
let id = now.timestamp_nanos_opt().unwrap_or(0);
if img.save(&path).is_ok() {
items.insert(
‚ãÆ----
let filename = format!("audio_{}.wav", now.format("%Y%m%d_%H%M%S_%f"));
‚ãÆ----
if fs::write(&path, wav_data).is_ok() {
‚ãÆ----
let filename = format!("text_{}.txt", now.format("%Y%m%d_%H%M%S_%f"));
‚ãÆ----
if fs::write(&path, &input_text).is_ok() {
‚ãÆ----
if let Some(pos) = items.iter().position(|x| x.id == id) {
let item = items.remove(pos);
let _ = fs::remove_file(media_dir.join(item.media_path));
‚ãÆ----
for entry in entries.flatten() {
let _ = fs::remove_file(entry.path());
‚ãÆ----
items.clear();
‚ãÆ----
if items.len() > max_items {
while items.len() > max_items {
if let Some(item) = items.pop() {
‚ãÆ----
save_db(&items);
</file>

<file path="src/overlay/favorite_bubble/render.rs">
use std::sync::atomic::Ordering;
‚ãÆ----
pub fn update_bubble_visual(hwnd: HWND) {
‚ãÆ----
let hdc_screen = GetDC(None);
let hdc_mem = CreateCompatibleDC(Some(hdc_screen));
‚ãÆ----
CreateDIBSection(Some(hdc_mem), &bmi, DIB_RGB_COLORS, &mut bits, None, 0).unwrap();
let old_bm = SelectObject(hdc_mem, hbm.into());
if !bits.is_null() {
‚ãÆ----
let is_hovered = IS_HOVERED.load(Ordering::SeqCst);
let is_expanded = IS_EXPANDED.load(Ordering::SeqCst);
draw_bubble_pixels(pixels, BUBBLE_SIZE, is_hovered || is_expanded);
‚ãÆ----
let _ = GetWindowRect(hwnd, &mut rect);
‚ãÆ----
let _ = UpdateLayeredWindow(
‚ãÆ----
Some(hdc_screen),
Some(&pt_dst),
Some(&size),
Some(hdc_mem),
Some(&pt_src),
COLORREF(0),
Some(&blend),
‚ãÆ----
let _ = SelectObject(hdc_mem, old_bm);
let _ = DeleteObject(hbm.into());
let _ = DeleteDC(hdc_mem);
let _ = ReleaseDC(None, hdc_screen);
‚ãÆ----
fn draw_bubble_pixels(pixels: &mut [u32], size: i32, _is_active: bool) {
let opacity = CURRENT_OPACITY.load(Ordering::SeqCst);
let icon_data = if LAST_THEME_IS_DARK.load(Ordering::SeqCst) {
‚ãÆ----
if !icon_data.is_empty() {
‚ãÆ----
if src_idx + 3 < icon_data.len() {
‚ãÆ----
let dist = (dx * dx + dy * dy).sqrt();
</file>

<file path="src/overlay/html_components/grid_js.rs">
pub fn get_css() -> &'static str {
‚ãÆ----
pub fn get_init_script() -> &'static str {
‚ãÆ----
pub fn get_lib_urls() -> (&'static str, &'static str) {
</file>

<file path="src/overlay/html_components/js_logic.rs">
pub fn get(placeholder_text: &str) -> String {
format!(
</file>

<file path="src/overlay/html_components/js_main.rs">
pub fn get(font_size: u32) -> String {
format!(
</file>

<file path="src/overlay/input_history.rs">
use std::fs;
use std::path::PathBuf;
use std::sync::Mutex;
‚ãÆ----
pub struct InputHistory {
‚ãÆ----
impl Default for InputHistory {
fn default() -> Self {
‚ãÆ----
impl InputHistory {
fn history_path() -> PathBuf {
‚ãÆ----
.unwrap_or_default()
.join("screen-goated-toolbox");
‚ãÆ----
config_dir.join("input_history.json")
‚ãÆ----
pub fn load() -> Self {
‚ãÆ----
if path.exists() {
‚ãÆ----
fn save(&self) {
‚ãÆ----
pub fn add_entry(&mut self, text: &str) {
let text = text.trim().to_string();
if text.is_empty() {
‚ãÆ----
self.entries.retain(|e| e != &text);
self.entries.push(text);
while self.entries.len() > MAX_HISTORY_SIZE {
self.entries.remove(0);
‚ãÆ----
self.reset_navigation();
self.save();
‚ãÆ----
pub fn navigate_up(&mut self, current_text: &str) -> Option<String> {
if self.entries.is_empty() {
‚ãÆ----
self.current_draft = current_text.to_string();
self.nav_index = self.entries.len() as i32;
‚ãÆ----
if (self.nav_index as usize) < self.entries.len() {
self.entries.get(self.nav_index as usize).cloned()
‚ãÆ----
pub fn navigate_down(&mut self, _current_text: &str) -> Option<String> {
‚ãÆ----
if (self.nav_index as usize) >= self.entries.len() {
let draft = self.current_draft.clone();
‚ãÆ----
Some(draft)
‚ãÆ----
pub fn reset_navigation(&mut self) {
‚ãÆ----
self.current_draft.clear();
‚ãÆ----
pub fn add_to_history(text: &str) {
if let Ok(mut history) = INPUT_HISTORY.lock() {
history.add_entry(text);
‚ãÆ----
pub fn navigate_history_up(current_text: &str) -> Option<String> {
‚ãÆ----
history.navigate_up(current_text)
‚ãÆ----
pub fn navigate_history_down(current_text: &str) -> Option<String> {
‚ãÆ----
history.navigate_down(current_text)
‚ãÆ----
pub fn reset_history_navigation() {
‚ãÆ----
history.reset_navigation();
</file>

<file path="src/overlay/realtime_html.rs">
use crate::gui::locale::LocaleText;
pub fn get_realtime_html(
‚ãÆ----
format!("{}", title_text)
‚ãÆ----
r#"<canvas id="volume-canvas" width="90" height="24"></canvas>"#.to_string()
‚ãÆ----
// Build language options HTML - show full name in dropdown, but store code for display
‚ãÆ----
.iter()
.map(|lang| {
‚ãÆ----
// Get 2-letter ISO 639-1 code
‚ãÆ----
.and_then(|l| l.to_639_1())
.map(|c| c.to_uppercase())
.unwrap_or_else(|| lang.chars().take(2).collect::<String>().to_uppercase());
// Option shows full name, but we store code as data attribute for selected display
format!(
‚ãÆ----
.join("\n");
‚ãÆ----
// Construct CSS and JS from components
let css = format!(
‚ãÆ----
let js = format!(
‚ãÆ----
// Get local font CSS (cached fonts, no network loading)
</file>

<file path="src/overlay/realtime_webview/wndproc.rs">
use super::webview::update_webview_text;
‚ãÆ----
use std::sync::atomic::Ordering;
‚ãÆ----
use wry::Rect;
pub unsafe extern "system" fn realtime_wnd_proc(
‚ãÆ----
if let Ok(state) = REALTIME_STATE.lock() {
‚ãÆ----
let pos = state.last_committed_pos.min(full.len());
‚ãÆ----
let old = old_raw.trim_end();
let new = new_raw.trim_start();
if !old.is_empty() && !new.is_empty() {
(old.to_string(), format!(" {}", new))
‚ãÆ----
(old.to_string(), new.to_string())
‚ãÆ----
update_webview_text(hwnd, &old_text, &new_text);
LRESULT(0)
‚ãÆ----
let rms_bits = REALTIME_RMS.load(Ordering::Relaxed);
‚ãÆ----
let script = format!("if(window.updateVolume) window.updateVolume({});", rms);
REALTIME_WEBVIEWS.with(|wvs| {
if let Some(webview) = wvs.borrow().get(&hwnd_key) {
let _ = webview.evaluate_script(&script);
‚ãÆ----
let script = format!(
‚ãÆ----
let _ = webview.set_bounds(Rect {
‚ãÆ----
let _ = PostMessageW(Some(hwnd), WM_APP_REALTIME_HIDE, WPARAM(0), LPARAM(0));
‚ãÆ----
REALTIME_STOP_SIGNAL.store(true, Ordering::SeqCst);
crate::api::tts::TTS_MANAGER.stop();
let _ = ShowWindow(hwnd, SW_HIDE);
if !std::ptr::addr_of!(TRANSLATION_HWND).read().is_invalid() {
let _ = ShowWindow(TRANSLATION_HWND, SW_HIDE);
‚ãÆ----
let _ = DestroyWindow(hwnd);
‚ãÆ----
let _ = DestroyWindow(TRANSLATION_HWND);
‚ãÆ----
PostQuitMessage(0);
‚ãÆ----
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
‚ãÆ----
pub unsafe extern "system" fn translation_wnd_proc(
‚ãÆ----
let old = state.committed_translation.trim_end();
let new = state.uncommitted_translation.trim_start();
‚ãÆ----
let app_selected = SELECTED_APP_PID.load(Ordering::SeqCst) > 0;
‚ãÆ----
.lock()
.map(|s| s.is_empty() || s.as_str() == "mic")
.unwrap_or(true);
‚ãÆ----
if REALTIME_TTS_ENABLED.load(Ordering::SeqCst) && tts_allowed && !old_text.is_empty() {
let old_len = old_text.len();
if LAST_SPOKEN_LENGTH.load(Ordering::SeqCst) == 0 && old_len > 50 {
let text = old_text.trim_end();
let search_limit = text.len().saturating_sub(1);
‚ãÆ----
.rfind(|c| c == '.' || c == '?' || c == '!' || c == '\n');
‚ãÆ----
LAST_SPOKEN_LENGTH.store(idx + 1, Ordering::SeqCst);
‚ãÆ----
let last_spoken = LAST_SPOKEN_LENGTH.load(Ordering::SeqCst);
‚ãÆ----
let new_committed = old_text[last_spoken..].to_string();
if !new_committed.trim().is_empty() {
if let Ok(mut queue) = COMMITTED_TRANSLATION_QUEUE.lock() {
queue.push_back(new_committed.clone());
‚ãÆ----
crate::api::tts::TTS_MANAGER.speak_realtime(&new_committed, hwnd_val);
‚ãÆ----
LAST_SPOKEN_LENGTH.store(old_len, Ordering::SeqCst);
‚ãÆ----
let _ = webview.evaluate_script(script);
‚ãÆ----
let _ = PostMessageW(
Some(REALTIME_HWND),
‚ãÆ----
WPARAM(0),
LPARAM(0),
‚ãÆ----
WM_DESTROY => LRESULT(0),
</file>

<file path="src/overlay/result/paint.rs">
use super::layout::should_show_buttons;
‚ãÆ----
use std::mem::size_of;
use windows::core::w;
‚ãÆ----
unsafe fn measure_text_bounds(
‚ãÆ----
let hfont = CreateFontW(
‚ãÆ----
w!("Google Sans Flex"),
‚ãÆ----
let old_font = SelectObject(hdc, hfont.into());
‚ãÆ----
DrawTextW(
‚ãÆ----
SelectObject(hdc, old_font);
let _ = DeleteObject(hfont.into());
‚ãÆ----
pub fn create_bitmap_from_pixels(pixels: &[u32], w: i32, h: i32) -> HBITMAP {
‚ãÆ----
let hdc = GetDC(None);
‚ãÆ----
let hbm = CreateDIBSection(Some(hdc), &bmi, DIB_RGB_COLORS, &mut bits, None, 0).unwrap();
if !bits.is_null() {
‚ãÆ----
pixels.as_ptr() as *const u8,
‚ãÆ----
pixels.len() * 4,
‚ãÆ----
ReleaseDC(None, hdc);
‚ãÆ----
fn dist_segment(px: f32, py: f32, ax: f32, ay: f32, bx: f32, by: f32) -> f32 {
‚ãÆ----
let h = (pax * bax + pay * bay) / (bax * bax + bay * bay).max(0.001);
let h = h.clamp(0.0, 1.0);
‚ãÆ----
(dx * dx + dy * dy).sqrt()
‚ãÆ----
fn sd_box(px: f32, py: f32, cx: f32, cy: f32, w: f32, h: f32) -> f32 {
let dx = (px - cx).abs() - w;
let dy = (py - cy).abs() - h;
(dx.max(0.0).powi(2) + dy.max(0.0).powi(2)).sqrt() + dx.max(dy).min(0.0)
‚ãÆ----
pub fn paint_window(hwnd: HWND) {
‚ãÆ----
let hdc = BeginPaint(hwnd, &mut ps);
‚ãÆ----
let _ = GetClientRect(hwnd, &mut rect);
‚ãÆ----
let mut states = WINDOW_STATES.lock().unwrap();
if let Some(state) = states.get_mut(&(hwnd.0 as isize)) {
if state.bg_bitmap.is_invalid() || state.bg_w != width || state.bg_h != height {
if !state.bg_bitmap.is_invalid() {
let _ = DeleteObject(state.bg_bitmap.into());
‚ãÆ----
CreateDIBSection(Some(hdc), &bmi, DIB_RGB_COLORS, &mut p_bg_bits, None, 0)
.unwrap();
if !p_bg_bits.is_null() {
‚ãÆ----
pixels[start..end].fill(col);
‚ãÆ----
.iter()
.map(|p| (p.x, p.y, p.life, p.size, p.color))
.collect();
‚ãÆ----
Some((
‚ãÆ----
&& crate::api::tts::TTS_MANAGER.is_speaking(state.tts_request_id);
‚ãÆ----
state.text_history.len(),
state.redo_history.len(),
‚ãÆ----
state.graphics_mode.clone(),
state.preset_prompt.clone(),
state.input_text.clone(),
‚ãÆ----
"standard".to_string(),
‚ãÆ----
let mem_dc = CreateCompatibleDC(Some(hdc));
‚ãÆ----
let scratch_bitmap = CreateDIBSection(
Some(hdc),
‚ãÆ----
let old_scratch = SelectObject(mem_dc, scratch_bitmap.into());
if !cached_bg_bm.is_invalid() {
let cache_dc = CreateCompatibleDC(Some(hdc));
let old_cbm = SelectObject(cache_dc, cached_bg_bm.into());
let _ = BitBlt(mem_dc, 0, 0, width, height, Some(cache_dc), 0, 0, SRCCOPY).ok();
SelectObject(cache_dc, old_cbm);
let _ = DeleteDC(cache_dc);
‚ãÆ----
if cache_dirty || cached_text_bm.is_invalid() {
if !cached_text_bm.is_invalid() {
let _ = DeleteObject(cached_text_bm.into());
‚ãÆ----
cached_text_bm = CreateCompatibleBitmap(hdc, width, height);
‚ãÆ----
let old_cache_bm = SelectObject(cache_dc, cached_text_bm.into());
let dark_brush = CreateSolidBrush(COLORREF(bg_color_u32));
‚ãÆ----
FillRect(cache_dc, &fill_rect, dark_brush);
let _ = DeleteObject(dark_brush.into());
SetBkMode(cache_dc, TRANSPARENT);
SetTextColor(cache_dc, COLORREF(0x00FFFFFF));
‚ãÆ----
vec![0u16; 1]
‚ãÆ----
let combined = if input_text.is_empty() {
preset_prompt.clone()
‚ãÆ----
format!("{}\n\n{}", preset_prompt, input_text)
‚ãÆ----
.encode_utf16()
.chain(std::iter::once(0))
‚ãÆ----
let text_len = GetWindowTextLengthW(hwnd) + 1;
let mut b = vec![0u16; text_len as usize];
GetWindowTextW(hwnd, &mut b);
‚ãÆ----
let available_w = (width - (h_padding * 2)).max(1);
‚ãÆ----
let available_h = (height - v_safety_margin).max(1);
‚ãÆ----
18.min(available_h)
‚ãÆ----
available_h.min(100)
‚ãÆ----
let (h, w) = measure_text_bounds(cache_dc, &mut buf, mid, available_w);
‚ãÆ----
let old_font = SelectObject(cache_dc, hfont.into());
‚ãÆ----
let offset_y = ((height - text_h) / 2).max(0);
‚ãÆ----
DrawTextW(cache_dc, &mut buf, &mut draw_rect as *mut _, draw_flags);
SelectObject(cache_dc, old_font);
‚ãÆ----
SelectObject(cache_dc, old_cache_bm);
‚ãÆ----
let old_cbm = SelectObject(cache_dc, cached_text_bm.into());
‚ãÆ----
if !scratch_bits.is_null() {
‚ãÆ----
let cycle = (anim_offset.abs() % 360.0) / 180.0;
‚ãÆ----
margin + ((t * scan_range as f32) as i32).clamp(0, scan_range - 1);
‚ãÆ----
if idx < raw_pixels.len() {
‚ãÆ----
let time_rad = anim_offset.to_radians();
‚ãÆ----
let d = sd_rounded_box(px, py, bx, by, 12.0);
‚ãÆ----
let dist = d.abs();
‚ãÆ----
let angle = py.atan2(px);
let noise = (angle * 12.0 - time_rad * 2.0).sin() * 0.5;
‚ãÆ----
let t = (dist / glow_width).clamp(0.0, 1.0);
let base_intensity = (1.0 - t).powi(3);
‚ãÆ----
let noise_mod = (1.0 + noise * 0.3).clamp(0.0, 2.0);
‚ãÆ----
(base_intensity * noise_mod).clamp(0.0, 1.0);
‚ãÆ----
let deg = angle.to_degrees() + (anim_offset * 2.0);
‚ãÆ----
let rgb = hsv_to_rgb(hue, 0.85, 1.0);
‚ãÆ----
let min_x = (d_x - radius - 1.0).floor() as i32;
let max_x = (d_x + radius + 1.0).ceil() as i32;
let min_y = (d_y - radius - 1.0).floor() as i32;
let max_y = (d_y + radius + 1.0).ceil() as i32;
let start_x = min_x.max(0);
let end_x = max_x.min(width - 1);
let start_y = min_y.max(0);
let end_y = max_y.min(height - 1);
‚ãÆ----
let dist = (dx * dx + dy * dy).sqrt();
let aa_edge = (radius + 0.5 - dist).clamp(0.0, 1.0);
‚ãÆ----
&& should_show_buttons(width, height)
‚ãÆ----
for y in b_start_y.max(0)..b_end_y.min(height) {
‚ãÆ----
let dy = (fy - cy).abs();
‚ãÆ----
let dx = (fx - cx_back).abs();
‚ãÆ----
let aa = (radius + 0.5 - dist).clamp(0.0, 1.0);
‚ãÆ----
border_alpha = ((radius + 0.5 - dist).clamp(0.0, 1.0)
* ((dist - (border_inner_radius - 0.5)).clamp(0.0, 1.0)))
‚ãÆ----
let d_shaft = dist_segment(fx, fy, tip_x, cy, tail_x, cy);
‚ãÆ----
dist_segment(fx, fy, tip_x, cy, tip_x + 3.0, cy - 3.0);
‚ãÆ----
dist_segment(fx, fy, tip_x, cy, tip_x + 3.0, cy + 3.0);
let d_arrow = d_shaft.min(d_wing1).min(d_wing2);
icon_alpha = (1.3 - d_arrow).clamp(0.0, 1.0);
‚ãÆ----
let dx = (fx - cx_forward).abs();
‚ãÆ----
let d_shaft = dist_segment(fx, fy, tail_x, cy, tip_x, cy);
‚ãÆ----
dist_segment(fx, fy, tip_x, cy, tip_x - 3.0, cy - 3.0);
‚ãÆ----
dist_segment(fx, fy, tip_x, cy, tip_x - 3.0, cy + 3.0);
‚ãÆ----
let dx_c = (fx - cx_copy).abs();
let dist_c = (dx_c * dx_c + dy * dy).sqrt();
let aa_c = (radius + 0.5 - dist_c).clamp(0.0, 1.0);
‚ãÆ----
border_alpha = ((radius + 0.5 - dist_c).clamp(0.0, 1.0)
* ((dist_c - (border_inner_radius - 0.5)).clamp(0.0, 1.0)))
‚ãÆ----
let d1 = dist_segment(
‚ãÆ----
let d2 = dist_segment(
‚ãÆ----
icon_alpha = (1.8 - d1.min(d2)).clamp(0.0, 1.0);
‚ãÆ----
let back_d = sd_box(fx, fy, cx_copy - 2.0, cy - 2.0, 3.0, 4.0);
let back_outline = (1.25 - back_d.abs()).clamp(0.0, 1.0);
let front_d = sd_box(fx, fy, cx_copy + 2.0, cy + 2.0, 3.0, 4.0);
let front_fill = (0.8 - front_d).clamp(0.0, 1.0);
let mask_d = sd_box(fx, fy, cx_copy + 2.0, cy + 2.0, 4.5, 5.5);
‚ãÆ----
+ back_outline * mask_d.clamp(0.0, 1.0))
.clamp(0.0, 1.0);
‚ãÆ----
let dx_e = (fx - cx_edit).abs();
let dist_e = (dx_e * dx_e + dy * dy).sqrt();
let aa_e = (radius + 0.5 - dist_e).clamp(0.0, 1.0);
‚ãÆ----
border_alpha = ((radius + 0.5 - dist_e).clamp(0.0, 1.0)
* ((dist_e - (border_inner_radius - 0.5)).clamp(0.0, 1.0)))
‚ãÆ----
let sx = (fx - cx_edit).abs();
let sy = (fy - cy).abs();
‚ãÆ----
(sx.powf(0.6) + sy.powf(0.6)).powf(1.0 / 0.6) - 4.5;
let mut ia = (1.2 - star_dist).clamp(0.0, 1.0);
let sx2 = (fx - (cx_edit + 4.5)).abs();
let sy2 = (fy - (cy - 3.5)).abs();
‚ãÆ----
(sx2.powf(0.6) + sy2.powf(0.6)).powf(1.0 / 0.6) - 2.2;
ia = ia.max((1.2 - star2_dist).clamp(0.0, 1.0));
‚ãÆ----
let dx_m = (fx - cx_md).abs();
let dist_m = (dx_m * dx_m + dy * dy).sqrt();
let aa_m = (radius + 0.5 - dist_m).clamp(0.0, 1.0);
‚ãÆ----
border_alpha = ((radius + 0.5 - dist_m).clamp(0.0, 1.0)
* ((dist_m - (border_inner_radius - 0.5)).clamp(0.0, 1.0)))
‚ãÆ----
let d_m1 = dist_segment(
‚ãÆ----
let d_m2 = dist_segment(
‚ãÆ----
let d_m3 = dist_segment(
‚ãÆ----
let d_m4 = dist_segment(
‚ãÆ----
let d_m = d_m1.min(d_m2).min(d_m3).min(d_m4);
icon_alpha = (1.5 - d_m).clamp(0.0, 1.0);
‚ãÆ----
let dx_dl = (fx - cx_dl).abs();
let dist_dl = (dx_dl * dx_dl + dy * dy).sqrt();
let aa_dl = (radius + 0.5 - dist_dl).clamp(0.0, 1.0);
‚ãÆ----
border_alpha = ((radius + 0.5 - dist_dl).clamp(0.0, 1.0)
‚ãÆ----
.clamp(0.0, 1.0)))
‚ãÆ----
dist_segment(fx, fy, cx_dl, cy - 4.0, cx_dl, cy + 2.0);
let d_arrow1 = dist_segment(
‚ãÆ----
let d_arrow2 = dist_segment(
‚ãÆ----
let d_tray = dist_segment(
‚ãÆ----
let d_icon = d_line.min(d_arrow1).min(d_arrow2).min(d_tray);
icon_alpha = (1.5 - d_icon).clamp(0.0, 1.0);
‚ãÆ----
let dx_u = (fx - cx_undo).abs();
let dist_u = (dx_u * dx_u + dy * dy).sqrt();
let aa_u = (radius + 0.5 - dist_u).clamp(0.0, 1.0);
‚ãÆ----
border_alpha = ((radius + 0.5 - dist_u).clamp(0.0, 1.0)
* ((dist_u - (border_inner_radius - 0.5)).clamp(0.0, 1.0)))
‚ãÆ----
let dx_rd = (fx - cx_redo).abs();
let dist_rd = (dx_rd * dx_rd + dy * dy).sqrt();
let aa_rd = (radius + 0.5 - dist_rd).clamp(0.0, 1.0);
‚ãÆ----
border_alpha = ((radius + 0.5 - dist_rd).clamp(0.0, 1.0)
‚ãÆ----
let dx_sp = (fx - cx_speaker).abs();
let dist_sp = (dx_sp * dx_sp + dy * dy).sqrt();
let aa_sp = (radius + 0.5 - dist_sp).clamp(0.0, 1.0);
‚ãÆ----
border_alpha = ((radius + 0.5 - dist_sp).clamp(0.0, 1.0)
‚ãÆ----
let d_cone = sd_box(
‚ãÆ----
let d_bell1 = dist_segment(
‚ãÆ----
let d_bell2 = dist_segment(
‚ãÆ----
let d_bell3 = dist_segment(
‚ãÆ----
let d_bell = d_bell1.min(d_bell2).min(d_bell3);
‚ãÆ----
let angle = py_wave.atan2(px);
‚ãÆ----
if px > 0.0 && angle.abs() < std::f32::consts::FRAC_PI_3 {
let dist_from_center = (px * px + py_wave * py_wave).sqrt();
let d_wave1 = (dist_from_center - 3.5).abs() - 0.8;
let d_wave2 = (dist_from_center - 6.0).abs() - 0.8;
d_wave = d_wave1.min(d_wave2);
‚ãÆ----
let d_speaker = d_cone.min(d_bell).min(d_wave);
icon_alpha = (1.5 - d_speaker).clamp(0.0, 1.0);
‚ãÆ----
| ((final_r.min(255.0) as u32) << 16)
| ((final_g.min(255.0) as u32) << 8)
| (final_b.min(255.0) as u32);
‚ãÆ----
let pixels = render_procedural_broom(params);
let hbm = create_bitmap_from_pixels(&pixels, BROOM_W, BROOM_H);
Some((bx, by, hbm))
‚ãÆ----
if !hbm.is_invalid() {
let broom_dc = CreateCompatibleDC(Some(hdc));
let old_hbm_broom = SelectObject(broom_dc, hbm.into());
‚ãÆ----
let _ = GdiAlphaBlend(
‚ãÆ----
SelectObject(broom_dc, old_hbm_broom);
let _ = DeleteDC(broom_dc);
let _ = DeleteObject(hbm.into());
‚ãÆ----
let _ = BitBlt(hdc, 0, 0, width, height, Some(mem_dc), 0, 0, SRCCOPY).ok();
SelectObject(mem_dc, old_scratch);
let _ = DeleteObject(scratch_bitmap.into());
let _ = DeleteDC(mem_dc);
let _ = EndPaint(hwnd, &mut ps);
</file>

<file path="src/overlay/result/state.rs">
use std::collections::HashMap;
‚ãÆ----
pub struct DustParticle {
‚ãÆ----
pub enum AnimationMode {
‚ãÆ----
pub enum ResizeEdge {
‚ãÆ----
pub enum InteractionMode {
‚ãÆ----
pub struct CursorPhysics {
‚ãÆ----
impl Default for CursorPhysics {
fn default() -> Self {
‚ãÆ----
pub enum RefineContext {
‚ãÆ----
pub struct WindowState {
‚ãÆ----
unsafe impl Send for WindowState {}
unsafe impl Sync for WindowState {}
‚ãÆ----
pub enum WindowType {
‚ãÆ----
pub fn link_windows(hwnd1: HWND, hwnd2: HWND) {
let mut states = WINDOW_STATES.lock().unwrap();
if let Some(s1) = states.get_mut(&(hwnd1.0 as isize)) {
s1.linked_window = Some(hwnd2);
‚ãÆ----
if let Some(s2) = states.get_mut(&(hwnd2.0 as isize)) {
s2.linked_window = Some(hwnd1);
‚ãÆ----
pub fn close_windows_with_token(token: &Arc<AtomicBool>) {
token.store(true, Ordering::SeqCst);
‚ãÆ----
let states = WINDOW_STATES.lock().unwrap();
for (&h_val, state) in states.iter() {
‚ãÆ----
to_close.push(HWND(h_val as *mut std::ffi::c_void));
‚ãÆ----
if IsWindow(Some(hwnd)).as_bool() {
let _ = PostMessageW(
Some(hwnd),
</file>

<file path="src/overlay/result/window.rs">
use std::mem::size_of;
use std::sync::Once;
‚ãÆ----
use windows::Win32::UI::Input::KeyboardAndMouse::SetFocus;
‚ãÆ----
use super::event_handler::result_wnd_proc;
‚ãÆ----
pub fn get_chain_color(visible_index: usize) -> u32 {
‚ãÆ----
let cycle_idx = (visible_index - 1) % (CHAIN_PALETTE.len() - 1);
‚ãÆ----
unsafe fn set_rounded_edit_region(h_edit: HWND, w: i32, h: i32) {
let rgn = CreateRoundRectRgn(0, 0, w, h, 12, 12);
let _ = SetWindowRgn(h_edit, Some(rgn), true);
‚ãÆ----
pub fn create_result_window(
‚ãÆ----
let instance = GetModuleHandleW(None).unwrap();
let class_name = w!("TranslationResult");
REGISTER_RESULT_CLASS.call_once(|| {
‚ãÆ----
wc.lpfnWndProc = Some(result_wnd_proc);
wc.hInstance = instance.into();
wc.hCursor = LoadCursorW(None, IDC_ARROW).unwrap();
‚ãÆ----
let _ = RegisterClassW(&wc);
‚ãÆ----
let width = (target_rect.right - target_rect.left).abs();
let height = (target_rect.bottom - target_rect.top).abs();
‚ãÆ----
let hwnd = CreateWindowExW(
‚ãÆ----
w!(""),
‚ãÆ----
Some(instance.into()),
‚ãÆ----
.unwrap_or_default();
// FOR MARKDOWN MODE: Create WebView IMMEDIATELY after window creation
// See docs/WEBVIEW2_INITIALIZATION.md for why this is necessary
‚ãÆ----
let _ = SetLayeredWindowAttributes(hwnd, COLORREF(0), 0, LWA_ALPHA);
‚ãÆ----
let _ = SetLayeredWindowAttributes(hwnd, COLORREF(0), 220, LWA_ALPHA);
‚ãÆ----
let edit_style = WINDOW_STYLE(
‚ãÆ----
let h_edit = CreateWindowExW(
‚ãÆ----
w!("EDIT"),
‚ãÆ----
0, // Sized dynamically
Some(hwnd),
Some(HMENU(101 as *mut core::ffi::c_void)),
‚ãÆ----
let hfont = CreateFontW(
‚ãÆ----
w!("Segoe UI"),
‚ãÆ----
SendMessageW(
‚ãÆ----
Some(WPARAM(hfont.0 as usize)),
Some(LPARAM(1)),
‚ãÆ----
let app = crate::APP.lock().unwrap();
app.config.graphics_mode.clone()
‚ãÆ----
let mut states = WINDOW_STATES.lock().unwrap();
states.insert(
‚ãÆ----
full_text: initial_text.clone(),
‚ãÆ----
pending_text: Some(initial_text),
‚ãÆ----
let _ = DwmSetWindowAttribute(
‚ãÆ----
DWMWINDOWATTRIBUTE(33),
‚ãÆ----
let _ = SetWindowPos(
‚ãÆ----
Some(HWND_TOP),
‚ãÆ----
set_rounded_edit_region(h_edit, edit_w, edit_h);
let _ = SetForegroundWindow(hwnd);
let _ = SetFocus(Some(h_edit));
‚ãÆ----
SetTimer(Some(hwnd), 3, 16, None);
‚ãÆ----
SetTimer(Some(hwnd), 2, 30, None);
‚ãÆ----
let _ = InvalidateRect(Some(hwnd), None, false);
let _ = UpdateWindow(hwnd);
‚ãÆ----
pub fn update_window_text(hwnd: HWND, text: &str) {
if !unsafe { IsWindow(Some(hwnd)).as_bool() } {
‚ãÆ----
if let Some(state) = states.get_mut(&(hwnd.0 as isize)) {
state.pending_text = Some(text.to_string());
state.full_text = text.to_string();
</file>

<file path="src/updater.rs">
use std::sync::mpsc::Sender;
use std::thread;
‚ãÆ----
pub enum UpdateStatus {
‚ãÆ----
pub struct Updater {
‚ãÆ----
impl Updater {
pub fn new(tx: Sender<UpdateStatus>) -> Self {
‚ãÆ----
pub fn check_for_updates(&self) {
let tx = self.tx.clone();
‚ãÆ----
let _ = tx.send(UpdateStatus::Checking);
‚ãÆ----
.timeout_global(Some(std::time::Duration::from_secs(10)))
.build();
let agent: ureq::Agent = config.into();
‚ãÆ----
.get(url)
.header("User-Agent", "screen-goated-toolbox-checker")
.call();
‚ãÆ----
let release_json: String = match resp.body_mut().read_to_string() {
‚ãÆ----
let _ = tx.send(UpdateStatus::Error(format!(
‚ãÆ----
Ok(mut releases) if !releases.is_empty() => {
let rel = releases.remove(0);
‚ãÆ----
rel.get("tag_name").and_then(|v| v.as_str()).unwrap_or("");
let version = tag_name.trim_start_matches('v').to_string();
‚ãÆ----
.get("body")
.and_then(|v| v.as_str())
.unwrap_or("")
.to_string();
let current = env!("CARGO_PKG_VERSION");
‚ãÆ----
.unwrap_or(false);
‚ãÆ----
let _ = tx.send(UpdateStatus::UpdateAvailable { version, body });
‚ãÆ----
let _ = tx.send(UpdateStatus::UpToDate(current.to_string()));
‚ãÆ----
let _ = tx.send(UpdateStatus::Error(
"No releases found on GitHub".to_string(),
‚ãÆ----
tx.send(UpdateStatus::Error(format!("JSON parse error: {}", e)));
‚ãÆ----
let err_str = e.to_string();
if err_str.contains("403") {
"Status 403: GitHub API rate limit reached or access forbidden. Please try again later or check your network/VPN.".to_string()
‚ãÆ----
format!("Network error: {}", e)
‚ãÆ----
pub fn perform_update(&self) {
‚ãÆ----
let _ = tx.send(UpdateStatus::Downloading);
‚ãÆ----
Ok(exe_path) => match exe_path.parent() {
Some(dir) => dir.to_path_buf(),
‚ãÆ----
"Could not find exe directory".to_string(),
‚ãÆ----
let _ = tx.send(UpdateStatus::Error("Could not get exe path".to_string()));
‚ãÆ----
let temp_path = exe_dir.join("temp_download");
let mut staging_path = exe_dir.join("update_pending.exe");
‚ãÆ----
.header("User-Agent", "screen-goated-toolbox-updater")
.call()
‚ãÆ----
match response.body_mut().read_to_string() {
‚ãÆ----
let _ = tx.send(UpdateStatus::Error(format!("Failed to parse response: {}", e)));
‚ãÆ----
"Status 403: GitHub API rate limit reached or access forbidden. Please try again later.".to_string()
‚ãÆ----
format!("Failed to fetch release list: {}", e)
‚ãÆ----
let _ = tx.send(UpdateStatus::Error(error_msg));
‚ãÆ----
.get("name")
‚ãÆ----
.to_string(),
‚ãÆ----
.get("tag_name")
‚ãÆ----
.trim_start_matches('v')
‚ãÆ----
.get("published_at")
‚ãÆ----
.map(|s| s.to_string()),
‚ãÆ----
.get("assets")
.and_then(|a| a.as_array())
.unwrap_or(&vec![])
.iter()
.filter_map(|asset| {
let name = asset.get("name")?.as_str()?.to_string();
‚ãÆ----
asset.get("browser_download_url")?.as_str()?.to_string();
Some(self_update::update::ReleaseAsset { name, download_url })
‚ãÆ----
.collect(),
‚ãÆ----
let _ = tx.send(UpdateStatus::Error("No releases found".to_string()));
‚ãÆ----
let is_nopack = cfg!(nopack);
‚ãÆ----
.find(|a| {
let is_exe_zip = a.name.ends_with(".exe") || a.name.ends_with(".zip");
‚ãÆ----
a.name.contains("nopack")
‚ãÆ----
!a.name.contains("nopack")
‚ãÆ----
.or_else(|| {
‚ãÆ----
let _ = tx.send(UpdateStatus::Error(msg.to_string()));
‚ãÆ----
if asset.name.ends_with(".exe") {
staging_path = exe_dir.join(&asset.name);
‚ãÆ----
match ureq::get(&asset.download_url).call() {
‚ãÆ----
let mut reader = response.into_body().into_reader();
‚ãÆ----
let _ = tx.send(UpdateStatus::Error(format!("Download failed: {}", e)));
‚ãÆ----
drop(file);
if asset.name.ends_with(".zip") {
‚ãÆ----
Ok(mut archive) => match archive.by_index(0) {
‚ãÆ----
.is_ok()
‚ãÆ----
let _ = tx.send(
‚ãÆ----
"Failed to extract zip".to_string(),
‚ãÆ----
let _ = tx.send(UpdateStatus::UpdatedAndRestartRequired);
</file>

<file path="build.ps1">
# Re-patch egui-snarl to ensure custom scroll-to-zoom is applied
Write-Host "Setting up patched egui-snarl..." -ForegroundColor Cyan
$snarlDir = Join-Path $PSScriptRoot "libs\egui-snarl"
if (Test-Path $snarlDir) {
    Remove-Item $snarlDir -Recurse -Force
}
& (Join-Path $PSScriptRoot "scripts\setup-egui-snarl.ps1")

# --- Build PromptDJ Frontend ---
Write-Host "Building PromptDJ Frontend..." -ForegroundColor Cyan
$pdjDir = Join-Path $PSScriptRoot "promptdj-midi"
$pdjDist = Join-Path $pdjDir "dist"
$pdjTargetDist = Join-Path $PSScriptRoot "src\overlay\prompt_dj\dist"

Push-Location $pdjDir
try {
    npm run build
} finally {
    Pop-Location
}

if (Test-Path $pdjDist) {
    if (-not (Test-Path $pdjTargetDist)) {
        New-Item -ItemType Directory -Path $pdjTargetDist -Force | Out-Null
    }
    Copy-Item -Path "$pdjDist\*" -Destination $pdjTargetDist -Recurse -Force
    Write-Host "PromptDJ assets synchronized." -ForegroundColor Green
} else {
    Write-Host "FAILED: PromptDJ build did not produce dist folder." -ForegroundColor Red
    exit 1
}

# --- Continue Main Build ---
# Extract version from Cargo.toml
$cargoContent = Get-Content "Cargo.toml" -Raw
if ($cargoContent -match 'version\s*=\s*"([^"]+)"') {
    $version = $matches[1]
}
else {
    Write-Host "Failed to extract version from Cargo.toml" -ForegroundColor Red
    exit 1
}

$upxDir = "tools/upx"
$upxPath = "$upxDir/upx.exe"

# Download UPX if not present
if (-not (Test-Path $upxPath)) {
    Write-Host "Downloading UPX..." -ForegroundColor Cyan
    New-Item -ItemType Directory -Path $upxDir -Force | Out-Null
    
    $url = "https://github.com/upx/upx/releases/download/v5.0.2/upx-5.0.2-win64.zip"
    $zip = "$upxDir/upx.zip"
    
    Invoke-WebRequest -Uri $url -OutFile $zip
    Expand-Archive -Path $zip -DestinationPath $upxDir -Force
    Move-Item "$upxDir/upx-5.0.2-win64/upx.exe" $upxPath -Force
    Remove-Item "$upxDir/upx-5.0.2-win64" -Recurse
    Remove-Item $zip
    
    Write-Host "UPX downloaded" -ForegroundColor Green
}

# Output paths
$outputExeNamePacked = "ScreenGoatedToolbox_v$version.exe"
$outputExeNameNoPack = "ScreenGoatedToolbox_v${version}_nopack.exe"
$outputPathPacked = "target/release/$outputExeNamePacked"
$outputPathNoPack = "target/release-safe/$outputExeNameNoPack"
$exePathRelease = "target/release/screen-goated-toolbox.exe"
$exePathSafe = "target/release-safe/screen-goated-toolbox.exe"

# =============================================================================
# STEP 1: Build AV-SAFE version (with debug symbols, no stripping)
# =============================================================================
Write-Host ""
Write-Host "=== Building AV-SAFE version (v$version) ===" -ForegroundColor Cyan
Write-Host "Using 'release-safe' profile with debug symbols for better AV trust..." -ForegroundColor Gray
$env:RUSTFLAGS="--cfg nopack"
cargo build --profile release-safe
$env:RUSTFLAGS=""

if (Test-Path $exePathSafe) {
    if (Test-Path $outputPathNoPack) {
        Remove-Item $outputPathNoPack
    }
    Move-Item $exePathSafe $outputPathNoPack
    $sizeNoPack = (Get-Item $outputPathNoPack).Length / 1MB
    Write-Host "  -> Created: $outputExeNameNoPack ($([Math]::Round($sizeNoPack, 2)) MB)" -ForegroundColor Cyan
}
else {
    Write-Host "  -> FAILED: release-safe build did not produce exe" -ForegroundColor Red
}

# =============================================================================
# STEP 2: Build PACKED version (stripped + UPX compressed)
# =============================================================================
Write-Host ""
Write-Host "=== Building PACKED version (v$version) ===" -ForegroundColor Green
Write-Host "Using 'release' profile with UPX compression..." -ForegroundColor Gray
cargo build --release

if (Test-Path $exePathRelease) {
    Write-Host "Compressing with UPX (--ultra-brute --lzma)..." -ForegroundColor Green
    & $upxPath --ultra-brute --lzma $exePathRelease
    
    if (Test-Path $outputPathPacked) {
        Remove-Item $outputPathPacked
    }
    Move-Item $exePathRelease $outputPathPacked
    $sizePacked = (Get-Item $outputPathPacked).Length / 1MB
    Write-Host "  -> Created: $outputExeNamePacked ($([Math]::Round($sizePacked, 2)) MB)" -ForegroundColor Green
}
else {
    Write-Host "  -> FAILED: release build did not produce exe" -ForegroundColor Red
}

# =============================================================================
# SUMMARY
# =============================================================================
Write-Host ""
Write-Host "=======================================" -ForegroundColor White
Write-Host "         BUILD COMPLETE v$version" -ForegroundColor White
Write-Host "=======================================" -ForegroundColor White
Write-Host ""
if (Test-Path $outputPathPacked) {
    Write-Host "  [PACKED]   $outputExeNamePacked" -ForegroundColor Green
    Write-Host "             Size: $([Math]::Round($sizePacked, 2)) MB | UPX compressed" -ForegroundColor Gray
}
if (Test-Path $outputPathNoPack) {
    Write-Host ""
    Write-Host "  [AV-SAFE]  $outputExeNameNoPack" -ForegroundColor Cyan
    Write-Host "             Size: $([Math]::Round($sizeNoPack, 2)) MB | Has debug symbols, no UPX" -ForegroundColor Gray
}
Write-Host ""
Write-Host "TIP: Offer '_nopack' to users with Windows Defender issues." -ForegroundColor Yellow
Write-Host ""
</file>

<file path="promptdj-midi/components/PromptController.ts">
import { css, html, LitElement } from 'lit';
import { customElement, property, query, state } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
‚ãÆ----
import type { WeightKnob } from './WeightKnob';
import type { MidiDispatcher } from '../utils/MidiDispatcher';
import type { Prompt, ControlChange } from '../types';
import { LOCALES, Lang } from '../utils/Locales';
‚ãÆ----
export class PromptController extends LitElement
‚ãÆ----
@property({ type: Number }) channel = 0; // Not currently used
‚ãÆ----
override connectedCallback()
override firstUpdated()
‚ãÆ----
this.textInput.setAttribute('dir', 'ltr'); // Ensure LTR direction to avoid RTL heuristics
‚ãÆ----
override update(changedProperties: Map<string, unknown>)
‚ãÆ----
// Avoid resetting the contenteditable while the user is typing, which can move the caret
‚ãÆ----
private dispatchPromptChange()
private onKeyDown(e: KeyboardEvent)
private onInlineInput()
‚ãÆ----
// Live-update arc text while typing (span is invisible, arc shows)
‚ãÆ----
// Do not commit lastValidText until stopEditing; but propagate for live behavior
‚ãÆ----
private resetText()
private async stopEditing()
private onFocus()
‚ãÆ----
range.collapse(false); // place caret at end
‚ãÆ----
private startEditing()
private updateWeight()
private toggleLearnMode()
override render()
‚ãÆ----
interface HTMLElementTagNameMap {
    'prompt-controller': PromptController;
  }
</file>

<file path="promptdj-midi/components/ToastMessage.ts">
import { css, html, LitElement } from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
‚ãÆ----
export class ToastMessage extends LitElement
‚ãÆ----
private renderMessageWithLinks()
override render()
‚ãÆ----
show(message: string, duration: number = 4000)
hide()
‚ãÆ----
interface HTMLElementTagNameMap {
    'toast-message': ToastMessage
  }
</file>

<file path="promptdj-midi/utils/MidiDispatcher.ts">
import type { ControlChange } from '../types';
export class MidiDispatcher extends EventTarget
‚ãÆ----
reset()
async getMidiAccess(): Promise<string[]>
getDeviceName(id: string): string | null
</file>

<file path="src/api/realtime_audio/transcription.rs">
use anyhow::Result;
‚ãÆ----
use crate::config::Preset;
use crate::overlay::realtime_webview::SELECTED_APP_PID;
use crate::APP;
‚ãÆ----
use super::state::SharedRealtimeState;
use super::translation::run_translation_loop;
use super::utils::update_overlay_text;
‚ãÆ----
use super::WM_VOLUME_UPDATE;
‚ãÆ----
enum AudioMode {
‚ãÆ----
pub fn start_realtime_transcription(
‚ãÆ----
let translation_send = translation_hwnd.map(crate::win_types::SendHwnd);
‚ãÆ----
transcription_thread_entry(preset, stop_signal, overlay_send, translation_send, state);
‚ãÆ----
fn transcription_thread_entry(
‚ãÆ----
let hwnd_translation = translation_send.map(|h| h.0);
‚ãÆ----
AUDIO_SOURCE_CHANGE.store(false, Ordering::SeqCst);
let result = run_realtime_transcription(
current_preset.clone(),
stop_signal.clone(),
‚ãÆ----
state.clone(),
‚ãÆ----
if !AUDIO_SOURCE_CHANGE.load(Ordering::SeqCst) {
let err_msg = format!(" [Error: {}]", e);
eprintln!("Realtime transcription error: {}", e);
if let Ok(mut s) = state.lock() {
s.append_transcript(&err_msg);
‚ãÆ----
let display_text = if let Ok(s) = state.lock() {
s.display_transcript.clone()
‚ãÆ----
update_overlay_text(hwnd_overlay, &display_text);
‚ãÆ----
if AUDIO_SOURCE_CHANGE.load(Ordering::SeqCst) {
if let Ok(new_source) = NEW_AUDIO_SOURCE.lock() {
if !new_source.is_empty() {
current_preset.audio_source = new_source.clone();
stop_signal.store(true, Ordering::SeqCst);
‚ãÆ----
stop_signal.store(false, Ordering::SeqCst);
‚ãÆ----
fn run_realtime_transcription(
‚ãÆ----
let app = APP.lock().unwrap();
app.config.gemini_api_key.clone()
‚ãÆ----
if gemini_api_key.trim().is_empty() {
return Err(anyhow::anyhow!("NO_API_KEY:google"));
‚ãÆ----
let mut socket = connect_websocket(&gemini_api_key)?;
send_setup_message(&mut socket)?;
‚ãÆ----
match socket.read() {
‚ãÆ----
let msg = msg.as_str();
if msg.contains("setupComplete") {
‚ãÆ----
if msg.contains("error") || msg.contains("Error") {
return Err(anyhow::anyhow!("Server returned error: {}", msg));
‚ãÆ----
.map(|f| format!("code={}, reason={}", f.code, f.reason))
.unwrap_or("no frame".to_string());
return Err(anyhow::anyhow!(
‚ãÆ----
if let Ok(text) = String::from_utf8(data.to_vec()) {
if text.contains("setupComplete") {
‚ãÆ----
} else if data.len() < 100 {
‚ãÆ----
if e.kind() == std::io::ErrorKind::WouldBlock
|| e.kind() == std::io::ErrorKind::TimedOut =>
‚ãÆ----
if setup_start.elapsed() > Duration::from_secs(30) {
return Err(anyhow::anyhow!("Setup timeout - no response from server"));
‚ãÆ----
return Err(e.into());
‚ãÆ----
if stop_signal.load(Ordering::Relaxed) {
return Ok(());
‚ãÆ----
set_socket_nonblocking(&mut socket)?;
‚ãÆ----
use crate::overlay::realtime_webview::REALTIME_TTS_ENABLED;
let tts_enabled = REALTIME_TTS_ENABLED.load(Ordering::SeqCst);
let selected_pid = SELECTED_APP_PID.load(Ordering::SeqCst);
‚ãÆ----
start_per_app_capture(selected_pid, audio_buffer.clone(), stop_signal.clone())?;
‚ãÆ----
_stream = Some(start_device_loopback_capture(
audio_buffer.clone(),
‚ãÆ----
_stream = Some(start_mic_capture(
‚ãÆ----
let has_translation = translation_hwnd.is_some() && preset.blocks.len() > 1;
‚ãÆ----
let translation_send = crate::win_types::SendHwnd(translation_hwnd.unwrap());
let translation_state = state.clone();
let translation_stop = stop_signal.clone();
let translation_preset = preset.clone();
‚ãÆ----
run_translation_loop(
‚ãÆ----
run_main_loop(
‚ãÆ----
drop(_stream);
Ok(())
‚ãÆ----
fn run_main_loop(
‚ãÆ----
while !stop_signal.load(Ordering::Relaxed) {
if overlay_hwnd.0 != 0 as _ && !unsafe { IsWindow(Some(overlay_hwnd)).as_bool() } {
‚ãÆ----
use crate::overlay::realtime_webview::AUDIO_SOURCE_CHANGE;
‚ãÆ----
if mode_start.elapsed() >= NORMAL_DURATION {
‚ãÆ----
silence_buffer.clear();
‚ãÆ----
if mode_start.elapsed() >= SILENCE_DURATION {
‚ãÆ----
if silence_buffer.is_empty() {
‚ãÆ----
if last_send.elapsed() >= send_interval {
‚ãÆ----
let mut buf = audio_buffer.lock().unwrap();
‚ãÆ----
if !real_audio.is_empty() {
if send_audio_chunk(&mut socket, &real_audio).is_err() {
‚ãÆ----
silence_buffer.extend(real_audio);
let silence: Vec<i16> = vec![0i16; SAMPLES_PER_100MS];
if send_audio_chunk(&mut socket, &silence).is_err() {
‚ãÆ----
let to_send: Vec<i16> = if silence_buffer.len() >= chunk_size {
silence_buffer.drain(..chunk_size).collect()
} else if !silence_buffer.is_empty() {
silence_buffer.drain(..).collect()
‚ãÆ----
if !to_send.is_empty() {
if send_audio_chunk(&mut socket, &to_send).is_err() {
‚ãÆ----
let _ = PostMessageW(Some(overlay_hwnd), WM_VOLUME_UPDATE, WPARAM(0), LPARAM(0));
‚ãÆ----
if let Some(transcript) = parse_input_transcription(msg) {
if !transcript.is_empty() {
‚ãÆ----
let display_text = if let Ok(mut s) = state.lock() {
s.append_transcript(&transcript);
‚ãÆ----
if !display_text.is_empty() {
update_overlay_text(overlay_hwnd, &display_text);
‚ãÆ----
if let Some(transcript) = parse_input_transcription(&text) {
‚ãÆ----
if !try_reconnect(
‚ãÆ----
&& last_transcription_time.elapsed()
‚ãÆ----
let error_str = e.to_string();
if error_str.contains("reset")
|| error_str.contains("closed")
|| error_str.contains("broken")
‚ãÆ----
let _ = socket.close(None);
‚ãÆ----
fn try_reconnect(
‚ãÆ----
reconnect_buffer.extend(std::mem::take(&mut *buf));
‚ãÆ----
match connect_websocket(api_key) {
‚ãÆ----
if send_setup_message(&mut new_socket).is_err() {
‚ãÆ----
if set_socket_nonblocking(&mut new_socket).is_err() {
‚ãÆ----
silence_buffer.extend(reconnect_buffer);
</file>

<file path="src/api/tts/manager.rs">
use super::utils;
use std::collections::VecDeque;
use std::sync::mpsc;
‚ãÆ----
pub struct TtsManager {
‚ãÆ----
impl TtsManager {
pub fn new() -> Self {
‚ãÆ----
pub fn _is_ready(&self) -> bool {
self._is_ready.load(Ordering::SeqCst)
‚ãÆ----
pub fn speak(&self, text: &str, hwnd: isize) -> u64 {
self.speak_internal(text, hwnd, false)
‚ãÆ----
pub fn speak_realtime(&self, text: &str, hwnd: isize) -> u64 {
self.speak_internal(text, hwnd, true)
‚ãÆ----
fn speak_internal(&self, text: &str, hwnd: isize, is_realtime: bool) -> u64 {
let id = REQUEST_ID_COUNTER.fetch_add(1, Ordering::SeqCst);
let current_gen = self.interrupt_generation.load(Ordering::SeqCst);
‚ãÆ----
let mut wq = self.work_queue.lock().unwrap();
wq.push_back((
‚ãÆ----
text: text.to_string(),
‚ãÆ----
self.work_signal.notify_one();
‚ãÆ----
let mut pq = self.playback_queue.lock().unwrap();
pq.push_back((rx, hwnd, id, current_gen, is_realtime));
‚ãÆ----
self.playback_signal.notify_one();
‚ãÆ----
pub fn speak_interrupt(&self, text: &str, hwnd: isize) -> u64 {
let new_gen = self.interrupt_generation.fetch_add(1, Ordering::SeqCst) + 1;
‚ãÆ----
wq.clear();
‚ãÆ----
pq.clear();
‚ãÆ----
pq.push_back((rx, hwnd, id, new_gen, false));
‚ãÆ----
pub fn stop(&self) {
self.interrupt_generation.fetch_add(1, Ordering::SeqCst);
‚ãÆ----
self.playback_signal.notify_all();
‚ãÆ----
pub fn stop_if_active(&self, _request_id: u64) {
self.stop();
‚ãÆ----
pub fn is_speaking(&self, _request_id: u64) -> bool {
‚ãÆ----
pub fn has_pending_audio(&self) -> bool {
if self.is_playing.load(Ordering::SeqCst) {
‚ãÆ----
.lock()
.map(|q| !q.is_empty())
.unwrap_or(false);
‚ãÆ----
pub fn _shutdown(&self) {
self.shutdown.store(true, Ordering::SeqCst);
‚ãÆ----
self.work_signal.notify_all();
‚ãÆ----
pub fn get_output_devices() -> Vec<(String, String)> {
</file>

<file path="src/config/preset/preset.rs">
use super::block::ProcessingBlock;
use crate::config::types::Hotkey;
‚ãÆ----
pub struct Preset {
‚ãÆ----
fn default_prompt_mode() -> String {
"fixed".to_string()
‚ãÆ----
fn default_preset_type() -> String {
"image".to_string()
‚ãÆ----
fn default_text_input_mode() -> String {
"select".to_string()
‚ãÆ----
fn default_audio_source() -> String {
"mic".to_string()
‚ãÆ----
fn default_audio_processing_mode() -> String {
"record_then_process".to_string()
‚ãÆ----
fn default_realtime_window_mode() -> String {
"standard".to_string()
‚ãÆ----
fn default_true() -> bool {
‚ãÆ----
impl Default for Preset {
fn default() -> Self {
‚ãÆ----
id: generate_preset_id(),
name: "New Preset".to_string(),
blocks: vec![ProcessingBlock::default()],
block_connections: vec![],
prompt_mode: "fixed".to_string(),
preset_type: "image".to_string(),
text_input_mode: "select".to_string(),
audio_source: "mic".to_string(),
audio_processing_mode: "record_then_process".to_string(),
realtime_window_mode: "standard".to_string(),
video_capture_method: "region".to_string(),
‚ãÆ----
hotkeys: vec![],
‚ãÆ----
fn generate_preset_id() -> String {
format!(
‚ãÆ----
pub struct PresetBuilder {
‚ãÆ----
impl PresetBuilder {
pub fn new(id: &str, name: &str) -> Self {
‚ãÆ----
id: id.to_string(),
name: name.to_string(),
blocks: vec![],
‚ãÆ----
pub fn image(mut self) -> Self {
self.preset.preset_type = "image".to_string();
‚ãÆ----
pub fn text_select(mut self) -> Self {
self.preset.preset_type = "text".to_string();
self.preset.text_input_mode = "select".to_string();
‚ãÆ----
pub fn text_type(mut self) -> Self {
‚ãÆ----
self.preset.text_input_mode = "type".to_string();
‚ãÆ----
pub fn audio_mic(mut self) -> Self {
self.preset.preset_type = "audio".to_string();
self.preset.audio_source = "mic".to_string();
‚ãÆ----
pub fn audio_device(mut self) -> Self {
‚ãÆ----
self.preset.audio_source = "device".to_string();
‚ãÆ----
pub fn blocks(mut self, blocks: Vec<ProcessingBlock>) -> Self {
‚ãÆ----
pub fn connections(mut self, connections: Vec<(usize, usize)>) -> Self {
‚ãÆ----
pub fn auto_paste(mut self) -> Self {
‚ãÆ----
pub fn auto_stop(mut self) -> Self {
‚ãÆ----
pub fn realtime(mut self) -> Self {
self.preset.audio_processing_mode = "realtime".to_string();
‚ãÆ----
pub fn minimal_mode(mut self) -> Self {
self.preset.realtime_window_mode = "minimal".to_string();
‚ãÆ----
pub fn continuous(mut self) -> Self {
‚ãÆ----
pub fn dynamic_prompt(mut self) -> Self {
self.preset.prompt_mode = "dynamic".to_string();
‚ãÆ----
pub fn master(mut self) -> Self {
‚ãÆ----
self.preset.blocks = vec![];
‚ãÆ----
pub fn build(self) -> Preset {
‚ãÆ----
impl Preset {
pub fn is_builtin(&self) -> bool {
self.id.starts_with("preset_")
‚ãÆ----
pub fn is_master_preset(&self) -> bool {
‚ãÆ----
pub fn input_block(&self) -> Option<&ProcessingBlock> {
self.blocks.first()
‚ãÆ----
pub fn input_block_mut(&mut self) -> Option<&mut ProcessingBlock> {
self.blocks.first_mut()
</file>

<file path="src/gui/app/utils.rs">
use crate::config::save_config;
use eframe::egui;
use std::sync::atomic::Ordering;
‚ãÆ----
use windows::Win32::Foundation::CloseHandle;
‚ãÆ----
pub fn simple_rand(seed: u32) -> u32 {
seed.wrapping_mul(1103515245).wrapping_add(12345)
‚ãÆ----
pub fn signal_restore_window() {
RESTORE_SIGNAL.store(true, Ordering::SeqCst);
‚ãÆ----
if let Ok(event) = OpenEventW(
‚ãÆ----
w!("Global\\ScreenGoatedToolboxRestoreEvent"),
‚ãÆ----
let _ = SetEvent(event);
let _ = CloseHandle(event);
‚ãÆ----
impl SettingsApp {
pub(crate) fn save_and_sync(&mut self) {
‚ãÆ----
let mut state = self.app_state_ref.lock().unwrap();
‚ãÆ----
state.config = self.config.clone();
drop(state);
save_config(&self.config);
‚ãÆ----
let class = w!("HotkeyListenerClass");
let title = w!("Listener");
‚ãÆ----
.unwrap_or_default();
if !hwnd.is_invalid() {
‚ãÆ----
Some(hwnd),
‚ãÆ----
pub(crate) fn restore_window(&self, ctx: &egui::Context) {
ctx.send_viewport_cmd(egui::ViewportCommand::Visible(true));
ctx.send_viewport_cmd(egui::ViewportCommand::Minimized(false));
ctx.send_viewport_cmd(egui::ViewportCommand::Focus);
ctx.send_viewport_cmd(egui::ViewportCommand::WindowLevel(
‚ãÆ----
ctx.request_repaint();
‚ãÆ----
pub(crate) fn check_hotkey_conflict(
‚ãÆ----
for (idx, preset) in self.config.presets.iter().enumerate() {
‚ãÆ----
return Some(format!(
</file>

<file path="src/gui/icons.rs">
use eframe::egui;
use std::f32::consts::PI;
‚ãÆ----
pub enum Icon {
‚ãÆ----
pub fn icon_button(ui: &mut egui::Ui, icon: Icon) -> egui::Response {
icon_button_sized(ui, icon, 24.0)
‚ãÆ----
pub fn icon_button_sized(ui: &mut egui::Ui, icon: Icon, size_val: f32) -> egui::Response {
‚ãÆ----
let (rect, response) = ui.allocate_exact_size(size, egui::Sense::click());
if response.hovered() {
ui.painter()
.rect_filled(rect.shrink(2.0), 4.0, ui.visuals().widgets.hovered.bg_fill);
‚ãÆ----
let color = if response.hovered() {
ui.visuals().widgets.hovered.fg_stroke.color
‚ãÆ----
ui.visuals().widgets.inactive.fg_stroke.color
‚ãÆ----
paint_internal(ui.painter(), rect, icon, color);
‚ãÆ----
pub fn draw_icon_static(ui: &mut egui::Ui, icon: Icon, size_override: Option<f32>) {
let side = size_override.unwrap_or(16.0);
let (rect, _) = ui.allocate_exact_size(egui::vec2(side, side), egui::Sense::hover());
let color = ui.visuals().text_color();
‚ãÆ----
pub fn paint_icon(painter: &egui::Painter, rect: egui::Rect, icon: Icon, color: egui::Color32) {
paint_internal(painter, rect, icon, color);
‚ãÆ----
fn paint_internal(painter: &egui::Painter, rect: egui::Rect, icon: Icon, color: egui::Color32) {
let center = rect.center();
let scale = rect.width().min(rect.height()) / 22.0;
‚ãÆ----
points.push(center + egui::vec2(theta_a.cos() * r, theta_a.sin() * r));
points.push(center + egui::vec2(theta_b.cos() * r, theta_b.sin() * r));
‚ãÆ----
points.push(points[0]);
painter.add(egui::Shape::line(points, stroke));
painter.circle_stroke(center, hole_r, stroke);
‚ãÆ----
let pts_top = bezier_points(p_left, p_top, p_right, 10);
let pts_bot = bezier_points(p_right, p_bot, p_left, 10);
‚ãÆ----
full_eye.extend(pts_bot);
painter.add(egui::Shape::line(full_eye, stroke));
painter.circle_filled(center, 2.5 * scale, color);
‚ãÆ----
let pts = bezier_points(p_left, p_top, p_right, 12);
painter.add(egui::Shape::line(pts, stroke));
‚ãÆ----
painter.line_segment(
‚ãÆ----
painter.rect_stroke(caps_rect, w / 2.0, stroke, egui::StrokeKind::Middle);
let y_start = caps_rect.top() + 3.5 * scale;
‚ãÆ----
let u_path = bezier_points(u_left, u_bot, u_right, 10);
painter.add(egui::Shape::line(u_path, stroke));
‚ãÆ----
let img_rect = rect.shrink(3.0 * scale);
painter.rect_stroke(img_rect, 2.0 * scale, stroke, egui::StrokeKind::Middle);
let p1 = img_rect.left_bottom() - egui::vec2(-1.0, 2.0) * scale;
let p2 = img_rect.left_bottom() + egui::vec2(3.0, -6.0) * scale;
let p3 = img_rect.left_bottom() + egui::vec2(6.0, -3.0) * scale;
let p4 = img_rect.left_bottom() + egui::vec2(9.0, -7.0) * scale;
let p5 = img_rect.right_bottom() - egui::vec2(1.0, 2.0) * scale;
painter.add(egui::Shape::line(vec![p1, p2, p3, p4, p5], stroke));
painter.circle_filled(
img_rect.left_top() + egui::vec2(3.5, 3.5) * scale,
‚ãÆ----
painter.add(egui::Shape::line(vec![p1, p2, p3, p4], stroke));
‚ãÆ----
let p1 = body_rect.left_top();
let p2 = body_rect.left_bottom();
let p3 = body_rect.right_bottom();
let p4 = body_rect.right_top();
let p5 = body_rect.left_top() + egui::vec2(tab_w, 0.0);
let p6 = body_rect.left_top() + egui::vec2(tab_w, -tab_h);
let p7 = body_rect.left_top() + egui::vec2(0.0, -tab_h);
painter.add(egui::Shape::line(
vec![p7, p1, p2, p3, p4, p5, p6, p7],
‚ãÆ----
painter.rect_stroke(back_rect, 1.0 * scale, stroke, egui::StrokeKind::Middle);
‚ãÆ----
painter.rect_filled(
‚ãÆ----
painter.ctx().style().visuals.panel_fill,
‚ãÆ----
painter.rect_stroke(front_rect, 1.0 * scale, stroke, egui::StrokeKind::Middle);
‚ãÆ----
painter.rect_stroke(back_rect, 0.8 * scale, stroke, egui::StrokeKind::Middle);
‚ãÆ----
painter.rect_stroke(front_rect, 0.8 * scale, stroke, egui::StrokeKind::Middle);
‚ãÆ----
painter.line_segment([p1, p2], stroke);
painter.line_segment([p3, p4], stroke);
‚ãÆ----
painter.rect_stroke(rect, 0.5 * scale, stroke, egui::StrokeKind::Middle);
let cone_pts = vec![
‚ãÆ----
painter.add(egui::Shape::closed_line(cone_pts, stroke));
‚ãÆ----
wave1_pts.push(egui::pos2(
wave_x + wave_r1 * angle.cos(),
center.y + wave_r1 * angle.sin(),
‚ãÆ----
painter.add(egui::Shape::line(wave1_pts, stroke));
‚ãÆ----
wave2_pts.push(egui::pos2(
wave_x + wave_r2 * angle.cos(),
center.y + wave_r2 * angle.sin(),
‚ãÆ----
painter.add(egui::Shape::line(wave2_pts, stroke));
‚ãÆ----
painter.circle_stroke(egui::pos2(center.x, bulb_cy), bulb_r, stroke);
‚ãÆ----
let wave_pts = vec![
‚ãÆ----
painter.add(egui::Shape::line(wave_pts, wave_stroke));
‚ãÆ----
points.push(egui::pos2(
center.x + r * angle.cos(),
center.y + r * angle.sin(),
‚ãÆ----
raw_points.push(egui::pos2(
‚ãÆ----
let p_start = lerp(p, p_prev, round_ratio);
let p_end = lerp(p, p_next, round_ratio);
let curve = bezier_points(p_start, p, p_end, 5);
path_points.extend(curve);
‚ãÆ----
path_points.push(p);
‚ãÆ----
painter.add(egui::Shape::Path(egui::epaint::PathShape {
‚ãÆ----
stroke: egui::Stroke::new(1.0 * scale, gold).into(),
‚ãÆ----
painter.circle_stroke(center, 4.0 * scale, stroke);
‚ãÆ----
let angle = (i as f32 * 45.0).to_radians();
let dir = egui::vec2(angle.cos(), angle.sin());
‚ãÆ----
painter.line_segment([start, end], stroke);
‚ãÆ----
painter.circle_filled(center, r, color);
‚ãÆ----
painter.rect_stroke(screen_rect, 1.0 * scale, stroke, egui::StrokeKind::Middle);
‚ãÆ----
painter.circle_filled(egui::pos2(cx, cy), r, color);
‚ãÆ----
painter.circle_stroke(center, r, stroke);
painter.line_segment([center, center + egui::vec2(4.0 * scale, 0.0)], stroke);
painter.line_segment([center, center + egui::vec2(0.0, -5.0 * scale)], stroke);
‚ãÆ----
fn lerp(a: egui::Pos2, b: egui::Pos2, t: f32) -> egui::Pos2 {
‚ãÆ----
fn lerp_quadratic(p0: egui::Pos2, p1: egui::Pos2, p2: egui::Pos2, t: f32) -> egui::Pos2 {
let l1 = lerp(p0, p1, t);
let l2 = lerp(p1, p2, t);
lerp(l1, l2, t)
‚ãÆ----
fn bezier_points(
‚ãÆ----
points.push(lerp_quadratic(p0, p1, p2, t));
</file>

<file path="src/gui/settings_ui/global/update_section.rs">
use crate::gui::locale::LocaleText;
‚ãÆ----
use eframe::egui;
‚ãÆ----
pub fn render_update_section_content(
‚ãÆ----
ui.horizontal(|ui| {
let mut ver_string = format!(
‚ãÆ----
if cfg!(feature = "nopack") || cfg!(nopack) {
ver_string.push_str(" (NoPack)");
‚ãÆ----
ui.label(ver_string);
if ui.button(text.check_for_updates_btn).clicked() {
‚ãÆ----
u.check_for_updates();
‚ãÆ----
ui.spinner();
ui.label(text.checking_github);
‚ãÆ----
ui.label(
egui::RichText::new(format!("{} (v{})", text.up_to_date, ver))
.color(egui::Color32::from_rgb(34, 139, 34)),
‚ãÆ----
if ui.button(text.check_again_btn).clicked() {
‚ãÆ----
ui.colored_label(
‚ãÆ----
format!("{} {}", text.new_version_available, version),
‚ãÆ----
ui.collapsing(text.release_notes_label, |ui| {
ui.label(body);
‚ãÆ----
ui.add_space(5.0);
‚ãÆ----
.button(egui::RichText::new(text.download_update_btn).strong())
.clicked()
‚ãÆ----
u.perform_update();
‚ãÆ----
ui.label(text.downloading_update);
‚ãÆ----
ui.colored_label(egui::Color32::RED, format!("{} {}", text.update_failed, e));
ui.label(egui::RichText::new(text.app_folder_writable_hint).size(11.0));
if ui.button(text.retry_btn).clicked() {
‚ãÆ----
.color(egui::Color32::GREEN)
.heading(),
‚ãÆ----
ui.label(text.restart_to_use_new_version);
if ui.button(text.restart_app_btn).clicked() {
‚ãÆ----
if let Some(exe_dir) = exe_path.parent() {
‚ãÆ----
.filter_map(|e| e.ok())
.filter(|e| {
let name = e.file_name();
let name_str = name.to_string_lossy();
name_str.starts_with("ScreenGoatedToolbox_v")
&& name_str.ends_with(".exe")
‚ãÆ----
.max_by_key(|e| e.metadata().ok().and_then(|m| m.modified().ok()))
‚ãÆ----
let path = newest_exe.path();
println!("Attempting to spawn with delay: {:?}", path);
let kill_mutex_cmd = format!("timeout /t 2 /nobreak > NUL");
‚ãÆ----
format!("start \"\" \"{}\"", path.to_string_lossy());
‚ãÆ----
let batch_content = format!(
‚ãÆ----
.join(format!("sgt_restart_{}.bat", std::process::id()));
println!("Writing batch file to: {:?}", bat_path);
‚ãÆ----
.args(["/C", &bat_path.to_string_lossy()])
.spawn();
‚ãÆ----
eprintln!("Failed to spawn batch file: {}", e);
‚ãÆ----
eprintln!("Failed to write batch file");
</file>

<file path="src/gui/settings_ui/history.rs">
use crate::config::Config;
‚ãÆ----
use crate::gui::locale::LocaleText;
‚ãÆ----
use eframe::egui;
pub fn render_history_panel(
‚ãÆ----
let is_dark = ui.visuals().dark_mode;
‚ãÆ----
ui.set_max_width(510.0);
ui.add_space(5.0);
‚ãÆ----
.fill(card_bg)
.stroke(card_stroke)
.inner_margin(12.0)
.corner_radius(10.0)
.show(ui, |ui| {
ui.horizontal(|ui| {
ui.label(
egui::RichText::new(format!("üìú {}", text.history_title))
.strong()
.size(14.0),
‚ãÆ----
ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
‚ãÆ----
.add(egui::Slider::new(&mut config.max_history_items, 10..=200))
.changed()
‚ãÆ----
history_manager.request_prune(config.max_history_items);
‚ãÆ----
ui.label(text.max_items_label);
‚ãÆ----
ui.add_space(8.0);
‚ãÆ----
ui.scope(|ui| {
‚ãÆ----
let visuals = ui.visuals_mut();
‚ãÆ----
ui.add(
‚ãÆ----
.hint_text(text.search_placeholder)
.desired_width(220.0),
‚ãÆ----
if !search_query.is_empty() {
if icon_button(ui, Icon::Close)
.on_hover_text("Clear search")
.clicked()
‚ãÆ----
*search_query = "".to_string();
‚ãÆ----
if icon_button(ui, Icon::Folder)
.on_hover_text("Open Media Folder")
‚ãÆ----
.unwrap_or_default()
.join("screen-goated-toolbox")
.join("history_media");
‚ãÆ----
.add(
‚ãÆ----
.color(egui::Color32::WHITE)
.small(),
‚ãÆ----
.fill(clear_bg)
.corner_radius(8.0),
‚ãÆ----
history_manager.clear_all();
‚ãÆ----
let items = history_manager.items.lock().unwrap().clone();
let q = search_query.to_lowercase();
‚ãÆ----
.iter()
.filter(|i| q.is_empty() || i.text.to_lowercase().contains(&q) || i.timestamp.contains(&q))
.collect();
if filtered.is_empty() {
ui.centered_and_justified(|ui| {
ui.label(text.history_empty);
‚ãÆ----
egui::Frame::new().show(ui, |ui| {
ui.set_height(460.0);
egui::ScrollArea::vertical().show(ui, |ui| {
‚ãÆ----
.fill(item_bg)
‚ãÆ----
.inner_margin(8.0)
.corner_radius(8.0)
‚ãÆ----
draw_icon_static(ui, icon, Some(14.0));
ui.label(egui::RichText::new(&item.timestamp).size(10.0).weak());
ui.with_layout(
‚ãÆ----
if icon_button(ui, Icon::DeleteLarge)
.on_hover_text("Delete")
‚ãÆ----
id_to_delete = Some(item.id);
‚ãÆ----
if icon_button(ui, Icon::Copy)
.on_hover_text("Copy Text")
‚ãÆ----
if !item.media_path.is_empty() {
‚ãÆ----
if ui.button(btn_text).clicked() {
‚ãÆ----
.unwrap()
‚ãÆ----
let path = config_dir.join(&item.media_path);
‚ãÆ----
ui.label(egui::RichText::new(&item.text).size(13.0));
‚ãÆ----
ui.add_space(4.0);
‚ãÆ----
history_manager.delete(id);
</file>

<file path="src/gui/utils.rs">
use eframe::egui;
use std::process::Command;
use windows::core::w;
‚ãÆ----
use windows_core::BOOL;
struct MonitorEnumContext {
‚ãÆ----
unsafe extern "system" fn monitor_enum_proc(
‚ãÆ----
if GetMonitorInfoW(hmonitor, &mut mi as *mut _ as *mut _).as_bool() {
‚ãÆ----
let trimmed_name = device_name.trim_matches(char::from(0)).to_string();
context.monitors.push(trimmed_name);
‚ãÆ----
pub fn get_monitor_names() -> Vec<String> {
‚ãÆ----
let _ = EnumDisplayMonitors(
‚ãÆ----
Some(monitor_enum_proc),
LPARAM(&mut ctx as *mut _ as isize),
‚ãÆ----
pub fn copy_to_clipboard_text(text: &str) {
‚ãÆ----
pub fn is_running_as_admin() -> bool {
‚ãÆ----
if OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &mut h_token).is_ok() {
‚ãÆ----
if GetTokenInformation(
‚ãÆ----
Some(&mut elevation as *mut _ as *mut std::ffi::c_void),
‚ãÆ----
.is_ok()
‚ãÆ----
pub fn is_system_in_dark_mode() -> bool {
‚ãÆ----
use winreg::RegKey;
‚ãÆ----
hkcu.open_subkey("Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize")
‚ãÆ----
pub fn configure_fonts(ctx: &egui::Context) {
‚ãÆ----
let gs_data = include_bytes!(
‚ãÆ----
fonts.font_data.insert(
gs_font_name.to_owned(),
‚ãÆ----
let windir = std::env::var("WINDIR").unwrap_or_else(|_| "C:\\Windows".to_string());
let font_dir = std::path::Path::new(&windir).join("Fonts");
let viet_font_path = font_dir.join("segoeui.ttf");
let viet_fallback_path = font_dir.join("arial.ttf");
let viet_data = std::fs::read(&viet_font_path).or_else(|_| std::fs::read(&viet_fallback_path));
‚ãÆ----
let korean_font_path = font_dir.join("malgun.ttf");
‚ãÆ----
viet_font_name.to_owned(),
‚ãÆ----
if let Some(vec) = fonts.families.get_mut(&egui::FontFamily::Proportional) {
vec.insert(0, viet_font_name.to_owned());
‚ãÆ----
if let Some(vec) = fonts.families.get_mut(&egui::FontFamily::Monospace) {
‚ãÆ----
korean_font_name.to_owned(),
‚ãÆ----
let idx = if vec.contains(&viet_font_name.to_string()) {
‚ãÆ----
vec.insert(idx, korean_font_name.to_owned());
‚ãÆ----
vec.insert(0, gs_font_name.to_owned());
‚ãÆ----
ctx.set_fonts(fonts);
‚ãÆ----
pub fn set_admin_startup(enable: bool) -> bool {
‚ãÆ----
let exe_str = match exe_path.to_str() {
‚ãÆ----
if exe_str.is_empty() {
‚ãÆ----
.args(&[
‚ãÆ----
&format!("\"{}\"", exe_str),
‚ãÆ----
.output();
‚ãÆ----
Ok(o) => o.status.success(),
‚ãÆ----
.args(&["/delete", "/tn", TASK_NAME, "/f"])
‚ãÆ----
pub fn is_admin_startup_enabled() -> bool {
‚ãÆ----
.args(&["/query", "/tn", TASK_NAME])
‚ãÆ----
fn rgba_to_bgra(data: &[u8]) -> Vec<u8> {
let mut bgra = data.to_vec();
for chunk in bgra.chunks_exact_mut(4) {
chunk.swap(0, 2);
‚ãÆ----
unsafe fn create_hicon_from_bytes(bytes: &[u8], target_w: i32, target_h: i32) -> Option<HANDLE> {
let img = image::load_from_memory(bytes).ok()?;
let resized = img.resize_exact(
‚ãÆ----
let rgba = resized.to_rgba8();
let bgra_data = rgba_to_bgra(rgba.as_raw());
‚ãÆ----
let mask_bits = vec![0u8; mask_len];
let hicon_result = CreateIcon(
‚ãÆ----
mask_bits.as_ptr(),
bgra_data.as_ptr(),
‚ãÆ----
if hicon.is_invalid() {
‚ãÆ----
Some(std::mem::transmute::<_, HANDLE>(hicon))
‚ãÆ----
pub fn set_window_icon(hwnd: HWND, is_dark_mode: bool) {
‚ãÆ----
include_bytes!("../../assets/app-icon-small.png")
‚ãÆ----
include_bytes!("../../assets/app-icon-small-light.png")
‚ãÆ----
if !hwnd.is_invalid() {
let small_w = GetSystemMetrics(SM_CXSMICON);
let small_h = GetSystemMetrics(SM_CYSMICON);
let big_w = GetSystemMetrics(SM_CXICON);
let big_h = GetSystemMetrics(SM_CYICON);
if let Some(hicon_small) = create_hicon_from_bytes(icon_bytes, small_w, small_h) {
let _ = SendMessageW(
‚ãÆ----
Some(WPARAM(ICON_SMALL as usize)),
Some(LPARAM(hicon_small.0 as isize)),
‚ãÆ----
if let Some(hicon_big) = create_hicon_from_bytes(icon_bytes, big_w, big_h) {
‚ãÆ----
Some(WPARAM(ICON_BIG as usize)),
Some(LPARAM(hicon_big.0 as isize)),
‚ãÆ----
pub fn update_window_icon_native(is_dark_mode: bool) {
‚ãÆ----
let class_name = w!("eframe");
let title_name = w!("Screen Goated Toolbox (SGT by nganlinh4)");
let mut hwnd = FindWindowW(class_name, title_name).unwrap_or_default();
if hwnd.is_invalid() {
hwnd = FindWindowW(None, title_name).unwrap_or_default();
‚ãÆ----
set_window_icon(hwnd, is_dark_mode);
</file>

<file path="src/overlay/html_components/css_main.rs">
pub fn get(glow_color: &str, font_size: u32) -> String {
format!(
</file>

<file path="src/overlay/html_components/icons.rs">
pub fn get_icon_svg(name: &str) -> &'static str {
</file>

<file path="src/overlay/html_components/mod.rs">
pub mod css_main;
pub mod css_modals;
pub mod font_manager;
pub mod grid_js;
pub mod icons;
pub mod js_logic;
pub mod js_main;
</file>

<file path="src/overlay/preset_wheel/mod.rs">
mod html;
mod window;
</file>

<file path="src/overlay/realtime_egui.rs">
use crate::APP;
use eframe::egui;
‚ãÆ----
use std::sync::Mutex;
‚ãÆ----
struct RealtimeUiState {
‚ãÆ----
impl Default for RealtimeUiState {
fn default() -> Self {
‚ãÆ----
pub fn show_realtime_egui_overlay(preset_idx: usize) {
if MINIMAL_ACTIVE.load(Ordering::SeqCst) || unsafe { IS_ACTIVE } {
‚ãÆ----
REALTIME_STOP_SIGNAL.store(false, Ordering::SeqCst);
MIC_VISIBLE.store(true, Ordering::SeqCst);
TRANS_VISIBLE.store(true, Ordering::SeqCst);
AUDIO_SOURCE_CHANGE.store(false, Ordering::SeqCst);
LANGUAGE_CHANGE.store(false, Ordering::SeqCst);
TRANSLATION_MODEL_CHANGE.store(false, Ordering::SeqCst);
‚ãÆ----
let mut state = REALTIME_STATE.lock().unwrap();
‚ãÆ----
LAST_SPOKEN_LENGTH.store(0, Ordering::SeqCst);
REALTIME_TTS_ENABLED.store(false, Ordering::SeqCst);
SELECTED_APP_PID.store(0, Ordering::SeqCst);
if let Ok(mut name) = SELECTED_APP_NAME.lock() { name.clear(); }
if let Ok(mut queue) = COMMITTED_TRANSLATION_QUEUE.lock() { queue.clear(); }
USER_REQUESTED_CLOSE.store(false, Ordering::SeqCst);
MINIMAL_ACTIVE.store(true, Ordering::SeqCst);
MINIMAL_PRESET_IDX.store(preset_idx, Ordering::SeqCst);
let app = APP.lock().unwrap();
let preset = app.config.presets[preset_idx].clone();
‚ãÆ----
let config_language = app.config.realtime_target_language.clone();
let config_audio_source = app.config.realtime_audio_source.clone();
drop(app);
‚ãÆ----
if let Ok(mut ui_state) = UI_STATE.lock() {
‚ãÆ----
ui_state.apps_list.clear();
‚ãÆ----
ui_state.committed_segments.clear();
‚ãÆ----
let effective_source = if config_audio_source.is_empty() { "mic".to_string() } else { config_audio_source };
if let Ok(mut new_source) = NEW_AUDIO_SOURCE.lock() {
*new_source = effective_source.clone();
‚ãÆ----
if !config_language.is_empty() {
if let Ok(mut new_lang) = NEW_TARGET_LANGUAGE.lock() {
*new_lang = config_language.clone();
‚ãÆ----
LANGUAGE_CHANGE.store(true, Ordering::SeqCst);
‚ãÆ----
let mut final_preset = preset.clone();
‚ãÆ----
start_realtime_transcription(
‚ãÆ----
REALTIME_STOP_SIGNAL.clone(),
‚ãÆ----
Some(windows::Win32::Foundation::HWND::default()),
REALTIME_STATE.clone(),
‚ãÆ----
if let Ok(guard) = crate::gui::GUI_CONTEXT.lock() {
if let Some(ctx) = guard.as_ref() {
ctx.request_repaint();
‚ãÆ----
pub fn render_minimal_overlay(ctx: &egui::Context) {
if !MINIMAL_ACTIVE.load(Ordering::SeqCst) {
‚ãÆ----
if USER_REQUESTED_CLOSE.load(Ordering::SeqCst) {
MINIMAL_ACTIVE.store(false, Ordering::SeqCst);
‚ãÆ----
REALTIME_STOP_SIGNAL.store(true, Ordering::SeqCst);
crate::api::tts::TTS_MANAGER.stop();
‚ãÆ----
let mut ui_state = UI_STATE.lock().unwrap();
let ui_language = APP.lock().map(|a| a.config.ui_language.clone()).unwrap_or_else(|_| "en".to_string());
‚ãÆ----
ctx.show_viewport_immediate(
‚ãÆ----
.with_inner_size([700.0, 200.0])
.with_title(title)
.with_always_on_top(),
‚ãÆ----
if ctx.input(|i| i.viewport().close_requested()) {
USER_REQUESTED_CLOSE.store(true, Ordering::SeqCst);
‚ãÆ----
egui::CentralPanel::default().show(ctx, |ui| {
render_main_ui(ui, &mut ui_state);
‚ãÆ----
fn render_main_ui(ui: &mut egui::Ui, state: &mut RealtimeUiState) {
let current_source = NEW_AUDIO_SOURCE.lock().map(|s| s.clone()).unwrap_or_else(|_| "mic".to_string());
‚ãÆ----
let app_pid = SELECTED_APP_PID.load(Ordering::SeqCst);
let tts_enabled = REALTIME_TTS_ENABLED.load(Ordering::SeqCst);
‚ãÆ----
ui.horizontal(|ui| {
‚ãÆ----
ui.label(egui::RichText::new(locale.device_mode_warning)
.color(egui::Color32::from_rgb(255, 180, 100)).size(11.0));
if ui.small_button(locale.select_app_btn).clicked() {
‚ãÆ----
if state.apps_list.is_empty() {
‚ãÆ----
ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
if ui.selectable_label(state.show_translation, "üåê").on_hover_text(locale.toggle_translation_tooltip).clicked() {
‚ãÆ----
TRANS_VISIBLE.store(state.show_translation, Ordering::SeqCst);
‚ãÆ----
if ui.selectable_label(state.show_transcription, "üìù").on_hover_text(locale.toggle_transcription_tooltip).clicked() {
‚ãÆ----
MIC_VISIBLE.store(state.show_transcription, Ordering::SeqCst);
‚ãÆ----
ui.separator();
if ui.small_button("‚ûñ").on_hover_text(locale.font_minus_tooltip).clicked() {
state.font_size = (state.font_size - 2.0).max(10.0);
if let Ok(mut app) = APP.lock() {
‚ãÆ----
if ui.small_button("‚ûï").on_hover_text(locale.font_plus_tooltip).clicked() {
state.font_size = (state.font_size + 2.0).min(40.0);
‚ãÆ----
if ui.small_button(tts_label).on_hover_text(locale.tts_settings_title).clicked() {
‚ãÆ----
let current_model = APP.lock().map(|a| a.config.realtime_translation_model.clone()).unwrap_or_default();
let model_label = match current_model.as_str() {
‚ãÆ----
ui.menu_button(model_label, |ui| {
if ui.selectable_label(current_model == "groq-llama", "‚ö° Groq").clicked() {
if let Ok(mut m) = NEW_TRANSLATION_MODEL.lock() { *m = "groq-llama".to_string(); }
TRANSLATION_MODEL_CHANGE.store(true, Ordering::SeqCst);
if let Ok(mut app) = APP.lock() { app.config.realtime_translation_model = "groq-llama".to_string(); }
ui.close();
‚ãÆ----
if ui.selectable_label(current_model == "google-gemma", "‚ú® Gemma").clicked() {
if let Ok(mut m) = NEW_TRANSLATION_MODEL.lock() { *m = "google-gemma".to_string(); }
‚ãÆ----
if let Ok(mut app) = APP.lock() { app.config.realtime_translation_model = "google-gemma".to_string(); }
‚ãÆ----
if ui.selectable_label(current_model == "google-gtx", format!("üåç {}", locale.google_gtx_label)).clicked() {
if let Ok(mut m) = NEW_TRANSLATION_MODEL.lock() { *m = "google-gtx".to_string(); }
‚ãÆ----
if let Ok(mut app) = APP.lock() { app.config.realtime_translation_model = "google-gtx".to_string(); }
‚ãÆ----
let current_lang = NEW_TARGET_LANGUAGE.lock().map(|l| if l.is_empty() { "English".to_string() } else { l.clone() }).unwrap_or_else(|_| "English".to_string());
‚ãÆ----
.and_then(|l| l.to_639_1())
.map(|c| c.to_uppercase())
.unwrap_or_else(|| current_lang.chars().take(2).collect::<String>().to_uppercase());
let btn_resp = ui.button(&lang_code);
if btn_resp.clicked() {
egui::Popup::toggle_id(ui.ctx(), btn_resp.id);
‚ãÆ----
.close_behavior(egui::PopupCloseBehavior::CloseOnClickOutside)
.show(|ui| {
ui.set_min_width(120.0);
‚ãÆ----
let mut search_text: String = ui.data_mut(|d| d.get_temp(search_id).unwrap_or_default());
let response = ui.add(egui::TextEdit::singleline(&mut search_text).hint_text("Search...").desired_width(120.0));
if response.changed() {
ui.data_mut(|d| d.insert_temp(search_id, search_text.clone()));
‚ãÆ----
if response.clicked() {
response.request_focus();
‚ãÆ----
egui::ScrollArea::vertical().max_height(250.0).show(ui, |ui| {
‚ãÆ----
let matches = search_text.is_empty() || lang.to_lowercase().contains(&search_text.to_lowercase());
‚ãÆ----
if ui.selectable_label(current_lang == *lang, lang).clicked() {
if let Ok(mut l) = NEW_TARGET_LANGUAGE.lock() { *l = lang.to_string(); }
‚ãÆ----
if let Ok(mut app) = APP.lock() { app.config.realtime_target_language = lang.to_string(); }
ui.data_mut(|d| d.remove_temp::<String>(search_id));
egui::Popup::toggle_id(ui.ctx(), popup_id);
‚ãÆ----
if ui.selectable_label(!is_device_mode, "üé§").on_hover_text(locale.audio_src_mic).clicked() {
if let Ok(mut s) = NEW_AUDIO_SOURCE.lock() { *s = "mic".to_string(); }
‚ãÆ----
AUDIO_SOURCE_CHANGE.store(true, Ordering::SeqCst);
if let Ok(mut app) = APP.lock() { app.config.realtime_audio_source = "mic".to_string(); }
‚ãÆ----
if ui.selectable_label(is_device_mode, "üîä").on_hover_text(locale.audio_src_device).clicked() {
‚ãÆ----
ui.add_enabled_ui(can_enable_tts, |ui| {
if ui.checkbox(&mut tts_on, "TTS").changed() {
‚ãÆ----
REALTIME_TTS_ENABLED.store(true, Ordering::SeqCst);
‚ãÆ----
let current_speed = CURRENT_TTS_SPEED.load(Ordering::Relaxed);
let base_speed = REALTIME_TTS_SPEED.load(Ordering::Relaxed);
let auto_speed = REALTIME_TTS_AUTO_SPEED.load(Ordering::Relaxed);
ui.label(format!("{:.1}x", current_speed as f32 / 100.0));
‚ãÆ----
if ui.add(egui::Slider::new(&mut speed_val, 50..=200).show_value(false)).changed() {
REALTIME_TTS_SPEED.store(speed_val as u32, Ordering::SeqCst);
REALTIME_TTS_AUTO_SPEED.store(false, Ordering::SeqCst);
‚ãÆ----
if ui.checkbox(&mut auto_on, locale.realtime_tts_auto).changed() {
REALTIME_TTS_AUTO_SPEED.store(auto_on, Ordering::SeqCst);
‚ãÆ----
ui.label(egui::RichText::new(locale.app_select_title).strong().size(11.0));
if ui.small_button("üîÑ").clicked() {
‚ãÆ----
if ui.small_button("‚úñ").clicked() {
‚ãÆ----
let selected_name = SELECTED_APP_NAME.lock().map(|n| n.clone()).unwrap_or_default();
if !selected_name.is_empty() {
ui.label(egui::RichText::new(format!("‚úì {}", selected_name)).color(egui::Color32::GREEN).size(10.0));
‚ãÆ----
egui::ScrollArea::vertical().max_height(80.0).id_salt("app_list").show(ui, |ui| {
for (pid, name) in state.apps_list.clone() {
‚ãÆ----
let display = if name.chars().count() > 40 {
format!("{}...", name.chars().take(37).collect::<String>())
‚ãÆ----
name.clone()
‚ãÆ----
if ui.selectable_label(is_selected, &display).clicked() {
SELECTED_APP_PID.store(pid, Ordering::SeqCst);
if let Ok(mut app_name) = SELECTED_APP_NAME.lock() {
*app_name = name.clone();
‚ãÆ----
*new_source = "device".to_string();
‚ãÆ----
let state_data = REALTIME_STATE.lock().unwrap();
‚ãÆ----
if state.show_translation && TRANS_VISIBLE.load(Ordering::SeqCst) {
‚ãÆ----
let old_len = committed.len();
let is_mic_mode = current_source.is_empty() || current_source == "mic";
‚ãÆ----
let current_tts_enabled = REALTIME_TTS_ENABLED.load(Ordering::SeqCst);
if current_tts_enabled && tts_allowed && !committed.is_empty() {
‚ãÆ----
let text = committed.trim_end();
let search_limit = text.len().saturating_sub(1);
‚ãÆ----
if let Some(idx) = text[..search_limit].rfind(|c| c == '.' || c == '?' || c == '!' || c == '\n') {
‚ãÆ----
let new_committed = committed[state.last_spoken_len..].to_string();
if !new_committed.trim().is_empty() {
if let Ok(mut queue) = COMMITTED_TRANSLATION_QUEUE.lock() {
queue.push_back(new_committed.clone());
‚ãÆ----
crate::api::tts::TTS_MANAGER.speak_realtime(&text_to_speak, 0);
‚ãÆ----
state_data.full_transcript.clone(),
‚ãÆ----
state_data.committed_translation.clone(),
state_data.uncommitted_translation.clone(),
‚ãÆ----
drop(state_data);
let available_height = ui.available_height();
let rect = ui.ctx().input(|i| i.viewport().inner_rect);
let current_window_size = rect.map(|r| r.size()).unwrap_or(egui::Vec2::ZERO);
let current_len = committed_translation.len();
‚ãÆ----
state.committed_segments.clear();
‚ãÆ----
let new_segment = committed_translation[state.last_committed_len..].to_string();
state.committed_segments.push(new_segment);
‚ãÆ----
let window_resized = (current_window_size - state.prev_window_size).length() > 1.0;
‚ãÆ----
let has_content = !committed_translation.is_empty() || !uncommitted_translation.is_empty();
‚ãÆ----
let available_width = ui.available_width();
‚ãÆ----
let content_height = available_height.max(50.0);
‚ãÆ----
ui.vertical(|ui| {
ui.set_width(col_width);
ui.set_min_height(content_height);
‚ãÆ----
.id_salt("trans_scroll")
.auto_shrink([false, false])
.stick_to_bottom(true)
.show(ui, |ui| {
render_transcript(ui, &full_transcript, last_committed_pos, &font);
‚ãÆ----
.id_salt("transl_scroll")
‚ãÆ----
render_translation(ui, &state.committed_segments, &uncommitted_translation, &font);
‚ãÆ----
ui.scroll_to_cursor(Some(egui::Align::BOTTOM));
‚ãÆ----
.id_salt("trans_full")
‚ãÆ----
.id_salt("transl_full")
‚ãÆ----
fn render_transcript(ui: &mut egui::Ui, full: &str, split_pos: usize, font: &egui::FontId) {
let split_idx = split_pos.min(full.len());
let split_idx = if full.is_char_boundary(split_idx) { split_idx } else {
full.char_indices().take_while(|(i, _)| *i < split_idx).last().map(|(i, c)| i + c.len_utf8()).unwrap_or(0)
‚ãÆ----
let committed = full[..split_idx].trim_end();
let uncommitted = full[split_idx..].trim_start();
let dark_mode = ui.visuals().dark_mode;
ui.horizontal_wrapped(|ui| {
ui.spacing_mut().item_spacing.x = 0.0;
if !committed.is_empty() {
ui.label(egui::RichText::new(committed).font(font.clone()).color(get_text_color(true, dark_mode)));
‚ãÆ----
if !uncommitted.is_empty() {
if !committed.is_empty() { ui.label(" "); }
‚ãÆ----
ui.label(egui::RichText::new(uncommitted).font(font.clone()).color(color).italics());
‚ãÆ----
fn render_translation(ui: &mut egui::Ui, segments: &[String], uncommitted: &str, font: &egui::FontId) {
let uncommitted = uncommitted.trim_start();
‚ãÆ----
for (i, segment) in segments.iter().enumerate() {
let color = get_segment_color(i, dark_mode);
ui.label(egui::RichText::new(segment).font(font.clone()).color(color));
‚ãÆ----
fn tr(key: &str, lang: &str) -> String {
‚ãÆ----
"device_mode_warning" => "‚ö† ƒê√£ ch·ªçn √¢m thanh thi·∫øt b·ªã nh∆∞ng ch∆∞a ch·ªçn ·ª©ng d·ª•ng".to_string(),
"select_app" => "Ch·ªçn ·ª©ng d·ª•ng".to_string(),
"toggle_translation" => "T·∫Øt/M·ªü d·ªãch".to_string(),
"toggle_transcription" => "T·∫Øt/M·ªü ph·ª• ƒë·ªÅ".to_string(),
"font_minus" => "Gi·∫£m c·ª° ch·ªØ".to_string(),
"font_plus" => "TƒÉng c·ª° ch·ªØ".to_string(),
"tts_settings" => "C√†i ƒë·∫∑t ƒë·ªçc vƒÉn b·∫£n (TTS)".to_string(),
"microphone" => "Microphone".to_string(),
"system_audio" => "√Çm thanh h·ªá th·ªëng".to_string(),
"select_app_title" => "üéß Ch·ªçn ·ª©ng d·ª•ng ƒë·ªÉ thu √¢m".to_string(),
"auto" => "T·ª± ƒë·ªông".to_string(),
_ => key.to_string(),
‚ãÆ----
"device_mode_warning" => "‚ö† Device audio selected but no app chosen".to_string(),
"select_app" => "Select App".to_string(),
"toggle_translation" => "Toggle Translation".to_string(),
"toggle_transcription" => "Toggle Transcription".to_string(),
"font_minus" => "Font -".to_string(),
"font_plus" => "Font +".to_string(),
"tts_settings" => "TTS Settings".to_string(),
‚ãÆ----
"system_audio" => "System Audio".to_string(),
"select_app_title" => "üéß Select App to Record".to_string(),
"auto" => "Auto".to_string(),
‚ãÆ----
fn get_segment_color(index: usize, dark_mode: bool) -> egui::Color32 {
‚ãÆ----
fn get_text_color(is_committed: bool, dark_mode: bool) -> egui::Color32 {
</file>

<file path="src/overlay/realtime_webview.rs">
pub mod app_selection;
pub mod manager;
pub mod state;
pub mod webview;
pub mod wndproc;
</file>

<file path="src/overlay/realtime_webview/state.rs">
use std::collections::HashMap;
use std::num::NonZeroIsize;
‚ãÆ----
pub static mut REALTIME_HWND: HWND = HWND(std::ptr::null_mut());
pub static mut TRANSLATION_HWND: HWND = HWND(std::ptr::null_mut());
‚ãÆ----
thread_local! {
‚ãÆ----
pub struct HwndWrapper(pub HWND);
impl HasWindowHandle for HwndWrapper {
fn window_handle(&self) -> std::result::Result<WindowHandle<'_>, HandleError> {
‚ãÆ----
Ok(unsafe { WindowHandle::borrow_raw(raw) })
‚ãÆ----
Err(HandleError::Unavailable)
</file>

<file path="src/overlay/utils.rs">
pub fn to_wstring(s: &str) -> Vec<u16> {
s.encode_utf16().chain(std::iter::once(0)).collect()
‚ãÆ----
pub fn get_context_quote(text: &str) -> String {
let words: Vec<&str> = text.split_whitespace().collect();
let len = words.len();
‚ãÆ----
format!("\"... {}\"", words[len - 50..].join(" "))
‚ãÆ----
format!("\"... {}\"", words.join(" "))
‚ãÆ----
pub fn copy_to_clipboard(text: &str, hwnd: HWND) {
‚ãÆ----
if OpenClipboard(Some(hwnd)).is_ok() {
let _ = EmptyClipboard();
let wide_text: Vec<u16> = text.encode_utf16().chain(std::iter::once(0)).collect();
let mem_size = wide_text.len() * 2;
if let Ok(h_mem) = GlobalAlloc(GMEM_MOVEABLE, mem_size) {
let ptr = GlobalLock(h_mem) as *mut u16;
std::ptr::copy_nonoverlapping(wide_text.as_ptr(), ptr, wide_text.len());
let _ = GlobalUnlock(h_mem);
let h_mem_handle = HANDLE(h_mem.0);
let _ = SetClipboardData(13u32, Some(h_mem_handle));
‚ãÆ----
let _ = CloseClipboard();
‚ãÆ----
eprintln!("Failed to copy to clipboard after 5 attempts");
‚ãÆ----
pub fn copy_image_to_clipboard(image_bytes: &[u8]) {
‚ãÆ----
if img.write_to(&mut cursor, image::ImageFormat::Bmp).is_ok() {
if bmp_data.len() > 14 && bmp_data[0] == 0x42 && bmp_data[1] == 0x4D {
‚ãÆ----
if OpenClipboard(None).is_ok() {
‚ãÆ----
let mem_size = dib_data.len();
‚ãÆ----
let ptr = GlobalLock(h_mem) as *mut u8;
std::ptr::copy_nonoverlapping(dib_data.as_ptr(), ptr, mem_size);
‚ãÆ----
let _ = SetClipboardData(8, Some(h_mem_handle));
‚ãÆ----
let hdc = GetDC(None);
if !hdc.is_invalid() {
if dib_data.len() >= 4 {
‚ãÆ----
dib_data[0..4].try_into().unwrap_or([0; 4]),
‚ãÆ----
if (header_size as usize) < dib_data.len() {
‚ãÆ----
dib_data.as_ptr().add(header_size as usize);
‚ãÆ----
dib_data.as_ptr() as *const BITMAPINFOHEADER;
let pbmi = dib_data.as_ptr() as *const BITMAPINFO;
let hbitmap = CreateDIBitmap(
‚ãÆ----
Some(pbmih),
‚ãÆ----
Some(bits_ptr as *const std::ffi::c_void),
Some(pbmi),
‚ãÆ----
if !hbitmap.is_invalid() {
let _ = SetClipboardData(
‚ãÆ----
Some(HANDLE(hbitmap.0 as *mut _)),
‚ãÆ----
ReleaseDC(None, hdc);
‚ãÆ----
pub fn get_clipboard_image_bytes() -> Option<Vec<u8>> {
use windows::Win32::System::DataExchange::IsClipboardFormatAvailable;
‚ãÆ----
let has_dib = IsClipboardFormatAvailable(8).is_ok();
let has_dibv5 = IsClipboardFormatAvailable(17).is_ok();
‚ãÆ----
if let Ok(h_data) = GetClipboardData(format_to_try) {
let ptr = GlobalLock(HGLOBAL(h_data.0));
if !ptr.is_null() {
let size = GlobalSize(HGLOBAL(h_data.0));
‚ãÆ----
if dib_data.len() >= std::mem::size_of::<BITMAPINFOHEADER>() {
let header = &*(dib_data.as_ptr() as *const BITMAPINFOHEADER);
‚ãÆ----
let height = header.biHeight.abs();
‚ãÆ----
if dib_data.len() > pixel_offset {
‚ãÆ----
if px_start + bytes_per_pixel <= pixel_data.len() {
‚ãÆ----
rgba_buffer.push(r);
rgba_buffer.push(g);
rgba_buffer.push(b);
rgba_buffer.push(a);
‚ãÆ----
let _ = GlobalUnlock(HGLOBAL(h_data.0));
‚ãÆ----
.write_to(&mut cursor, image::ImageFormat::Png)
.is_ok()
‚ãÆ----
return Some(png_data);
‚ãÆ----
pub fn get_target_window_for_paste() -> Option<HWND> {
‚ãÆ----
let hwnd_foreground = GetForegroundWindow();
if hwnd_foreground.is_invalid() {
‚ãÆ----
let thread_id = GetWindowThreadProcessId(hwnd_foreground, None);
‚ãÆ----
if GetGUIThreadInfo(thread_id, &mut gui_info).is_ok() {
let has_caret = !gui_info.hwndCaret.is_invalid();
‚ãÆ----
let has_focus = !gui_info.hwndFocus.is_invalid();
‚ãÆ----
return Some(hwnd_foreground);
‚ãÆ----
pub fn force_focus_and_paste(hwnd_target: HWND) {
‚ãÆ----
if IsWindow(Some(hwnd_target)).as_bool() {
let cur_thread = GetCurrentThreadId();
let target_thread = GetWindowThreadProcessId(hwnd_target, None);
‚ãÆ----
let _ = AttachThreadInput(cur_thread, target_thread, true);
let _ = SetForegroundWindow(hwnd_target);
let _ = BringWindowToTop(hwnd_target);
let _ = SetFocus(Some(hwnd_target));
let _ = AttachThreadInput(cur_thread, target_thread, false);
‚ãÆ----
let state = GetAsyncKeyState(vk as i32);
‚ãÆ----
wVk: VIRTUAL_KEY(vk),
‚ãÆ----
SendInput(&[input], std::mem::size_of::<INPUT>() as i32);
‚ãÆ----
release_if_pressed(VK_MENU.0);
release_if_pressed(VK_SHIFT.0);
release_if_pressed(VK_LWIN.0);
release_if_pressed(VK_RWIN.0);
release_if_pressed(VK_CONTROL.0);
‚ãÆ----
send_input_event(VK_CONTROL.0, KEYBD_EVENT_FLAGS(0));
‚ãÆ----
send_input_event(VK_V.0, KEYBD_EVENT_FLAGS(0));
‚ãÆ----
send_input_event(VK_V.0, KEYEVENTF_KEYUP);
‚ãÆ----
send_input_event(VK_CONTROL.0, KEYEVENTF_KEYUP);
‚ãÆ----
pub fn get_error_message(error: &str, lang: &str, model_name: Option<&str>) -> String {
if error.starts_with("NO_API_KEY") {
let provider = if error.contains(':') {
let parts: Vec<&str> = error.split(':').collect();
if parts.len() > 1 {
‚ãÆ----
"vi" => format!("B·∫°n ch∆∞a nh·∫≠p {} API key!", provider),
"ko" => format!("{} API ÌÇ§Î•º ÏûÖÎ†•ÌïòÏßÄ ÏïäÏïòÏäµÎãàÎã§!", provider),
"ja" => format!("{} API„Ç≠„Éº„ÅåÂÖ•Âäõ„Åï„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì!", provider),
"zh" => format!("ÊÇ®ËøòÊ≤°ÊúâËæìÂÖ• {} API key!", provider),
_ => format!("You haven't entered a {} API key!", provider),
‚ãÆ----
if error.starts_with("INVALID_API_KEY") {
‚ãÆ----
"vi" => format!("{} API key kh√¥ng h·ª£p l·ªá!", provider),
"ko" => format!("{} API ÌÇ§Í∞Ä Ïú†Ìö®ÌïòÏßÄ ÏïäÏäµÎãàÎã§!", provider),
"ja" => format!("{} API„Ç≠„Éº„ÅåÁÑ°Âäπ„Åß„Åô!", provider),
"zh" => format!("{} API key Êó†Êïà!", provider),
_ => format!("Invalid {} API key!", provider),
‚ãÆ----
if let Some(status_code) = extract_http_status_code(error) {
let provider = extract_provider_from_error(error);
return format_http_error(status_code, &provider, model_name, lang);
‚ãÆ----
"vi" => format!("L·ªói: {}", error),
"ko" => format!("Ïò§Î•ò: {}", error),
"ja" => format!("„Ç®„É©„Éº: {}", error),
"zh" => format!("ÈîôËØØ: {}", error),
_ => format!("Error: {}", error),
‚ãÆ----
fn extract_http_status_code(error: &str) -> Option<u16> {
if let Some(pos) = error.find("status code ") {
‚ãÆ----
let code_str: String = after.chars().take_while(|c| c.is_ascii_digit()).collect();
return code_str.parse().ok();
‚ãÆ----
let trimmed = error.trim();
if trimmed.len() >= 3 {
‚ãÆ----
.chars()
.rev()
.take(3)
‚ãÆ----
.collect();
if last_3.chars().all(|c| c.is_ascii_digit()) {
‚ãÆ----
if (400..=599).contains(&code) {
return Some(code);
‚ãÆ----
if error.contains(&code.to_string()) {
‚ãÆ----
fn extract_provider_from_error(error: &str) -> String {
if error.contains("api.groq.com") {
"Groq".to_string()
} else if error.contains("generativelanguage.googleapis.com") || error.contains("gemini") {
"Google Gemini".to_string()
} else if error.contains("api.openai.com") {
"OpenAI".to_string()
} else if error.contains("api.anthropic.com") || error.contains("claude") {
"Anthropic".to_string()
‚ãÆ----
"API".to_string()
‚ãÆ----
fn format_http_error(
‚ãÆ----
format!("{} ({})", model, provider)
‚ãÆ----
provider.to_string()
‚ãÆ----
"vi" => format!("L·ªói 429: ƒê√£ v∆∞·ª£t qu√° h·∫°n m·ª©c c·ªßa m√¥ h√¨nh {} (Rate Limit). Vui l√≤ng ch·ªù m·ªôt l√°t r·ªìi th·ª≠ l·∫°i.", model_info),
"ko" => format!("Ïò§Î•ò 429: {} Î™®Îç∏Ïùò ÏöîÏ≤≠ Ï†úÌïú Ï¥àÍ≥º (Rate Limit). Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥ Ï£ºÏÑ∏Ïöî.", model_info),
"ja" => format!("„Ç®„É©„Éº 429: {} „ÅÆ„É¨„Éº„ÉàÂà∂Èôê„ÇíË∂Ö„Åà„Åæ„Åó„Åü„ÄÇ„Åó„Å∞„Çâ„Åè„Åó„Å¶„Åã„ÇâÂÜçË©¶Ë°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ", model_info),
"zh" => format!("ÈîôËØØ 429: {} Ê®°ÂûãËØ∑Ê±ÇË∂ÖÂá∫ÈôêÂà∂ (Rate Limit)„ÄÇËØ∑Á®çÂêéÂÜçËØï„ÄÇ", model_info),
_ => format!("Error 429: Rate limit exceeded for model {}. Please wait a moment and try again.", model_info),
‚ãÆ----
"vi" => format!("L·ªói 400: Y√™u c·∫ßu kh√¥ng h·ª£p l·ªá ƒë·∫øn {}. Vui l√≤ng ki·ªÉm tra l·∫°i c√†i ƒë·∫∑t.", model_info),
"ko" => format!("Ïò§Î•ò 400: {}Ïóê ÎåÄÌïú ÏûòÎ™ªÎêú ÏöîÏ≤≠ÏûÖÎãàÎã§. ÏÑ§Ï†ïÏùÑ ÌôïÏù∏Ìï¥ Ï£ºÏÑ∏Ïöî.", model_info),
"ja" => format!("„Ç®„É©„Éº 400: {} „Å∏„ÅÆ„É™„ÇØ„Ç®„Çπ„Éà„ÅåÁÑ°Âäπ„Åß„Åô„ÄÇË®≠ÂÆö„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ", model_info),
"zh" => format!("ÈîôËØØ 400: {} ËØ∑Ê±ÇÊó†Êïà„ÄÇËØ∑Ê£ÄÊü•ËÆæÁΩÆ„ÄÇ", model_info),
_ => format!("Error 400: Bad request to {}. Please check your settings.", model_info),
‚ãÆ----
"vi" => format!("L·ªói 401: API key c·ªßa {} kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n.", provider),
"ko" => format!("Ïò§Î•ò 401: {} API ÌÇ§Í∞Ä Ïú†Ìö®ÌïòÏßÄ ÏïäÍ±∞ÎÇò ÎßåÎ£åÎêòÏóàÏäµÎãàÎã§.", provider),
"ja" => format!("„Ç®„É©„Éº 401: {} „ÅÆ API „Ç≠„Éº„ÅåÁÑ°Âäπ„Åæ„Åü„ÅØÊúüÈôêÂàá„Çå„Åß„Åô„ÄÇ", provider),
"zh" => format!("ÈîôËØØ 401: {} API ÂØÜÈí•Êó†ÊïàÊàñÂ∑≤ËøáÊúü„ÄÇ", provider),
_ => format!("Error 401: {} API key is invalid or expired.", provider),
‚ãÆ----
"vi" => format!("L·ªói 403: Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p {}. Vui l√≤ng ki·ªÉm tra API key.", provider),
"ko" => format!("Ïò§Î•ò 403: {}Ïóê ÎåÄÌïú Ï†ëÍ∑º Í∂åÌïúÏù¥ ÏóÜÏäµÎãàÎã§. API ÌÇ§Î•º ÌôïÏù∏Ìï¥ Ï£ºÏÑ∏Ïöî.", provider),
"ja" => format!("„Ç®„É©„Éº 403: {} „Å∏„ÅÆ„Ç¢„ÇØ„Çª„ÇπÊ®©Èôê„Åå„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇAPI „Ç≠„Éº„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ", provider),
"zh" => format!("ÈîôËØØ 403: Êó†ÊùÉËÆøÈóÆ {}„ÄÇËØ∑Ê£ÄÊü• API ÂØÜÈí•„ÄÇ", provider),
_ => format!("Error 403: Access forbidden to {}. Please check your API key.", provider),
‚ãÆ----
"vi" => format!("L·ªói 404: Kh√¥ng t√¨m th·∫•y m√¥ h√¨nh {} tr√™n {}.", model_name.unwrap_or("n√†y"), provider),
"ko" => format!("Ïò§Î•ò 404: {}ÏóêÏÑú {} Î™®Îç∏ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.", provider, model_name.unwrap_or("Ìï¥Îãπ")),
"ja" => format!("„Ç®„É©„Éº 404: {} „Åß {} „ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÇ", provider, model_name.unwrap_or("„Åì„ÅÆ„É¢„Éá„É´")),
"zh" => format!("ÈîôËØØ 404: Âú® {} ‰∏äÊâæ‰∏çÂà∞Ê®°Âûã {}„ÄÇ", provider, model_name.unwrap_or("Ê≠§")),
_ => format!("Error 404: Model {} not found on {}.", model_name.unwrap_or("this"), provider),
‚ãÆ----
"vi" => format!("L·ªói 500: M√°y ch·ªß {} g·∫∑p l·ªói n·ªôi b·ªô. Vui l√≤ng th·ª≠ l·∫°i sau.", provider),
"ko" => format!("Ïò§Î•ò 500: {} ÏÑúÎ≤Ñ ÎÇ¥Î∂Ä Ïò§Î•òÏûÖÎãàÎã§. ÎÇòÏ§ëÏóê Îã§Ïãú ÏãúÎèÑÌï¥ Ï£ºÏÑ∏Ïöî.", provider),
"ja" => format!("„Ç®„É©„Éº 500: {} „Çµ„Éº„Éê„ÉºÂÜÖÈÉ®„Ç®„É©„Éº„ÄÇÂæå„ÅßÂÜçË©¶Ë°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ", provider),
"zh" => format!("ÈîôËØØ 500: {} ÊúçÂä°Âô®ÂÜÖÈÉ®ÈîôËØØ„ÄÇËØ∑Á®çÂêéÂÜçËØï„ÄÇ", provider),
_ => format!("Error 500: {} internal server error. Please try again later.", provider),
‚ãÆ----
"vi" => format!("L·ªói 502: Bad Gateway - {} ƒëang g·∫∑p s·ª± c·ªë. Vui l√≤ng th·ª≠ l·∫°i sau.", provider),
"ko" => format!("Ïò§Î•ò 502: Bad Gateway - {}Ïóê Î¨∏Ï†úÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. ÎÇòÏ§ëÏóê Îã§Ïãú ÏãúÎèÑÌï¥ Ï£ºÏÑ∏Ïöî.", provider),
"ja" => format!("„Ç®„É©„Éº 502: Bad Gateway - {} „Å´ÂïèÈ°å„ÅåÁô∫Áîü„Åó„Å¶„ÅÑ„Åæ„Åô„ÄÇÂæå„ÅßÂÜçË©¶Ë°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ", provider),
"zh" => format!("ÈîôËØØ 502: Bad Gateway - {} ÈÅáÂà∞ÈóÆÈ¢ò„ÄÇËØ∑Á®çÂêéÂÜçËØï„ÄÇ", provider),
_ => format!("Error 502: Bad Gateway - {} is having issues. Please try again later.", provider),
‚ãÆ----
"vi" => format!("L·ªói 503: D·ªãch v·ª• {} ƒëang qu√° t·∫£i ho·∫∑c b·∫£o tr√¨. Vui l√≤ng th·ª≠ l·∫°i sau.", provider),
"ko" => format!("Ïò§Î•ò 503: {} ÏÑúÎπÑÏä§Í∞Ä Í≥ºÎ∂ÄÌïò ÏÉÅÌÉúÏù¥Í±∞ÎÇò Ï†êÍ≤Ä Ï§ëÏûÖÎãàÎã§. ÎÇòÏ§ëÏóê Îã§Ïãú ÏãúÎèÑÌï¥ Ï£ºÏÑ∏Ïöî.", provider),
"ja" => format!("„Ç®„É©„Éº 503: {} „Çµ„Éº„Éì„Çπ„ÅåÈÅéË≤†Ëç∑„Åæ„Åü„ÅØ„É°„É≥„ÉÜ„Éä„É≥„Çπ‰∏≠„Åß„Åô„ÄÇÂæå„ÅßÂÜçË©¶Ë°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ", provider),
"zh" => format!("ÈîôËØØ 503: {} ÊúçÂä°ËøáËΩΩÊàñÁª¥Êä§‰∏≠„ÄÇËØ∑Á®çÂêéÂÜçËØï„ÄÇ", provider),
_ => format!("Error 503: {} service is overloaded or under maintenance. Please try again later.", provider),
‚ãÆ----
"vi" => format!("L·ªói 504: H·∫øt th·ªùi gian ch·ªù ph·∫£n h·ªìi t·ª´ {}. Vui l√≤ng th·ª≠ l·∫°i.", model_info),
"ko" => format!("Ïò§Î•ò 504: {} ÏùëÎãµ ÏãúÍ∞Ñ Ï¥àÍ≥º. Îã§Ïãú ÏãúÎèÑÌï¥ Ï£ºÏÑ∏Ïöî.", model_info),
"ja" => format!("„Ç®„É©„Éº 504: {} „Åã„Çâ„ÅÆÂøúÁ≠î„Åå„Çø„Ç§„É†„Ç¢„Ç¶„Éà„Åó„Åæ„Åó„Åü„ÄÇÂÜçË©¶Ë°å„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ", model_info),
"zh" => format!("ÈîôËØØ 504: {} ÂìçÂ∫îË∂ÖÊó∂„ÄÇËØ∑ÈáçËØï„ÄÇ", model_info),
_ => format!("Error 504: Gateway timeout from {}. Please try again.", model_info),
‚ãÆ----
"vi" => format!("L·ªói {}: C√≥ l·ªói x·∫£y ra v·ªõi {} (HTTP {}).", status_code, model_info, status_code),
"ko" => format!("Ïò§Î•ò {}: {}ÏóêÏÑú Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§ (HTTP {}).", status_code, model_info, status_code),
"ja" => format!("„Ç®„É©„Éº {}: {} „Åß„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü (HTTP {}).", status_code, model_info, status_code),
"zh" => format!("ÈîôËØØ {}: {} ÂèëÁîüÈîôËØØ (HTTP {}).", status_code, model_info, status_code),
_ => format!("Error {}: An error occurred with {} (HTTP {}).", status_code, model_info, status_code),
</file>

<file path="promptdj-midi/utils/Locales.ts">
export type Lang = keyof typeof LOCALES;
</file>

<file path="src/config/config.rs">
fn default_true() -> bool {
‚ãÆ----
fn default_history_limit() -> usize {
‚ãÆ----
fn default_graphics_mode() -> String {
"standard".to_string()
‚ãÆ----
fn default_tts_voice() -> String {
"Aoede".to_string()
‚ãÆ----
fn default_tts_speed() -> String {
"Fast".to_string()
‚ãÆ----
fn default_tts_method() -> TtsMethod {
‚ãÆ----
fn default_edge_tts_settings() -> EdgeTtsSettings {
‚ãÆ----
fn default_realtime_translation_model() -> String {
"groq-llama".to_string()
‚ãÆ----
fn default_realtime_font_size() -> u32 {
‚ãÆ----
fn default_realtime_window_size() -> (i32, i32) {
‚ãÆ----
fn default_realtime_target_language() -> String {
"Vietnamese".to_string()
‚ãÆ----
fn default_ollama_base_url() -> String {
"http://localhost:11434".to_string()
‚ãÆ----
pub struct Config {
‚ãÆ----
impl Default for Config {
fn default() -> Self {
‚ãÆ----
presets: get_default_presets(),
‚ãÆ----
ui_language: get_system_ui_language(),
‚ãÆ----
graphics_mode: "standard".to_string(),
‚ãÆ----
ollama_base_url: "http://localhost:11434".to_string(),
‚ãÆ----
realtime_translation_model: "groq-llama".to_string(),
‚ãÆ----
realtime_audio_source: "device".to_string(),
realtime_target_language: "Vietnamese".to_string(),
‚ãÆ----
tts_voice: "Aoede".to_string(),
tts_speed: "Fast".to_string(),
‚ãÆ----
tts_language_conditions: default_tts_language_conditions(),
</file>

<file path="src/config/preset/defaults/audio.rs">
use crate::config::preset::Preset;
‚ãÆ----
pub fn create_audio_presets() -> Vec<Preset> {
vec![
</file>

<file path="src/config/preset/defaults/text.rs">
use crate::config::preset::Preset;
‚ãÆ----
pub fn create_text_presets() -> Vec<Preset> {
vec![
</file>

<file path="src/gui/app.rs">
mod init;
mod input_handler;
mod logic;
mod rendering;
mod types;
mod utils;
pub use types::SettingsApp;
pub use utils::signal_restore_window;
use eframe::egui;
‚ãÆ----
fn clear_color(&self, _visuals: &egui::Visuals) -> [f32; 4] {
‚ãÆ----
fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
‚ãÆ----
self.check_updater();
self.update_theme_and_tray(ctx);
self.update_startup(ctx);
self.update_bubble_sync();
self.update_splash(ctx);
self.check_restore_signal(ctx);
self.update_hotkey_recording(ctx);
self.handle_events(ctx);
self.handle_close_request(ctx);
self.update_tips_logic(ctx);
self.render_footer_and_tips_modal(ctx);
self.render_main_layout(ctx);
self.render_fade_overlay(ctx);
‚ãÆ----
splash.paint(ctx);
‚ãÆ----
self.render_drop_overlay(ctx);
‚ãÆ----
fn on_exit(&mut self, _gl: Option<&eframe::glow::Context>) {
</file>

<file path="src/gui/settings_ui/help_assistant.rs">
use crate::api::client::UREQ_AGENT;
‚ãÆ----
pub fn is_modal_open() -> bool {
HELP_INPUT_ACTIVE.load(Ordering::SeqCst)
‚ãÆ----
fn fetch_repomix_xml() -> Result<String, String> {
‚ãÆ----
match UREQ_AGENT.get(url).call() {
‚ãÆ----
.into_body().read_to_string()
.map_err(|e| format!("Failed to read response: {}", e)),
Err(e) => Err(format!("Failed to fetch XML: {}", e)),
‚ãÆ----
fn ask_gemini(gemini_api_key: &str, question: &str, context_xml: &str) -> Result<String, String> {
if gemini_api_key.trim().is_empty() {
return Err("Gemini API key not configured. Please set it in Global Settings.".to_string());
‚ãÆ----
let url = format!(
‚ãÆ----
let user_message = format!(
‚ãÆ----
.post(&url)
.header("Content-Type", "application/json")
.send(&body.to_string())
.map_err(|e| format!("API request failed: {}", e))?;
‚ãÆ----
.into_body().read_json()
.map_err(|e| format!("Failed to parse response: {}", e))?;
‚ãÆ----
.as_str()
.map(|s| s.to_string())
.ok_or_else(|| "Failed to extract response text".to_string())
‚ãÆ----
pub fn show_help_input() {
HELP_INPUT_ACTIVE.store(true, Ordering::SeqCst);
‚ãÆ----
let app = crate::APP.lock().unwrap();
‚ãÆ----
app.config.gemini_api_key.clone(),
app.config.ui_language.clone(),
‚ãÆ----
let placeholder = match ui_language.as_str() {
‚ãÆ----
placeholder.to_string(),
ui_language.clone(),
‚ãÆ----
let question = question.trim().to_string();
if question.is_empty() {
HELP_INPUT_ACTIVE.store(false, Ordering::SeqCst);
‚ãÆ----
let gemini_key = gemini_api_key.clone();
let lang = ui_language.clone();
‚ãÆ----
let loading_msg = match lang.as_str() {
‚ãÆ----
let _ = CoInitializeEx(None, COINIT_APARTMENTTHREADED);
‚ãÆ----
unsafe { (GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN)) };
‚ãÆ----
"gemini-2.5-flash".to_string(),
"google".to_string(),
‚ãÆ----
"Ask SGT".to_string(),
‚ãÆ----
loading_msg.to_string(),
‚ãÆ----
let _ = ShowWindow(result_hwnd, SW_SHOW);
let _ = SetForegroundWindow(result_hwnd);
‚ãÆ----
let result = match fetch_repomix_xml() {
Ok(xml) => ask_gemini(&gemini_key, &question, &xml),
Err(e) => Err(format!("Failed to fetch context: {}", e)),
‚ãÆ----
Ok(answer) => format!("## ‚ùì {}\n\n{}", question, answer),
Err(e) => format!("## ‚ùå Error\n\n{}", e),
‚ãÆ----
while GetMessageW(&mut msg, None, 0, 0).as_bool() {
let _ = TranslateMessage(&msg);
DispatchMessageW(&msg);
</file>

<file path="src/gui/settings_ui/preset.rs">
use eframe::egui;
‚ãÆ----
use crate::gui::locale::LocaleText;
use super::get_localized_preset_name;
use egui_snarl::Snarl;
‚ãÆ----
pub fn render_preset_editor(
‚ãÆ----
if preset_idx >= config.presets.len() { return false; }
let mut preset = config.presets[preset_idx].clone();
‚ãÆ----
ui.set_max_width(510.0);
let is_default_preset = preset.id.starts_with("preset_");
‚ãÆ----
get_localized_preset_name(&preset.id, &config.ui_language)
‚ãÆ----
preset.name.clone()
‚ãÆ----
let is_dark = ui.visuals().dark_mode;
‚ãÆ----
ui.add_space(5.0);
‚ãÆ----
.fill(header_bg)
.stroke(header_stroke)
.inner_margin(12.0)
.corner_radius(10.0)
.show(ui, |ui| {
ui.horizontal(|ui| {
ui.label(egui::RichText::new(text.preset_name_label).strong());
‚ãÆ----
ui.label(egui::RichText::new(&display_name).strong().size(15.0));
‚ãÆ----
if ui.add(egui::TextEdit::singleline(&mut preset.name).font(egui::TextStyle::Body)).changed() {
‚ãÆ----
ui.add_space(10.0);
‚ãÆ----
if ui.checkbox(&mut preset.show_controller_ui, text.controller_checkbox_label).clicked() {
if !preset.show_controller_ui && preset.blocks.is_empty() {
preset.blocks.push(create_default_block_for_type(&preset.preset_type));
*snarl = blocks_to_snarl(&preset.blocks, &preset.block_connections, &preset.preset_type);
‚ãÆ----
ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
‚ãÆ----
if ui.add(egui::Button::new(egui::RichText::new(text.restore_preset_btn).color(egui::Color32::WHITE).small())
.fill(restore_bg)
.corner_radius(8.0))
.on_hover_text(text.restore_preset_tooltip)
.clicked() {
‚ãÆ----
if let Some(default_p) = default_config.presets.iter().find(|p| p.id == preset.id) {
preset = default_p.clone();
‚ãÆ----
request_node_graph_view_reset(ui.ctx());
‚ãÆ----
ui.add_space(6.0);
‚ãÆ----
ui.label(text.preset_type_label);
let selected_text = match preset.preset_type.as_str() {
‚ãÆ----
.selected_text(selected_text)
.show_ui(ui, |ui| {
if ui.selectable_value(&mut preset.preset_type, "image".to_string(), text.preset_type_image).clicked() {
if let Some(first) = preset.blocks.first_mut() {
first.block_type = "image".to_string();
first.model = "maverick".to_string();
‚ãÆ----
if ui.selectable_value(&mut preset.preset_type, "text".to_string(), text.preset_type_text).clicked() {
‚ãÆ----
first.block_type = "text".to_string();
first.model = "text_accurate_kimi".to_string();
‚ãÆ----
if ui.selectable_value(&mut preset.preset_type, "audio".to_string(), text.preset_type_audio).clicked() {
‚ãÆ----
first.block_type = "audio".to_string();
first.model = "whisper-accurate".to_string();
‚ãÆ----
ui.add_enabled_ui(false, |ui| {
let _ = ui.selectable_value(&mut preset.preset_type, "video".to_string(), text.preset_type_video);
‚ãÆ----
ui.add_space(15.0);
‚ãÆ----
ui.label(text.command_mode_label);
‚ãÆ----
.selected_text(if preset.prompt_mode == "dynamic" { text.prompt_mode_dynamic } else { text.prompt_mode_fixed })
‚ãÆ----
if ui.selectable_value(&mut preset.prompt_mode, "fixed".to_string(), text.prompt_mode_fixed).clicked() { changed = true; }
if ui.selectable_value(&mut preset.prompt_mode, "dynamic".to_string(), text.prompt_mode_dynamic).clicked() { changed = true; }
‚ãÆ----
ui.label(text.text_input_mode_label);
‚ãÆ----
.selected_text(if preset.text_input_mode == "type" { text.text_mode_type } else { text.text_mode_select })
‚ãÆ----
if ui.selectable_value(&mut preset.text_input_mode, "select".to_string(), text.text_mode_select).clicked() { changed = true; }
if ui.selectable_value(&mut preset.text_input_mode, "type".to_string(), text.text_mode_type).clicked() { changed = true; }
‚ãÆ----
if ui.checkbox(&mut preset.continuous_input, text.continuous_input_label).clicked() { changed = true; }
‚ãÆ----
let mode_label = match config.ui_language.as_str() {
‚ãÆ----
ui.label(mode_label);
let mode_record = match config.ui_language.as_str() {
‚ãÆ----
let mode_realtime = match config.ui_language.as_str() {
‚ãÆ----
.selected_text(selected_mode_text)
‚ãÆ----
if ui.selectable_value(&mut preset.audio_processing_mode, "record_then_process".to_string(), mode_record).clicked() { changed = true; }
if ui.selectable_value(&mut preset.audio_processing_mode, "realtime".to_string(), mode_realtime).clicked() { changed = true; }
‚ãÆ----
ui.add_space(8.0);
‚ãÆ----
let window_mode_label = match config.ui_language.as_str() {
‚ãÆ----
ui.label(window_mode_label);
let mode_standard = match config.ui_language.as_str() {
‚ãÆ----
let mode_minimal = match config.ui_language.as_str() {
‚ãÆ----
.selected_text(selected_window_mode)
‚ãÆ----
if ui.selectable_value(&mut preset.realtime_window_mode, "standard".to_string(), mode_standard).clicked() { changed = true; }
if ui.selectable_value(&mut preset.realtime_window_mode, "minimal".to_string(), mode_minimal).clicked() { changed = true; }
‚ãÆ----
ui.label(text.audio_source_label);
‚ãÆ----
if ui.selectable_value(&mut preset.audio_source, "mic".to_string(), text.audio_src_mic).clicked() { changed = true; }
if ui.selectable_value(&mut preset.audio_source, "device".to_string(), text.audio_src_device).clicked() { changed = true; }
‚ãÆ----
if ui.checkbox(&mut preset.hide_recording_ui, text.hide_recording_ui_label).clicked() { changed = true; }
‚ãÆ----
if ui.checkbox(&mut preset.auto_stop_recording, text.auto_stop_recording_label).clicked() { changed = true; }
‚ãÆ----
let has_any_auto_copy = preset.blocks.iter().any(|b| b.auto_copy);
‚ãÆ----
if ui.checkbox(&mut preset.auto_paste, text.auto_paste_label).clicked() { changed = true; }
let auto_copy_block = preset.blocks.iter().find(|b| b.auto_copy);
‚ãÆ----
if ui.checkbox(&mut preset.auto_paste_newline, text.auto_paste_newline_label).clicked() { changed = true; }
‚ãÆ----
ui.label(egui::RichText::new(text.hotkeys_section).strong());
‚ãÆ----
if *recording_hotkey_for_preset == Some(preset_idx) {
‚ãÆ----
ui.colored_label(text_color, text.press_keys);
‚ãÆ----
if ui.add(egui::Button::new(egui::RichText::new(text.cancel_label).color(egui::Color32::WHITE))
.fill(cancel_bg)
.corner_radius(10.0))
‚ãÆ----
if ui.add(egui::Button::new(egui::RichText::new(text.add_hotkey_button).color(egui::Color32::WHITE))
.fill(add_bg)
‚ãÆ----
.on_hover_cursor(egui::CursorIcon::PointingHand)
‚ãÆ----
*recording_hotkey_for_preset = Some(preset_idx);
‚ãÆ----
for (h_idx, hotkey) in preset.hotkeys.iter().enumerate() {
if ui.add(egui::Button::new(egui::RichText::new(format!("{} √ó", hotkey.name)).color(egui::Color32::WHITE).small())
.fill(hotkey_bg)
‚ãÆ----
hotkey_to_remove = Some(h_idx);
‚ãÆ----
if let Some(h) = hotkey_to_remove { preset.hotkeys.remove(h); changed = true; }
‚ãÆ----
ui.colored_label(egui::Color32::RED, msg);
‚ãÆ----
ui.push_id("node_graph_area", |ui| {
‚ãÆ----
.fill(graph_bg)
.inner_margin(6.0)
.corner_radius(8.0)
‚ãÆ----
ui.set_min_height(325.0);
if render_node_graph(ui, snarl, &config.ui_language, &preset.prompt_mode, config.use_groq, config.use_gemini, config.use_openrouter, config.use_ollama, &preset.preset_type, text) {
‚ãÆ----
ui.add_space(20.0);
‚ãÆ----
.fill(bg_color)
.inner_margin(24.0)
.corner_radius(12.0)
‚ãÆ----
ui.set_min_height(260.0);
‚ãÆ----
match config.ui_language.as_str() {
‚ãÆ----
ui.label(egui::RichText::new(title).heading().color(accent_color));
ui.add_space(16.0);
‚ãÆ----
ui.label(egui::RichText::new(desc).color(text_color));
‚ãÆ----
fn create_default_block_for_type(preset_type: &str) -> ProcessingBlock {
‚ãÆ----
block_type: "audio".to_string(),
model: "whisper-accurate".to_string(),
prompt: "Transcribe this audio.".to_string(),
selected_language: "Vietnamese".to_string(),
‚ãÆ----
block_type: "text".to_string(),
model: "text_accurate_kimi".to_string(),
prompt: "Process this text.".to_string(),
‚ãÆ----
block_type: "image".to_string(),
model: "maverick".to_string(),
prompt: "Extract text from this image.".to_string(),
</file>

<file path="src/model_config.rs">
pub enum ModelType {
‚ãÆ----
pub struct ModelConfig {
‚ãÆ----
impl ModelConfig {
pub fn new(
‚ãÆ----
id: id.to_string(),
provider: provider.to_string(),
name_vi: name_vi.to_string(),
name_ko: name_ko.to_string(),
name_en: name_en.to_string(),
full_name: full_name.to_string(),
‚ãÆ----
quota_limit_vi: quota_limit_vi.to_string(),
quota_limit_ko: quota_limit_ko.to_string(),
quota_limit_en: quota_limit_en.to_string(),
‚ãÆ----
pub fn model_is_non_llm(model_id: &str) -> bool {
‚ãÆ----
pub fn get_all_models() -> &'static [ModelConfig] {
‚ãÆ----
pub fn get_model_by_id(id: &str) -> Option<ModelConfig> {
get_all_models().iter().find(|m| m.id == id).cloned()
‚ãÆ----
/// Get all models including dynamically fetched Ollama models
/// This combines static models with Ollama models (if Ollama is enabled)
‚ãÆ----
/// This combines static models with Ollama models (if Ollama is enabled)
pub fn get_all_models_with_ollama() -> Vec<ModelConfig> {
‚ãÆ----
pub fn get_all_models_with_ollama() -> Vec<ModelConfig> {
let mut models: Vec<ModelConfig> = ALL_MODELS.iter().cloned().collect();
// Add cached Ollama models
let cached = OLLAMA_MODEL_CACHE.lock().unwrap();
for ollama_model in cached.iter() {
models.push(ollama_model.clone());
‚ãÆ----
/// Check if a model supports search capabilities (grounding/web search) by its Full Name (API Name)
pub fn model_supports_search_by_name(full_name: &str) -> bool {
‚ãÆ----
pub fn model_supports_search_by_name(full_name: &str) -> bool {
// Exclusions
if full_name.contains("gemma-3-27b-it") {
‚ãÆ----
if full_name.contains("gemini-3-flash-preview") {
‚ãÆ----
// Inclusions
if full_name.contains("gemini") {
‚ãÆ----
if full_name.contains("gemma") {
‚ãÆ----
if full_name.contains("compound") {
‚ãÆ----
/// Check if a model supports search capabilities (grounding/web search) by its Internal ID
pub fn model_supports_search_by_id(id: &str) -> bool {
‚ãÆ----
pub fn model_supports_search_by_id(id: &str) -> bool {
if let Some(conf) = get_model_by_id(id) {
return model_supports_search_by_name(&conf.full_name);
‚ãÆ----
// Fallback logic for models not in static config (though currently most are)
if id.contains("compound") {
‚ãÆ----
// === OLLAMA MODEL CACHE ===
‚ãÆ----
/// Cached Ollama models (populated by background scan)
    static ref OLLAMA_MODEL_CACHE: Mutex<Vec<ModelConfig>> = Mutex::new(Vec::new());
/// Whether a scan is currently in progress
    static ref OLLAMA_SCAN_IN_PROGRESS: AtomicBool = AtomicBool::new(false);
/// Last scan time (for debouncing) - initialized to 10s ago so first scan works immediately
    static ref OLLAMA_LAST_SCAN: Mutex<std::time::Instant> = Mutex::new(
‚ãÆ----
/// Check if Ollama model scan is in progress
pub fn is_ollama_scan_in_progress() -> bool {
‚ãÆ----
pub fn is_ollama_scan_in_progress() -> bool {
OLLAMA_SCAN_IN_PROGRESS.load(Ordering::SeqCst)
‚ãÆ----
/// Trigger background scan for Ollama models (non-blocking)
/// Returns immediately, models will be populated in cache when ready
‚ãÆ----
/// Returns immediately, models will be populated in cache when ready
pub fn trigger_ollama_model_scan() {
‚ãÆ----
pub fn trigger_ollama_model_scan() {
// Check if Ollama is enabled
let (use_ollama, base_url) = if let Ok(app) = crate::APP.lock() {
(app.config.use_ollama, app.config.ollama_base_url.clone())
‚ãÆ----
// Debounce: don't scan more than once per 5 seconds
‚ãÆ----
let last_scan = OLLAMA_LAST_SCAN.lock().unwrap();
if last_scan.elapsed().as_secs() < 5 {
‚ãÆ----
if OLLAMA_SCAN_IN_PROGRESS.swap(true, Ordering::SeqCst) {
‚ãÆ----
let mut last_scan = OLLAMA_LAST_SCAN.lock().unwrap();
‚ãÆ----
let model_id = format!(
‚ãÆ----
let display_name = format!("{} (Local)", ollama_model.name);
‚ãÆ----
new_models.push(ModelConfig {
id: format!("{}-vision", model_id),
provider: "ollama".to_string(),
name_vi: display_name.clone(),
name_ko: display_name.clone(),
name_en: display_name.clone(),
full_name: ollama_model.name.clone(),
‚ãÆ----
quota_limit_vi: "Kh√¥ng gi·ªõi h·∫°n".to_string(),
quota_limit_ko: "Î¨¥Ï†úÌïú".to_string(),
quota_limit_en: "Unlimited".to_string(),
‚ãÆ----
let mut cache = OLLAMA_MODEL_CACHE.lock().unwrap();
‚ãÆ----
OLLAMA_SCAN_IN_PROGRESS.store(false, Ordering::SeqCst);
</file>

<file path="src/overlay/realtime_webview/app_selection.rs">
use std::collections::HashMap;
use std::sync::Mutex;
‚ãÆ----
use windows::Win32::System::LibraryLoader::GetModuleHandleW;
‚ãÆ----
use windows::Win32::UI::Shell::ExtractIconExW;
‚ãÆ----
fn get_process_exe_path(pid: u32) -> Option<String> {
‚ãÆ----
let handle = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, false, pid).ok()?;
‚ãÆ----
let mut size = buffer.len() as u32;
let result = QueryFullProcessImageNameW(
‚ãÆ----
windows::core::PWSTR(buffer.as_mut_ptr()),
‚ãÆ----
if result.is_ok() && size > 0 {
Some(String::from_utf16_lossy(&buffer[..size as usize]))
‚ãÆ----
fn extract_icon_as_base64(exe_path: &str) -> Option<String> {
‚ãÆ----
let wide_path: Vec<u16> = exe_path.encode_utf16().chain(std::iter::once(0)).collect();
‚ãÆ----
let count = ExtractIconExW(
windows::core::PCWSTR(wide_path.as_ptr()),
‚ãÆ----
Some(&mut large_icon),
‚ãÆ----
if count == 0 || large_icon.is_invalid() {
‚ãÆ----
if GetIconInfo(large_icon, &mut icon_info).is_err() {
let _ = DestroyIcon(large_icon);
‚ãÆ----
if GetObjectW(
icon_info.hbmColor.into(),
‚ãÆ----
Some(&mut bmp as *mut _ as *mut std::ffi::c_void),
‚ãÆ----
let _ = DeleteObject(icon_info.hbmMask.into());
let _ = DeleteObject(icon_info.hbmColor.into());
‚ãÆ----
let hdc_screen = GetDC(None);
let hdc_mem = CreateCompatibleDC(Some(hdc_screen));
‚ãÆ----
let mut pixels = vec![0u8; (width * height * 4) as usize];
let lines = GetDIBits(
‚ãÆ----
Some(pixels.as_mut_ptr() as *mut std::ffi::c_void),
‚ãÆ----
let _ = DeleteDC(hdc_mem);
let _ = ReleaseDC(None, hdc_screen);
‚ãÆ----
for i in (0..pixels.len()).step_by(4) {
pixels.swap(i, i + 2);
‚ãÆ----
for i in (3..pixels.len()).step_by(4) {
‚ãÆ----
.write_to(
‚ãÆ----
.is_err()
‚ãÆ----
use base64::Engine;
Some(base64::engine::general_purpose::STANDARD.encode(&png_data))
‚ãÆ----
fn get_app_icon(pid: u32) -> Option<String> {
‚ãÆ----
let cache = ICON_CACHE.lock().ok()?;
if let Some(cached) = cache.get(&pid) {
return cached.clone();
‚ãÆ----
let icon = get_process_exe_path(pid).and_then(|path| extract_icon_as_base64(&path));
if let Ok(mut cache) = ICON_CACHE.lock() {
cache.insert(pid, icon.clone());
‚ãÆ----
pub fn enumerate_audio_apps() -> Vec<(u32, String)> {
‚ãÆ----
extern "system" fn enum_callback(hwnd: HWND, lparam: LPARAM) -> windows_core::BOOL {
‚ãÆ----
if !IsWindowVisible(hwnd).as_bool() {
‚ãÆ----
let len = GetWindowTextW(hwnd, &mut title_buf);
‚ãÆ----
if title.is_empty() || title == "Program Manager" || title == "Settings" {
‚ãÆ----
GetWindowThreadProcessId(hwnd, Some(&mut pid));
‚ãÆ----
if seen_pids.contains(&pid) {
‚ãÆ----
seen_pids.insert(pid);
‚ãÆ----
apps.push((pid, title));
‚ãÆ----
let _ = EnumWindows(
Some(enum_callback),
LPARAM(&mut callback_data as *mut _ as isize),
‚ãÆ----
apps.sort_by(|a, b| a.1.to_lowercase().cmp(&b.1.to_lowercase()));
‚ãÆ----
pub fn show_app_selection_popup() {
use crate::gui::locale::LocaleText;
use crate::APP;
use std::sync::atomic::Ordering;
‚ãÆ----
let app = APP.lock().unwrap();
let lang = app.config.ui_language.clone();
‚ãÆ----
let apps = enumerate_audio_apps();
if apps.is_empty() {
eprintln!("No audio apps found for selection");
‚ãÆ----
.iter()
.map(|(pid, name)| {
‚ãÆ----
.replace('\\', "\\\\")
.replace('"', "\\\"")
.replace('<', "&lt;")
.replace('>', "&gt;");
let short_name = if escaped_name.chars().count() > 50 {
let truncated: String = escaped_name.chars().take(47).collect();
format!("{}...", truncated)
‚ãÆ----
escaped_name.clone()
‚ãÆ----
let icon_html = if let Some(base64_icon) = get_app_icon(*pid) {
format!(
‚ãÆ----
.collect();
// Get local font CSS (cached fonts, no network loading)
‚ãÆ----
let html = format!(
‚ãÆ----
let class_name = w!("AppSelectPopup");
let h_instance = GetModuleHandleW(None).unwrap_or_default();
‚ãÆ----
lpfnWndProc: Some(app_select_wndproc),
hInstance: h_instance.into(),
hCursor: LoadCursorW(None, IDC_ARROW).unwrap_or_default(),
hbrBackground: HBRUSH(GetStockObject(BLACK_BRUSH).0),
‚ãÆ----
RegisterClassExW(&wc);
let screen_width = GetSystemMetrics(SM_CXSCREEN);
let screen_height = GetSystemMetrics(SM_CYSCREEN);
‚ãÆ----
let hwnd = CreateWindowExW(
‚ãÆ----
w!("Select App"),
‚ãÆ----
Some(h_instance.into()),
‚ãÆ----
.unwrap();
APP_SELECTION_HWND.store(hwnd.0 as isize, Ordering::SeqCst);
‚ãÆ----
let _ = DwmSetWindowAttribute(
‚ãÆ----
let html_clone = html.clone();
‚ãÆ----
let mut web_context = wry::WebContext::new(Some(shared_data_dir));
‚ãÆ----
.with_bounds(wry::Rect {
‚ãÆ----
.with_html(&html_clone)
.with_transparent(true)
.with_ipc_handler(move |req| {
let body = req.body();
if body.starts_with("selectApp:") {
‚ãÆ----
if let Some((pid_str, name)) = rest.split_once(':') {
‚ãÆ----
SELECTED_APP_PID.store(pid, Ordering::SeqCst);
if let Ok(mut app_name) = SELECTED_APP_NAME.lock() {
*app_name = name.to_string();
‚ãÆ----
if let Ok(mut new_source) = NEW_AUDIO_SOURCE.lock() {
*new_source = "device".to_string();
‚ãÆ----
AUDIO_SOURCE_CHANGE.store(true, Ordering::SeqCst);
let hwnd = HWND(hwnd_val as *mut std::ffi::c_void);
let _ = ShowWindow(hwnd, SW_HIDE);
let _ = PostMessageW(Some(hwnd), WM_CLOSE, WPARAM(0), LPARAM(0));
if !std::ptr::addr_of!(TRANSLATION_HWND).read().is_invalid() {
let _ = PostMessageW(
Some(TRANSLATION_HWND),
‚ãÆ----
WPARAM(0),
LPARAM(0),
‚ãÆ----
.build_as_child(&HwndWrapper(hwnd));
if result.is_err() {
eprintln!("Failed to create WebView for app selection");
let _ = DestroyWindow(hwnd);
‚ãÆ----
let _webview = result.unwrap();
‚ãÆ----
while GetMessageW(&mut msg, None, 0, 0).as_bool() {
let _ = TranslateMessage(&msg);
DispatchMessageW(&msg);
‚ãÆ----
pub unsafe extern "system" fn app_select_wndproc(
‚ãÆ----
LRESULT(0)
‚ãÆ----
APP_SELECTION_HWND.store(0, std::sync::atomic::Ordering::SeqCst);
PostQuitMessage(0);
‚ãÆ----
if let Ok(child) = GetWindow(hwnd, GW_CHILD) {
‚ãÆ----
let _ = MoveWindow(child, 0, 0, width, height, true);
‚ãÆ----
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
</file>

<file path="src/overlay/realtime_webview/webview.rs">
use crate::config::get_all_languages;
use crate::gui::locale::LocaleText;
use crate::overlay::realtime_html::get_realtime_html;
use crate::APP;
use std::sync::atomic::Ordering;
‚ãÆ----
use windows::Win32::UI::Input::KeyboardAndMouse::ReleaseCapture;
‚ãÆ----
pub fn create_realtime_webview(
‚ãÆ----
let _ = GetClientRect(hwnd, &mut rect);
‚ãÆ----
let languages = get_all_languages();
‚ãÆ----
let app = APP.lock().unwrap();
let lang = app.config.ui_language.clone();
‚ãÆ----
let html = get_realtime_html(
‚ãÆ----
let wrapper = HwndWrapper(hwnd);
‚ãÆ----
REALTIME_WEB_CONTEXT.with(|ctx| {
if ctx.borrow().is_none() {
‚ãÆ----
*ctx.borrow_mut() = Some(wry::WebContext::new(Some(shared_data_dir)));
‚ãÆ----
let result = REALTIME_WEB_CONTEXT.with(|ctx| {
let mut ctx_ref = ctx.borrow_mut();
let builder = if let Some(web_ctx) = ctx_ref.as_mut() {
‚ãÆ----
.with_bounds(Rect {
‚ãÆ----
.with_html(&html)
.with_transparent(false)
.with_ipc_handler(move |msg: wry::http::Request<String>| {
let body = msg.body();
‚ãÆ----
let _ = ReleaseCapture();
SendMessageW(
‚ãÆ----
Some(WPARAM(HTCAPTION as usize)),
Some(LPARAM(0)),
‚ãÆ----
} else if body.starts_with("groupDragMove:") {
‚ãÆ----
if let Some((dx_str, dy_str)) = coords.split_once(',') {
‚ãÆ----
if !std::ptr::addr_of!(REALTIME_HWND).read().is_invalid() {
‚ãÆ----
let _ = GetWindowRect(REALTIME_HWND, &mut rect);
let _ = SetWindowPos(
‚ãÆ----
if !std::ptr::addr_of!(TRANSLATION_HWND).read().is_invalid() {
‚ãÆ----
let _ = GetWindowRect(TRANSLATION_HWND, &mut rect);
‚ãÆ----
} else if body.starts_with("copyText:") {
‚ãÆ----
let _ = PostMessageW(Some(hwnd_for_ipc), WM_CLOSE, WPARAM(0), LPARAM(0));
‚ãÆ----
let _ = GetWindowRect(hwnd_for_ipc, &mut rect);
‚ãÆ----
let mut app = APP.lock().unwrap();
‚ãÆ----
} else if body.starts_with("fontSize:") {
‚ãÆ----
} else if body.starts_with("audioSource:") {
let source = body[12..].to_string();
if let Ok(mut new_source) = NEW_AUDIO_SOURCE.lock() {
*new_source = source.clone();
‚ãÆ----
SELECTED_APP_PID.store(0, Ordering::SeqCst);
if let Ok(mut name) = SELECTED_APP_NAME.lock() {
name.clear();
‚ãÆ----
let tts_enabled = REALTIME_TTS_ENABLED.load(Ordering::SeqCst);
‚ãÆ----
show_app_selection_popup();
‚ãÆ----
AUDIO_SOURCE_CHANGE.store(true, Ordering::SeqCst);
} else if body.starts_with("language:") {
let lang = body[9..].to_string();
if let Ok(mut new_lang) = NEW_TARGET_LANGUAGE.lock() {
*new_lang = lang.clone();
‚ãÆ----
LANGUAGE_CHANGE.store(true, Ordering::SeqCst);
} else if body.starts_with("translationModel:") {
let model = body[17..].to_string();
if let Ok(mut new_model) = NEW_TRANSLATION_MODEL.lock() {
*new_model = model.clone();
‚ãÆ----
TRANSLATION_MODEL_CHANGE.store(true, Ordering::SeqCst);
} else if body.starts_with("resize:") {
‚ãÆ----
let new_width = (rect.right - rect.left + dx).max(200);
let new_height = (rect.bottom - rect.top + dy).max(100);
‚ãÆ----
} else if body.starts_with("toggleMic:") {
‚ãÆ----
MIC_VISIBLE.store(visible, Ordering::SeqCst);
‚ãÆ----
ShowWindow(REALTIME_HWND, if visible { SW_SHOW } else { SW_HIDE });
‚ãÆ----
sync_visibility_to_webviews();
if !MIC_VISIBLE.load(Ordering::SeqCst)
&& !TRANS_VISIBLE.load(Ordering::SeqCst)
‚ãÆ----
REALTIME_STOP_SIGNAL.store(true, Ordering::SeqCst);
crate::api::tts::TTS_MANAGER.stop();
‚ãÆ----
let _ = PostMessageW(
Some(REALTIME_HWND),
‚ãÆ----
WPARAM(0),
LPARAM(0),
‚ãÆ----
} else if body.starts_with("toggleTrans:") {
‚ãÆ----
TRANS_VISIBLE.store(visible, Ordering::SeqCst);
‚ãÆ----
let _ = ShowWindow(
‚ãÆ----
Some(TRANSLATION_HWND),
‚ãÆ----
} else if body.starts_with("ttsEnabled:") {
‚ãÆ----
REALTIME_TTS_ENABLED.store(enabled, Ordering::SeqCst);
‚ãÆ----
let popup_hwnd_val = APP_SELECTION_HWND.load(Ordering::SeqCst);
‚ãÆ----
Some(popup_hwnd),
‚ãÆ----
APP_SELECTION_HWND.store(0, Ordering::SeqCst);
‚ãÆ----
LAST_SPOKEN_LENGTH.store(0, Ordering::SeqCst);
if let Ok(mut queue) = COMMITTED_TRANSLATION_QUEUE.lock() {
queue.clear();
‚ãÆ----
app.config.realtime_audio_source.clone()
‚ãÆ----
} else if body.starts_with("ttsSpeed:") {
‚ãÆ----
REALTIME_TTS_SPEED.store(speed, Ordering::SeqCst);
REALTIME_TTS_AUTO_SPEED.store(false, Ordering::SeqCst);
‚ãÆ----
} else if body.starts_with("ttsAutoSpeed:") {
‚ãÆ----
REALTIME_TTS_AUTO_SPEED.store(enabled, Ordering::SeqCst);
‚ãÆ----
.build_as_child(&wrapper)
‚ãÆ----
REALTIME_WEBVIEWS.with(|wvs| {
wvs.borrow_mut().insert(hwnd_key, webview);
‚ãÆ----
pub fn destroy_realtime_webview(hwnd: HWND) {
‚ãÆ----
wvs.borrow_mut().remove(&hwnd_key);
‚ãÆ----
pub fn sync_visibility_to_webviews() {
let mic_vis = MIC_VISIBLE.load(Ordering::SeqCst);
let trans_vis = TRANS_VISIBLE.load(Ordering::SeqCst);
let script = format!(
‚ãÆ----
for webview in wvs.borrow().values() {
let _ = webview.evaluate_script(&script);
‚ãÆ----
pub fn update_webview_text(hwnd: HWND, old_text: &str, new_text: &str) {
‚ãÆ----
fn escape_js(text: &str) -> String {
text.replace('\\', "\\\\")
.replace('\'', "\\'")
.replace('\n', "\\n")
.replace('\r', "")
‚ãÆ----
let escaped_old = escape_js(old_text);
let escaped_new = escape_js(new_text);
let script = format!("window.updateText('{}', '{}');", escaped_old, escaped_new);
‚ãÆ----
if let Some(webview) = wvs.borrow().get(&hwnd_key) {
‚ãÆ----
/// Clear/reset the WebView text to initial "ƒêang ch·ªù n√≥i..." state
pub fn clear_webview_text(hwnd: HWND) {
‚ãÆ----
pub fn clear_webview_text(hwnd: HWND) {
‚ãÆ----
let _ = webview.evaluate_script(script);
‚ãÆ----
use super::app_selection::show_app_selection_popup;
</file>

<file path="src/overlay/text_selection.rs">
use crate::APP;
‚ãÆ----
struct TextSelectionState {
‚ãÆ----
unsafe impl Send for TextSelectionState {}
‚ãÆ----
hwnd: HWND(std::ptr::null_mut()),
‚ãÆ----
cached_bitmap: HBITMAP(std::ptr::null_mut()),
‚ãÆ----
cached_font: HFONT(std::ptr::null_mut()),
‚ãÆ----
hook_handle: HHOOK(std::ptr::null_mut()),
‚ãÆ----
pub fn is_active() -> bool {
!SELECTION_STATE.lock().unwrap().hwnd.is_invalid()
‚ãÆ----
pub fn try_instant_process(preset_idx: usize) -> bool {
‚ãÆ----
let original_clipboard = get_clipboard_text();
if OpenClipboard(Some(HWND::default())).is_ok() {
let _ = EmptyClipboard();
let _ = CloseClipboard();
‚ãÆ----
wVk: VIRTUAL_KEY(vk),
‚ãÆ----
SendInput(&[input], std::mem::size_of::<INPUT>() as i32);
‚ãÆ----
send_input_event(VK_CONTROL.0, KEYBD_EVENT_FLAGS(0));
‚ãÆ----
send_input_event(0x43, KEYBD_EVENT_FLAGS(0));
‚ãÆ----
send_input_event(0x43, KEYEVENTF_KEYUP);
‚ãÆ----
send_input_event(VK_CONTROL.0, KEYEVENTF_KEYUP);
‚ãÆ----
clipboard_text = get_clipboard_text();
if !clipboard_text.is_empty() {
‚ãÆ----
if clipboard_text.trim().is_empty() {
if !original_clipboard.is_empty() {
‚ãÆ----
process_selected_text(preset_idx, clipboard_text);
‚ãÆ----
unsafe fn get_clipboard_text() -> String {
‚ãÆ----
if let Ok(h_data) = GetClipboardData(13u32) {
‚ãÆ----
let ptr = GlobalLock(h_global);
if !ptr.is_null() {
let size = GlobalSize(h_global);
‚ãÆ----
if let Some(end) = wide_slice.iter().position(|&c| c == 0) {
‚ãÆ----
let _ = GlobalUnlock(h_global);
‚ãÆ----
fn process_selected_text(preset_idx: usize, clipboard_text: String) {
‚ãÆ----
let app = APP.lock().unwrap();
‚ãÆ----
(p.is_master, p.text_input_mode.clone())
‚ãÆ----
let _ = GetCursorPos(&mut cursor_pos);
‚ãÆ----
super::preset_wheel::show_preset_wheel("text", Some("select"), cursor_pos);
‚ãÆ----
let mut app = APP.lock().unwrap();
‚ãÆ----
app.config.clone(),
app.config.presets[final_preset_idx].clone(),
GetSystemMetrics(SM_CXSCREEN),
GetSystemMetrics(SM_CYSCREEN),
‚ãÆ----
preset.text_input_mode = "select".to_string();
‚ãÆ----
.first()
.map(|h| h.name.clone())
.unwrap_or_default();
‚ãÆ----
pub fn cancel_selection() {
TAG_ABORT_SIGNAL.store(true, Ordering::SeqCst);
let hwnd = SELECTION_STATE.lock().unwrap().hwnd;
‚ãÆ----
if !hwnd.is_invalid() {
let _ = PostMessageW(Some(hwnd), WM_CLOSE, WPARAM(0), LPARAM(0));
‚ãÆ----
unsafe extern "system" fn keyboard_hook_proc(code: i32, wparam: WPARAM, lparam: LPARAM) -> LRESULT {
‚ãÆ----
return LRESULT(1);
‚ãÆ----
CallNextHookEx(None, code, wparam, lparam)
‚ãÆ----
pub fn show_text_selection_tag(preset_idx: usize) {
‚ãÆ----
let mut state = SELECTION_STATE.lock().unwrap();
if !state.hwnd.is_invalid() {
‚ãÆ----
TAG_ABORT_SIGNAL.store(false, Ordering::SeqCst);
if !state.cached_bitmap.is_invalid() {
let _ = DeleteObject(state.cached_bitmap.into());
‚ãÆ----
if !state.cached_font.is_invalid() {
let _ = DeleteObject(state.cached_font.into());
state.cached_font = HFONT(std::ptr::null_mut());
‚ãÆ----
let instance = GetModuleHandleW(None).unwrap();
let class_name = w!("SGT_TextTag");
REGISTER_TAG_CLASS.call_once(|| {
‚ãÆ----
wc.lpfnWndProc = Some(tag_wnd_proc);
wc.hInstance = instance.into();
wc.hCursor = LoadCursorW(None, IDC_ARROW).unwrap();
‚ãÆ----
let _ = RegisterClassW(&wc);
‚ãÆ----
let hwnd = CreateWindowExW(
‚ãÆ----
w!("SGT Tag"),
‚ãÆ----
Some(instance.into()),
‚ãÆ----
SELECTION_STATE.lock().unwrap().hwnd = hwnd;
‚ãÆ----
let hook = SetWindowsHookExW(
‚ãÆ----
Some(keyboard_hook_proc),
Some(GetModuleHandleW(None).unwrap().into()),
‚ãÆ----
SELECTION_STATE.lock().unwrap().hook_handle = h;
‚ãÆ----
let _ = ShowWindow(hwnd, SW_SHOWNOACTIVATE);
‚ãÆ----
while PeekMessageW(&mut msg, None, 0, 0, PM_REMOVE).into() {
‚ãÆ----
let _ = TranslateMessage(&msg);
DispatchMessageW(&msg);
‚ãÆ----
if TAG_ABORT_SIGNAL.load(Ordering::SeqCst) {
‚ãÆ----
if !state.hook_handle.is_invalid() {
let _ = UnhookWindowsHookEx(state.hook_handle);
‚ãÆ----
let _ = DestroyWindow(hwnd);
‚ãÆ----
let _ = GetCursorPos(&mut pt);
‚ãÆ----
let lbutton_down = (GetAsyncKeyState(VK_LBUTTON.0 as i32) as u16 & 0x8000) != 0;
‚ãÆ----
let hwnd_copy = HWND(hwnd_val as *mut std::ffi::c_void);
‚ãÆ----
if TAG_ABORT_SIGNAL.load(Ordering::Relaxed) {
‚ãÆ----
if !clipboard_text.trim().is_empty()
&& !TAG_ABORT_SIGNAL.load(Ordering::Relaxed)
‚ãÆ----
process_selected_text(preset_idx_for_thread, clipboard_text);
let _ = PostMessageW(Some(hwnd_copy), WM_CLOSE, WPARAM(0), LPARAM(0));
‚ãÆ----
paint_tag_window(
‚ãÆ----
let _ = DwmFlush();
‚ãÆ----
unsafe extern "system" fn tag_wnd_proc(
‚ãÆ----
PostQuitMessage(0);
LRESULT(0)
‚ãÆ----
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
‚ãÆ----
unsafe fn paint_tag_window(
‚ãÆ----
let screen_dc = GetDC(None);
let mem_dc = CreateCompatibleDC(Some(screen_dc));
‚ãÆ----
if state.cached_lang.is_none() {
‚ãÆ----
state.cached_lang = Some(app.config.ui_language.clone());
‚ãÆ----
if state.cached_bitmap.is_invalid() {
‚ãÆ----
CreateDIBSection(Some(screen_dc), &bmi, DIB_RGB_COLORS, &mut p_bits, None, 0)
‚ãÆ----
if state.cached_font.is_invalid() {
state.cached_font = CreateFontW(
‚ãÆ----
FONT_CHARSET(DEFAULT_CHARSET.0 as u8),
FONT_OUTPUT_PRECISION(OUT_DEFAULT_PRECIS.0 as u8),
FONT_CLIP_PRECISION(CLIP_DEFAULT_PRECIS.0 as u8),
FONT_QUALITY(CLEARTYPE_QUALITY.0 as u8),
‚ãÆ----
w!("Google Sans Flex"),
‚ãÆ----
let old_bitmap = SelectObject(mem_dc, state.cached_bitmap.into());
if !state.cached_bits.is_null() {
‚ãÆ----
let time_rad = animation_offset.to_radians();
‚ãÆ----
let angle = py.atan2(px);
‚ãÆ----
(angle * 10.0 - time_rad * 8.0).sin() * 0.5
‚ãÆ----
(angle * 2.0 + time_rad * 3.0).sin() * 0.2
‚ãÆ----
let glow_t = (d.max(0.0) / glow_width).clamp(0.0, 1.0);
let glow_intensity = (1.0 - glow_t).powi(2);
let hue = (angle.to_degrees() + animation_offset * 2.0).rem_euclid(360.0);
‚ãÆ----
(glow_r / final_alpha + 0x10 as f32 * (1.0 - blend)).min(255.0) as u32;
‚ãÆ----
(glow_g / final_alpha + 0x10 as f32 * (1.0 - blend)).min(255.0) as u32;
‚ãÆ----
(glow_b / final_alpha + 0x10 as f32 * (1.0 - blend)).min(255.0) as u32;
‚ãÆ----
let t = (d / glow_width).clamp(0.0, 1.0);
let glow_intensity = (1.0 - t).powi(2);
‚ãÆ----
SetBkMode(mem_dc, TRANSPARENT);
SetTextColor(mem_dc, COLORREF(0x00FFFFFF));
let old_font = SelectObject(mem_dc, state.cached_font.into());
‚ãÆ----
match state.cached_lang.as_ref().unwrap().as_str() {
‚ãÆ----
DrawTextW(
‚ãÆ----
let _ = GdiFlush();
‚ãÆ----
for p in pxs.iter_mut() {
‚ãÆ----
let max_c = r.max(g).max(b);
‚ãÆ----
let _ = UpdateLayeredWindow(
‚ãÆ----
Some(&pt_dst),
Some(&size),
Some(mem_dc),
Some(&pt_src),
COLORREF(0),
Some(&bl),
‚ãÆ----
let _ = SelectObject(mem_dc, old_font.into());
let _ = SelectObject(mem_dc, old_bitmap.into());
let _ = DeleteDC(mem_dc);
ReleaseDC(None, screen_dc);
</file>

<file path="src/api/text.rs">
use super::client::UREQ_AGENT;
‚ãÆ----
use crate::gui::locale::LocaleText;
use crate::overlay::result::RefineContext;
use crate::overlay::utils::get_context_quote;
use crate::APP;
use anyhow::Result;
‚ãÆ----
pub fn translate_text_streaming<F>(
‚ãÆ----
.lock()
.ok()
.and_then(|app| {
let config = app.config.clone();
if config.openrouter_api_key.is_empty() {
‚ãÆ----
Some(config.openrouter_api_key.clone())
‚ãÆ----
.unwrap_or_default();
‚ãÆ----
let prompt = format!("{}\n\n{}", instruction, text);
‚ãÆ----
.map(|app| {
‚ãÆ----
config.ollama_base_url.clone(),
config.ollama_text_model.clone(),
‚ãÆ----
.unwrap_or_else(|| ("http://localhost:11434".to_string(), model.clone()));
let actual_model = if ollama_text_model.is_empty() {
model.clone()
‚ãÆ----
.to_lowercase()
.split("translate to ")
.nth(1)
.and_then(|s| s.split('.').next())
.and_then(|s| s.split(',').next())
.map(|s| s.trim().to_string())
.unwrap_or_else(|| "English".to_string());
‚ãÆ----
.chars()
.enumerate()
.map(|(i, c)| {
‚ãÆ----
c.to_uppercase().next().unwrap_or(c)
‚ãÆ----
on_chunk(&translated);
return Ok(translated);
‚ãÆ----
return Err(anyhow::anyhow!("GTX translation failed"));
‚ãÆ----
if gemini_api_key.trim().is_empty() {
return Err(anyhow::anyhow!("NO_API_KEY:gemini"));
‚ãÆ----
format!(
‚ãÆ----
let supports_thinking = (model.contains("gemini-2.5-flash") && !model.contains("lite"))
|| model.contains("gemini-3-flash-preview")
|| model.contains("gemini-robotics");
‚ãÆ----
.post(&url)
.header("x-goog-api-key", gemini_api_key)
.send_json(payload)
.map_err(|e| {
let err_str = e.to_string();
if err_str.contains("401") || err_str.contains("403") {
‚ãÆ----
let reader = BufReader::new(resp.into_body().into_reader());
‚ãÆ----
for line in reader.lines() {
let line = line.map_err(|e| anyhow::anyhow!("Failed to read line: {}", e))?;
if line.starts_with("data: ") {
let json_str = &line["data: ".len()..];
if json_str.trim() == "[DONE]" {
‚ãÆ----
chunk_resp.get("candidates").and_then(|c| c.as_array())
‚ãÆ----
if let Some(first_candidate) = candidates.first() {
‚ãÆ----
.get("content")
.and_then(|c| c.get("parts"))
.and_then(|p| p.as_array())
‚ãÆ----
.get("thought")
.and_then(|t| t.as_bool())
.unwrap_or(false);
‚ãÆ----
part.get("text").and_then(|t| t.as_str())
‚ãÆ----
on_chunk(locale.model_thinking);
‚ãÆ----
full_content.push_str(text);
let wipe_content = format!(
‚ãÆ----
on_chunk(&wipe_content);
‚ãÆ----
on_chunk(text);
‚ãÆ----
.into_body().read_json()
.map_err(|e| anyhow::anyhow!("Failed to parse non-streaming response: {}", e))?;
if let Some(candidates) = chat_resp.get("candidates").and_then(|c| c.as_array()) {
if let Some(first_choice) = candidates.first() {
‚ãÆ----
.iter()
.filter(|p| {
!p.get("thought").and_then(|t| t.as_bool()).unwrap_or(false)
‚ãÆ----
.filter_map(|p| p.get("text").and_then(|t| t.as_str()))
‚ãÆ----
on_chunk(&full_content);
‚ãÆ----
if openrouter_api_key.trim().is_empty() {
return Err(anyhow::anyhow!("NO_API_KEY:openrouter"));
‚ãÆ----
.post("https://openrouter.ai/api/v1/chat/completions")
.header("Authorization", &format!("Bearer {}", openrouter_api_key))
.header("Content-Type", "application/json")
‚ãÆ----
.get(0)
.and_then(|c| c.delta.reasoning.as_ref())
.filter(|s| !s.is_empty())
‚ãÆ----
.and_then(|c| c.delta.content.as_ref())
‚ãÆ----
full_content.push_str(content);
‚ãÆ----
format!("{}{}", crate::api::WIPE_SIGNAL, full_content);
‚ãÆ----
on_chunk(content);
‚ãÆ----
if let Some(choice) = chat_resp.choices.first() {
full_content = choice.message.content.clone();
‚ãÆ----
if groq_api_key.trim().is_empty() {
return Err(anyhow::anyhow!("NO_API_KEY:groq"));
‚ãÆ----
let is_compound = model.starts_with("groq/compound");
‚ãÆ----
let context_quote = get_context_quote(&prompt);
‚ãÆ----
Some(label) => format!(
‚ãÆ----
None => format!(
‚ãÆ----
on_chunk(&search_msg);
‚ãÆ----
.post("https://api.groq.com/openai/v1/chat/completions")
.header("Authorization", &format!("Bearer {}", groq_api_key))
‚ãÆ----
if err_str.contains("401") {
‚ãÆ----
if let Some(remaining) = resp.headers().get("x-ratelimit-remaining-requests").and_then(|v| v.to_str().ok()) {
let limit = resp.headers().get("x-ratelimit-limit-requests").and_then(|v| v.to_str().ok()).unwrap_or("?");
let usage_str = format!("{} / {}", remaining, limit);
if let Ok(mut app) = APP.lock() {
app.model_usage_stats.insert(model.clone(), usage_str);
‚ãÆ----
.map_err(|e| anyhow::anyhow!("Failed to parse compound response: {}", e))?;
if let Some(choices) = json.get("choices").and_then(|c| c.as_array()) {
if let Some(first_choice) = choices.first() {
if let Some(message) = first_choice.get("message") {
‚ãÆ----
message.get("executed_tools").and_then(|t| t.as_array())
‚ãÆ----
if let Some(tool_type) = tool.get("type").and_then(|t| t.as_str()) {
‚ãÆ----
tool.get("arguments").and_then(|a| a.as_str())
‚ãÆ----
args_json.get("query").and_then(|q| q.as_str())
‚ãÆ----
search_queries.push(query.to_string());
‚ãÆ----
if !search_queries.is_empty() {
‚ãÆ----
phase1.push_str(&format!("{}\n", locale.search_query_label));
for (i, query) in search_queries.iter().enumerate() {
phase1.push_str(&format!("  {}. \"{}\"\n", i + 1, query));
‚ãÆ----
on_chunk(&phase1);
‚ãÆ----
.get("search_results")
.and_then(|s| s.get("results"))
.and_then(|r| r.as_array())
‚ãÆ----
.get("title")
.and_then(|t| t.as_str())
.unwrap_or(locale.search_no_title);
‚ãÆ----
.get("url")
.and_then(|u| u.as_str())
.unwrap_or("");
‚ãÆ----
.get("score")
.and_then(|s| s.as_f64())
.unwrap_or(0.0);
‚ãÆ----
.and_then(|c| c.as_str())
‚ãÆ----
all_sources.push((
title.to_string(),
url.to_string(),
‚ãÆ----
content.to_string(),
‚ãÆ----
if !all_sources.is_empty() {
all_sources.sort_by(|a, b| {
b.2.partial_cmp(&a.2).unwrap_or(std::cmp::Ordering::Equal)
‚ãÆ----
let mut phase2 = format!(
‚ãÆ----
phase2.push_str(&format!("{}\n\n", locale.search_sources_label));
‚ãÆ----
all_sources.iter().take(6).enumerate()
‚ãÆ----
let title_display = if title.chars().count() > 60 {
format!("{}...", title.chars().take(57).collect::<String>())
‚ãÆ----
title.clone()
‚ãÆ----
let domain = url.split('/').nth(2).unwrap_or(url);
‚ãÆ----
phase2.push_str(&format!(
‚ãÆ----
phase2.push_str(&format!("   üîó {}\n", domain));
if !content.is_empty() {
let preview = if content.len() > 100 {
‚ãÆ----
content.replace('\n', " ")
‚ãÆ----
phase2.push_str(&format!("   üìÑ {}\n", preview));
‚ãÆ----
phase2.push('\n');
‚ãÆ----
on_chunk(&phase2);
‚ãÆ----
let phase3 = format!(
‚ãÆ----
on_chunk(&phase3);
‚ãÆ----
if let Some(content) = message.get("content").and_then(|c| c.as_str()) {
full_content = content.to_string();
‚ãÆ----
chunk.choices.get(0).and_then(|c| c.delta.content.as_ref())
‚ãÆ----
let chat_resp: ChatCompletionResponse = resp.into_body().read_json().map_err(|e| {
‚ãÆ----
json_obj.get("translation").and_then(|v| v.as_str())
‚ãÆ----
full_content = translation.to_string();
‚ãÆ----
full_content = content_str.clone();
‚ãÆ----
Ok(full_content)
‚ãÆ----
pub fn refine_text_streaming<F>(
‚ãÆ----
let final_prompt = format!(
‚ãÆ----
RefineContext::Image(_) => (original_model_id.to_string(), original_provider.to_string()),
‚ãÆ----
if !original_model_id.trim().is_empty() && original_model_id != "scout" {
(original_model_id.to_string(), original_provider.to_string())
‚ãÆ----
if !gemini_api_key.trim().is_empty() {
("gemini-flash-lite".to_string(), "google".to_string())
} else if !groq_api_key.trim().is_empty() {
("text_accurate_kimi".to_string(), "groq".to_string())
‚ãÆ----
let supports_thinking = (p_model.contains("gemini-2.5-flash")
&& !p_model.contains("lite"))
|| p_model.contains("gemini-3-flash-preview")
|| p_model.contains("gemini-robotics");
‚ãÆ----
.map_err(|e| anyhow::anyhow!("Gemini Refine Error: {}", e))?;
‚ãÆ----
if let Some(first) = candidates.first() {
‚ãÆ----
part.get("text").and_then(|v| v.as_str())
‚ãÆ----
full_content.push_str(t);
‚ãÆ----
on_chunk(t);
‚ãÆ----
let json: serde_json::Value = resp.into_body().read_json()?;
if let Some(candidates) = json.get("candidates").and_then(|c| c.as_array()) {
‚ãÆ----
.map_err(|e| anyhow::anyhow!("OpenRouter Refine Error: {}", e))?;
‚ãÆ----
let json: ChatCompletionResponse = resp.into_body().read_json()?;
if let Some(choice) = json.choices.first() {
‚ãÆ----
let is_compound = p_model.starts_with("groq/compound");
‚ãÆ----
let context_quote = get_context_quote(&final_prompt);
on_chunk(&format!(
‚ãÆ----
.map_err(|e| anyhow::anyhow!("Groq Compound Refine Error: {}", e))?;
‚ãÆ----
app.model_usage_stats.insert(p_model.clone(), usage_str);
‚ãÆ----
if tool.get("type").and_then(|t| t.as_str()) == Some("search") {
‚ãÆ----
let mut phase1 = format!(
‚ãÆ----
for (i, q) in search_queries.iter().enumerate() {
phase1.push_str(&format!("  {}. \"{}\"\n", i + 1, q));
‚ãÆ----
r.get("url").and_then(|u| u.as_str()).unwrap_or("");
‚ãÆ----
all_sources.iter().take(5).enumerate()
‚ãÆ----
let t = if title.chars().count() > 50 {
‚ãÆ----
let domain = url.split('/').nth(2).unwrap_or("");
‚ãÆ----
phase2.push_str(&format!("\n{}", locale.search_synthesizing));
‚ãÆ----
.map_err(|e| anyhow::anyhow!("Groq Refine Error: {}", e))?;
‚ãÆ----
let img = image::load_from_memory(&img_bytes)?.to_rgba8();
vision_translate_image_streaming(
‚ãÆ----
Some(img_bytes.clone()),
‚ãÆ----
exec_text_only(target_id_or_name, target_provider)
‚ãÆ----
RefineContext::None => exec_text_only(target_id_or_name, target_provider),
</file>

<file path="src/api/vision.rs">
use super::client::UREQ_AGENT;
‚ãÆ----
use crate::gui::locale::LocaleText;
use crate::APP;
use anyhow::Result;
‚ãÆ----
pub fn translate_image_streaming<F>(
‚ãÆ----
.lock()
.ok()
.and_then(|app| {
let config = app.config.clone();
if config.openrouter_api_key.is_empty() {
‚ãÆ----
Some(config.openrouter_api_key.clone())
‚ãÆ----
.unwrap_or_default();
‚ãÆ----
let mut mime_type = "image/png".to_string();
if provider == "google" && original_bytes.is_some() {
println!("DEBUG: Zero-Copy optimization active for Google provider");
let bytes = original_bytes.as_ref().unwrap();
b64_image = general_purpose::STANDARD.encode(bytes);
if bytes.starts_with(&[0xff, 0xd8, 0xff]) {
mime_type = "image/jpeg".to_string();
} else if bytes.starts_with(&[0x89, 0x50, 0x4e, 0x47]) {
mime_type = "image/png".to_string();
} else if bytes.starts_with(&[0x52, 0x49, 0x46, 0x46])
‚ãÆ----
mime_type = "image/webp".to_string();
‚ãÆ----
println!("DEBUG: Detected MIME type: {}", mime_type);
‚ãÆ----
if provider != "google" && (final_image.width() > max_dim || final_image.height() > max_dim)
‚ãÆ----
println!("DEBUG: Image exceeds {}px, resizing...", max_dim);
let (n_w, n_h) = if final_image.width() > final_image.height() {
let ratio = max_dim as f32 / final_image.width() as f32;
(max_dim, (final_image.height() as f32 * ratio) as u32)
‚ãÆ----
let ratio = max_dim as f32 / final_image.height() as f32;
((final_image.width() as f32 * ratio) as u32, max_dim)
‚ãÆ----
println!(
‚ãÆ----
final_image.write_to(&mut Cursor::new(&mut image_data), image::ImageFormat::Png)?;
b64_image = general_purpose::STANDARD.encode(&image_data);
‚ãÆ----
.map(|app| {
‚ãÆ----
config.ollama_base_url.clone(),
config.ollama_vision_model.clone(),
config.ui_language.clone(),
‚ãÆ----
.unwrap_or_else(|| {
‚ãÆ----
"http://localhost:11434".to_string(),
model.clone(),
"en".to_string(),
‚ãÆ----
let actual_model = if ollama_vision_model.is_empty() {
model.clone()
‚ãÆ----
let ollama_image = image::load_from_memory(&image_data)?.to_rgba8();
‚ãÆ----
let boundary = format!(
‚ãÆ----
body.extend_from_slice(format!("--{}\r\n", boundary).as_bytes());
body.extend_from_slice(b"Content-Disposition: form-data; name=\"MAX_FILE_SIZE\"\r\n\r\n");
body.extend_from_slice(b"1048576\r\n");
‚ãÆ----
body.extend_from_slice(
‚ãÆ----
body.extend_from_slice(b"Content-Type: image/png\r\n\r\n");
body.extend_from_slice(&image_data);
body.extend_from_slice(b"\r\n");
body.extend_from_slice(format!("--{}--\r\n", boundary).as_bytes());
‚ãÆ----
.post("http://api.qrserver.com/v1/read-qr-code/")
.header(
‚ãÆ----
&format!("multipart/form-data; boundary={}", boundary),
‚ãÆ----
.send(&body)
.map_err(|e| anyhow::anyhow!("QR Server API Error: {}", e))?;
‚ãÆ----
.into_body()
.read_json()
.map_err(|e| anyhow::anyhow!("Failed to parse QR response: {}", e))?;
if let Some(first) = json.as_array().and_then(|a| a.first()) {
if let Some(symbols) = first.get("symbol").and_then(|s| s.as_array()) {
if let Some(first_symbol) = symbols.first() {
if let Some(data) = first_symbol.get("data").and_then(|d| d.as_str()) {
if !data.is_empty() {
full_content = data.to_string();
on_chunk(&full_content);
return Ok(full_content);
‚ãÆ----
if let Some(error) = first_symbol.get("error").and_then(|e| e.as_str()) {
if !error.is_empty() {
return Err(anyhow::anyhow!("QR_NOT_FOUND: {}", error));
‚ãÆ----
return Err(anyhow::anyhow!(
‚ãÆ----
if gemini_api_key.trim().is_empty() {
return Err(anyhow::anyhow!("NO_API_KEY:gemini"));
‚ãÆ----
format!(
‚ãÆ----
let supports_thinking = (model.contains("gemini-2.5-flash") && !model.contains("lite"))
|| model.contains("gemini-3-flash-preview")
|| model.contains("gemini-robotics");
‚ãÆ----
.post(&url)
.header("x-goog-api-key", gemini_api_key)
.send_json(payload)
.map_err(|e| {
let err_str = e.to_string();
if err_str.contains("401") || err_str.contains("403") {
‚ãÆ----
let reader = BufReader::new(resp.into_body().into_reader());
‚ãÆ----
.map(|app| app.config.ui_language.clone())
.unwrap_or_else(|| "en".to_string());
‚ãÆ----
for line in reader.lines() {
let line = line.map_err(|e| anyhow::anyhow!("Failed to read line: {}", e))?;
if line.starts_with("data: ") {
let json_str = &line["data: ".len()..];
if json_str.trim() == "[DONE]" {
‚ãÆ----
chunk_resp.get("candidates").and_then(|c| c.as_array())
‚ãÆ----
if let Some(first_candidate) = candidates.first() {
‚ãÆ----
.get("content")
.and_then(|c| c.get("parts"))
.and_then(|p| p.as_array())
‚ãÆ----
.get("thought")
.and_then(|t| t.as_bool())
.unwrap_or(false);
‚ãÆ----
part.get("text").and_then(|t| t.as_str())
‚ãÆ----
on_chunk(locale.model_thinking);
‚ãÆ----
full_content.push_str(text);
let wipe_content = format!(
‚ãÆ----
on_chunk(&wipe_content);
‚ãÆ----
on_chunk(text);
‚ãÆ----
.map_err(|e| anyhow::anyhow!("Failed to parse non-streaming response: {}", e))?;
if let Some(candidates) = chat_resp.get("candidates").and_then(|c| c.as_array()) {
if let Some(first_choice) = candidates.first() {
‚ãÆ----
.iter()
.filter(|p| {
!p.get("thought").and_then(|t| t.as_bool()).unwrap_or(false)
‚ãÆ----
.filter_map(|p| p.get("text").and_then(|t| t.as_str()))
‚ãÆ----
if openrouter_api_key.trim().is_empty() {
return Err(anyhow::anyhow!("NO_API_KEY:openrouter"));
‚ãÆ----
.post("https://openrouter.ai/api/v1/chat/completions")
.header("Authorization", &format!("Bearer {}", openrouter_api_key))
.header("Content-Type", "application/json")
‚ãÆ----
.get(0)
.and_then(|c| c.delta.reasoning.as_ref())
.filter(|s| !s.is_empty())
‚ãÆ----
.and_then(|c| c.delta.content.as_ref())
‚ãÆ----
full_content.push_str(content);
‚ãÆ----
format!("{}{}", crate::api::WIPE_SIGNAL, full_content);
‚ãÆ----
on_chunk(content);
‚ãÆ----
if let Some(choice) = chat_resp.choices.first() {
full_content = choice.message.content.clone();
‚ãÆ----
if groq_api_key.trim().is_empty() {
return Err(anyhow::anyhow!("NO_API_KEY:groq"));
‚ãÆ----
let resp = UREQ_AGENT.post("https://api.groq.com/openai/v1/chat/completions")
.header("Authorization", &format!("Bearer {}", groq_api_key))
‚ãÆ----
if err_str.contains("401") {
‚ãÆ----
} else if err_str.contains("400") {
‚ãÆ----
.headers()
.get("x-ratelimit-remaining-requests")
.and_then(|v| v.to_str().ok())
‚ãÆ----
.get("x-ratelimit-limit-requests")
‚ãÆ----
.unwrap_or("?");
let usage_str = format!("{} / {}", remaining, limit);
if let Ok(mut app) = APP.lock() {
app.model_usage_stats.insert(model.clone(), usage_str);
‚ãÆ----
chunk.choices.get(0).and_then(|c| c.delta.content.as_ref())
‚ãÆ----
json_obj.get("translation").and_then(|v| v.as_str())
‚ãÆ----
full_content = translation.to_string();
‚ãÆ----
full_content = content_str.clone();
‚ãÆ----
Ok(full_content)
</file>

<file path="src/config/preset/defaults/image.rs">
use crate::config::preset::Preset;
use crate::config::types::Hotkey;
pub fn create_image_presets() -> Vec<Preset> {
vec![
‚ãÆ----
.prompt("") // QR scanner doesn't need a prompt
‚ãÆ----
// Node 1: Format the QR content nicely
</file>

<file path="src/config/preset/defaults/mod.rs">
mod audio;
mod image;
mod master;
mod text;
use crate::config::preset::Preset;
pub use audio::create_audio_presets;
pub use image::create_image_presets;
pub use master::create_master_presets;
pub use text::create_text_presets;
pub fn get_default_presets() -> Vec<Preset> {
let image = create_image_presets();
let text = create_text_presets();
let audio = create_audio_presets();
let masters = create_master_presets();
‚ãÆ----
presets.iter().find(|p| p.id == id).cloned().unwrap()
‚ãÆ----
vec![
</file>

<file path="src/gui/app/rendering.rs">
use super::types::SettingsApp;
use crate::gui::locale::LocaleText;
‚ãÆ----
use eframe::egui;
‚ãÆ----
impl SettingsApp {
pub(crate) fn render_footer_and_tips_modal(&mut self, ctx: &egui::Context) {
‚ãÆ----
let visuals = ctx.style().visuals.clone();
‚ãÆ----
.get(self.current_tip_idx)
.unwrap_or(&"")
.to_string();
‚ãÆ----
.resizable(false)
.show_separator_line(false)
.frame(
‚ãÆ----
.inner_margin(egui::Margin::symmetric(10, 4))
.fill(footer_bg),
‚ãÆ----
.show(ctx, |ui| {
render_footer(
‚ãÆ----
current_tip.clone(),
‚ãÆ----
let tips_list_copy = text.tips_list.clone();
‚ãÆ----
.order(egui::Order::Tooltip)
.anchor(egui::Align2::CENTER_CENTER, egui::vec2(0.0, 0.0))
‚ãÆ----
egui::Frame::popup(ui.style())
.inner_margin(egui::Margin::same(16))
.show(ui, |ui| {
ui.set_max_width(1000.0);
ui.set_max_height(550.0);
ui.horizontal(|ui| {
ui.heading(tips_title);
ui.with_layout(
‚ãÆ----
.clicked()
‚ãÆ----
ui.separator();
ui.add_space(8.0);
‚ãÆ----
.max_height(400.0)
.auto_shrink([false; 2])
‚ãÆ----
for (i, tip) in tips_list_copy.iter().enumerate() {
let is_dark_mode = ctx.style().visuals.dark_mode;
‚ãÆ----
format_tip_with_bold(i + 1, tip, is_dark_mode);
ui.label(layout_job);
if i < tips_list_copy.len() - 1 {
‚ãÆ----
if ctx.input(|i| i.pointer.any_click()) {
if let Some(pos) = ctx.input(|i| i.pointer.interact_pos()) {
if let Some(layer) = ctx.layer_id_at(pos) {
‚ãÆ----
if ctx.input(|i| i.key_pressed(egui::Key::Escape)) {
‚ãÆ----
pub(crate) fn render_main_layout(&mut self, ctx: &egui::Context) {
‚ãÆ----
egui::CentralPanel::default().show(ctx, |ui| {
let available_width = ui.available_width();
‚ãÆ----
ui.allocate_ui_with_layout(
egui::vec2(left_width, ui.available_height()),
‚ãÆ----
if render_sidebar(ui, &mut self.config, &mut self.view_mode, &text) {
self.save_and_sync();
‚ãÆ----
ui.add_space(10.0);
‚ãÆ----
egui::vec2(right_width - 20.0, ui.available_height()),
‚ãÆ----
let app = self.app_state_ref.lock().unwrap();
app.model_usage_stats.clone()
‚ãÆ----
if render_global_settings(
‚ãÆ----
app.history.clone()
‚ãÆ----
if render_history_panel(
‚ãÆ----
if self.last_edited_preset_idx != Some(idx) {
if idx < self.config.presets.len() {
self.snarl = Some(blocks_to_snarl(
‚ãÆ----
self.last_edited_preset_idx = Some(idx);
‚ãÆ----
if render_preset_editor(
‚ãÆ----
let (blocks, connections) = snarl_to_graph(snarl);
‚ãÆ----
pub(crate) fn render_fade_overlay(&mut self, ctx: &egui::Context) {
‚ãÆ----
let elapsed = ctx.input(|i| i.time) - start_time;
‚ãÆ----
let rect = ctx.input(|i| {
i.viewport().inner_rect.unwrap_or(egui::Rect::from_min_size(
‚ãÆ----
let painter = ctx.layer_painter(egui::LayerId::new(
‚ãÆ----
painter.rect_filled(
‚ãÆ----
ctx.request_repaint();
‚ãÆ----
pub(crate) fn render_drop_overlay(&mut self, ctx: &egui::Context) {
use super::input_handler::is_files_hovered;
‚ãÆ----
let delta = ctx.input(|i| i.stable_dt).min(0.1);
let is_hovered = is_files_hovered(ctx);
‚ãÆ----
self.drop_overlay_fade = self.drop_overlay_fade.clamp(0.0, 1.0);
‚ãÆ----
let screen_rect = ctx.available_rect();
‚ãÆ----
let painter = ctx.layer_painter(overlay_layer);
‚ãÆ----
painter.rect_filled(screen_rect, 0.0, backdrop_color);
‚ãÆ----
let inner_rect = screen_rect.shrink(inset);
let time = ctx.input(|i| i.time);
let pulse = (time * 2.5).sin() as f32 * 0.2_f32 + 0.8_f32;
‚ãÆ----
let len = vec.length();
‚ãÆ----
let count = (len / (dash_length + gap_length)).ceil() as i32;
‚ãÆ----
let end = if (end - p1).length() > len { p2 } else { end };
painter.line_segment([start, end], stroke);
‚ãÆ----
draw_dashed_line(inner_rect.left_top(), inner_rect.right_top());
draw_dashed_line(inner_rect.right_top(), inner_rect.right_bottom());
draw_dashed_line(inner_rect.right_bottom(), inner_rect.left_bottom());
draw_dashed_line(inner_rect.left_bottom(), inner_rect.left_top());
let center = screen_rect.center();
‚ãÆ----
let bob_offset = (time * 5.0).sin() as f32 * 4.0_f32;
‚ãÆ----
painter.rect_stroke(
‚ãÆ----
painter.line_segment([arrow_start, arrow_end], arrow_stroke);
‚ãÆ----
painter.line_segment(
‚ãÆ----
let galley = painter.layout_no_wrap(
text.drop_overlay_text.to_string(),
‚ãÆ----
painter.galley(
text_pos - egui::vec2(text_rect.width() * 0.5, 0.0),
‚ãÆ----
fn format_tip_with_bold(tip_number: usize, text: &str, is_dark_mode: bool) -> LayoutJob {
‚ãÆ----
let number_text = format!("{}. ", tip_number);
‚ãÆ----
job.append(&number_text, 0.0, text_format.clone());
‚ãÆ----
let mut chars = text.chars().peekable();
‚ãÆ----
while let Some(ch) = chars.next() {
if ch == '*' && chars.peek() == Some(&'*') {
chars.next();
if !current_text.is_empty() {
let mut fmt = text_format.clone();
‚ãÆ----
job.append(&current_text, 0.0, fmt);
current_text.clear();
‚ãÆ----
current_text.push(ch);
</file>

<file path="src/gui/settings_ui/node_graph/body.rs">
use super::node::ChainNode;
‚ãÆ----
use super::viewer::ChainViewer;
‚ãÆ----
use eframe::egui;
‚ãÆ----
pub fn show_body(
‚ãÆ----
.get_node(node_id)
.map(|n| n.id().to_string())
.unwrap_or_default();
‚ãÆ----
let node = snarl.get_node_mut(node_id).unwrap();
ui.vertical(|ui| {
ui.set_max_width(320.0);
‚ãÆ----
ui.set_min_width(173.0);
‚ãÆ----
viewer.preset_type.as_str()
‚ãÆ----
block_type.as_str()
‚ãÆ----
ui.horizontal(|ui| {
‚ãÆ----
if icon_button(ui, icon).clicked() {
‚ãÆ----
"plain".to_string()
‚ãÆ----
"markdown".to_string()
‚ãÆ----
match viewer.ui_language.as_str() {
‚ãÆ----
let popup_id = ui.make_persistent_id(format!(
‚ãÆ----
let btn = ui.add(
‚ãÆ----
.fill(egui::Color32::from_rgba_unmultiplied(
‚ãÆ----
.corner_radius(4.0),
‚ãÆ----
if btn.clicked() {
ui.memory_mut(|mem| mem.toggle_popup(popup_id));
‚ãÆ----
ui.set_min_width(60.0);
let (lbl_norm, lbl_md) = match viewer.ui_language.as_str() {
‚ãÆ----
.selectable_label(render_mode == "plain", lbl_norm)
.clicked()
‚ãÆ----
*render_mode = "plain".to_string();
‚ãÆ----
ui.memory_mut(|mem| mem.close_popup(popup_id));
‚ãÆ----
.selectable_label(render_mode == "markdown", lbl_md)
‚ãÆ----
*render_mode = "markdown".to_string();
‚ãÆ----
let _ = icon_button(ui, Icon::Copy)
.on_hover_text(viewer.text.input_auto_copy_tooltip);
‚ãÆ----
if icon_button(ui, copy_icon)
.on_hover_text(viewer.text.input_auto_copy_tooltip)
‚ãÆ----
if icon_button(ui, speak_icon)
.on_hover_text(viewer.text.input_auto_speak_tooltip)
‚ãÆ----
let target_model_type = match viewer.preset_type.as_str() {
‚ãÆ----
let model_label = match viewer.ui_language.as_str() {
‚ãÆ----
ui.label(model_label);
let model_def = get_model_by_id(model);
‚ãÆ----
.as_ref()
.map(|m| match viewer.ui_language.as_str() {
"vi" => m.name_vi.as_str(),
"ko" => m.name_ko.as_str(),
_ => m.name_en.as_str(),
‚ãÆ----
.unwrap_or(model.as_str());
let button_response = ui.button(display_name);
if button_response.clicked() {
egui::Popup::toggle_id(ui.ctx(), button_response.id);
‚ãÆ----
trigger_ollama_model_scan();
‚ãÆ----
egui::Popup::from_toggle_button_response(&button_response).show(|ui| {
ui.style_mut().wrap_mode = Some(egui::TextWrapMode::Extend);
if viewer.use_ollama && is_ollama_scan_in_progress() {
let loading_text = match viewer.ui_language.as_str() {
‚ãÆ----
ui.label(egui::RichText::new(loading_text).weak().italics());
ui.separator();
‚ãÆ----
for m in get_all_models_with_ollama() {
‚ãÆ----
&& viewer.is_provider_enabled(&m.provider)
‚ãÆ----
let name = match viewer.ui_language.as_str() {
‚ãÆ----
let quota = match viewer.ui_language.as_str() {
‚ãÆ----
let search_icon = if model_supports_search(&m.id) {
‚ãÆ----
let label = format!(
‚ãÆ----
if ui.selectable_label(is_selected, label).clicked() {
*model = m.id.clone();
‚ãÆ----
egui::Popup::toggle_id(ui.ctx(), popup_layer_id);
‚ãÆ----
// Only show prompt UI for LLM models (not QR scanner, GTX, Whisper, etc.)
if !model_is_non_llm(model) {
// Row 2: Prompt Label + Add Tag Button
‚ãÆ----
let prompt_label = match viewer.ui_language.as_str() {
‚ãÆ----
ui.label(prompt_label);
let btn_label = match viewer.ui_language.as_str() {
‚ãÆ----
let is_dark = ui.visuals().dark_mode;
‚ãÆ----
.add(
‚ãÆ----
.small()
.color(egui::Color32::WHITE),
‚ãÆ----
.fill(lang_btn_bg)
.corner_radius(8.0),
‚ãÆ----
insert_next_language_tag(prompt, language_vars);
‚ãÆ----
.desired_width(152.0)
.desired_rows(2),
‚ãÆ----
.changed()
‚ãÆ----
show_language_vars(
‚ãÆ----
match (render_mode.as_str(), *streaming_enabled) {
("markdown", _) => match viewer.ui_language.as_str() {
‚ãÆ----
(_, true) => match viewer.ui_language.as_str() {
‚ãÆ----
(_, false) => match viewer.ui_language.as_str() {
‚ãÆ----
.make_persistent_id(format!("render_mode_popup_{:?}", node_id));
‚ãÆ----
.selectable_label(
‚ãÆ----
*render_mode = "stream".to_string();
‚ãÆ----
// Only show prompt UI for LLM models (not GTX, etc.)
‚ãÆ----
for node in snarl.nodes_mut() {
if node.id() != current_node_uuid {
node.set_auto_copy(false);
</file>

<file path="src/gui/settings_ui/node_graph/utils.rs">
use crate::config::get_all_languages;
use crate::model_config::model_supports_search_by_id;
use eframe::egui;
use std::collections::HashMap;
pub fn model_supports_search(model_id: &str) -> bool {
model_supports_search_by_id(model_id)
‚ãÆ----
pub fn request_node_graph_view_reset(ctx: &egui::Context) {
‚ãÆ----
ctx.data_mut(|d| d.insert_temp(reset_id, true));
‚ãÆ----
pub fn show_language_vars(
‚ãÆ----
let tag = format!("{{language{}}}", k);
if prompt.contains(&tag) {
detected_vars.push(k);
‚ãÆ----
let key = format!("language{}", num);
if !language_vars.contains_key(&key) {
language_vars.insert(key.clone(), "Vietnamese".to_string());
‚ãÆ----
let label = format!("{{language{}}}:", num);
ui.horizontal(|ui| {
ui.label(label);
let current_val = language_vars.get(&key).cloned().unwrap_or_default();
let search_id = egui::Id::new(format!("lang_search_{}", num));
let is_dark = ui.visuals().dark_mode;
‚ãÆ----
let button_response = ui.add(
egui::Button::new(egui::RichText::new(&current_val).color(egui::Color32::WHITE))
.fill(lang_var_bg)
.corner_radius(8.0),
‚ãÆ----
if button_response.clicked() {
egui::Popup::toggle_id(ui.ctx(), button_response.id);
‚ãÆ----
.close_behavior(egui::PopupCloseBehavior::CloseOnClickOutside)
.show(|ui| {
ui.set_min_width(120.0);
‚ãÆ----
ui.data_mut(|d| d.get_temp(search_id).unwrap_or_default());
let _search_response = ui.add(
‚ãÆ----
.hint_text("Search...")
.desired_width(110.0),
‚ãÆ----
ui.data_mut(|d| d.insert_temp(search_id, search_text.clone()));
ui.separator();
‚ãÆ----
.max_height(200.0)
.min_scrolled_height(200.0)
.auto_shrink([true, false])
.show(ui, |ui| {
ui.set_width(120.0);
for lang in get_all_languages() {
let matches_search = search_text.is_empty()
|| lang.to_lowercase().contains(&search_text.to_lowercase());
‚ãÆ----
if ui.selectable_label(is_selected, lang).clicked() {
language_vars.insert(key.clone(), lang.clone());
‚ãÆ----
ui.data_mut(|d| {
‚ãÆ----
egui::Popup::toggle_id(ui.ctx(), popup_layer_id);
‚ãÆ----
pub fn insert_next_language_tag(prompt: &mut String, language_vars: &mut HashMap<String, String>) {
‚ãÆ----
if prompt.contains(&format!("{{language{}}}", k)) {
‚ãÆ----
let tag = format!(" {{language{}}} ", next_num);
prompt.push_str(&tag);
let key = format!("language{}", next_num);
‚ãÆ----
language_vars.insert(key, "Vietnamese".to_string());
</file>

<file path="src/overlay/favorite_bubble/window.rs">
use super::render::update_bubble_visual;
‚ãÆ----
use crate::APP;
use std::sync::atomic::Ordering;
use windows::core::w;
‚ãÆ----
use windows::Win32::System::LibraryLoader::GetModuleHandleW;
‚ãÆ----
pub fn show_favorite_bubble() {
if BUBBLE_ACTIVE.swap(true, Ordering::SeqCst) {
‚ãÆ----
CURRENT_OPACITY.store(0, Ordering::SeqCst);
FADE_OUT_STATE.store(false, Ordering::SeqCst);
‚ãÆ----
create_bubble_window();
‚ãÆ----
pub fn hide_favorite_bubble() {
if !BUBBLE_ACTIVE.load(Ordering::SeqCst) {
‚ãÆ----
let hwnd_val = BUBBLE_HWND.load(Ordering::SeqCst);
‚ãÆ----
FADE_OUT_STATE.store(true, Ordering::SeqCst);
let hwnd = HWND(hwnd_val as *mut std::ffi::c_void);
‚ãÆ----
let _ = SetTimer(Some(hwnd), OPACITY_TIMER_ID, 16, None);
‚ãÆ----
pub fn trigger_blink_animation() {
‚ãÆ----
BLINK_STATE.store(1, Ordering::SeqCst);
‚ãÆ----
fn create_bubble_window() {
‚ãÆ----
let instance = GetModuleHandleW(None).unwrap_or_default();
let class_name = w!("SGTFavoriteBubble");
REGISTER_BUBBLE_CLASS.call_once(|| {
‚ãÆ----
lpfnWndProc: Some(bubble_wnd_proc),
hInstance: instance.into(),
‚ãÆ----
hCursor: LoadCursorW(None, IDC_HAND).unwrap_or_default(),
‚ãÆ----
RegisterClassW(&wc);
‚ãÆ----
let (initial_x, initial_y) = if let Ok(app) = APP.lock() {
app.config.favorite_bubble_position.unwrap_or_else(|| {
let screen_w = GetSystemMetrics(SM_CXSCREEN);
let screen_h = GetSystemMetrics(SM_CYSCREEN);
‚ãÆ----
let hwnd = CreateWindowExW(
‚ãÆ----
w!("FavBubble"),
‚ãÆ----
Some(instance.into()),
‚ãÆ----
.unwrap_or_default();
if hwnd.is_invalid() {
BUBBLE_ACTIVE.store(false, Ordering::SeqCst);
‚ãÆ----
BUBBLE_HWND.store(hwnd.0 as isize, Ordering::SeqCst);
update_bubble_visual(hwnd);
let _ = ShowWindow(hwnd, SW_SHOWNOACTIVATE);
‚ãÆ----
ensure_panel_created(hwnd, true);
‚ãÆ----
while GetMessageW(&mut msg, None, 0, 0).into() {
let _ = TranslateMessage(&msg);
DispatchMessageW(&msg);
‚ãÆ----
destroy_panel();
‚ãÆ----
BUBBLE_HWND.store(0, Ordering::SeqCst);
‚ãÆ----
unsafe extern "system" fn bubble_wnd_proc(
‚ãÆ----
let _ = KillTimer(Some(hwnd), PHYSICS_TIMER_ID);
PHYSICS_STATE.with(|p| *p.borrow_mut() = (0.0, 0.0));
IS_DRAGGING.store(true, Ordering::SeqCst);
IS_DRAGGING_MOVED.store(false, Ordering::SeqCst);
‚ãÆ----
DRAG_START_X.store(x as isize, Ordering::SeqCst);
DRAG_START_Y.store(y as isize, Ordering::SeqCst);
let _ = SetCapture(hwnd);
LRESULT(0)
‚ãÆ----
let was_dragging_moved = IS_DRAGGING_MOVED.load(Ordering::SeqCst);
IS_DRAGGING.store(false, Ordering::SeqCst);
let _ = ReleaseCapture();
‚ãÆ----
if IS_EXPANDED.load(Ordering::SeqCst) {
close_panel();
‚ãÆ----
show_panel(hwnd);
‚ãÆ----
let _ = SetTimer(Some(hwnd), PHYSICS_TIMER_ID, 16, None);
‚ãÆ----
if IS_DRAGGING.load(Ordering::SeqCst) && (wparam.0 & 0x0001) != 0 {
‚ãÆ----
if !IS_DRAGGING_MOVED.load(Ordering::SeqCst) {
let start_x = DRAG_START_X.load(Ordering::SeqCst) as i32;
let start_y = DRAG_START_Y.load(Ordering::SeqCst) as i32;
let dx = (x - start_x).abs();
let dy = (y - start_y).abs();
‚ãÆ----
IS_DRAGGING_MOVED.store(true, Ordering::SeqCst);
‚ãÆ----
if IS_DRAGGING_MOVED.load(Ordering::SeqCst) {
‚ãÆ----
let _ = GetWindowRect(hwnd, &mut rect);
‚ãÆ----
let _ = SystemParametersInfoW(
‚ãÆ----
Some(&mut work_area as *mut _ as *mut std::ffi::c_void),
SYSTEM_PARAMETERS_INFO_UPDATE_FLAGS(0),
‚ãÆ----
.clamp(work_area.left, work_area.right - BUBBLE_SIZE);
‚ãÆ----
.clamp(work_area.top, work_area.bottom - BUBBLE_SIZE);
‚ãÆ----
PHYSICS_STATE.with(|p| {
let (old_vx, old_vy) = *p.borrow();
‚ãÆ----
*p.borrow_mut() = (final_vx, final_vy);
‚ãÆ----
let _ = SetWindowPos(
‚ãÆ----
move_panel_to_bubble(new_x, new_y);
‚ãÆ----
if !IS_HOVERED.load(Ordering::SeqCst) {
IS_HOVERED.store(true, Ordering::SeqCst);
‚ãÆ----
let _ = TrackMouseEvent(&mut tme);
‚ãÆ----
IS_HOVERED.store(false, Ordering::SeqCst);
‚ãÆ----
let is_hovered = IS_HOVERED.load(Ordering::SeqCst);
let is_expanded = IS_EXPANDED.load(Ordering::SeqCst);
let blink_state = BLINK_STATE.load(Ordering::SeqCst);
let is_fading_out = FADE_OUT_STATE.load(Ordering::SeqCst);
‚ãÆ----
let current = CURRENT_OPACITY.load(Ordering::SeqCst);
‚ãÆ----
(current as u16 + step as u16).min(target as u16) as u8
‚ãÆ----
(current as i16 - step as i16).max(target as i16) as u8
‚ãÆ----
CURRENT_OPACITY.store(new_opacity, Ordering::SeqCst);
‚ãÆ----
let _ = KillTimer(Some(hwnd), OPACITY_TIMER_ID);
‚ãÆ----
let _ = PostMessageW(Some(hwnd), WM_CLOSE, WPARAM(0), LPARAM(0));
‚ãÆ----
BLINK_STATE.store(0, Ordering::SeqCst);
‚ãÆ----
BLINK_STATE.fetch_add(1, Ordering::SeqCst);
‚ãÆ----
let (mut vx, mut vy) = *p.borrow();
‚ãÆ----
if vx.abs() < 0.2 && vy.abs() < 0.2 {
‚ãÆ----
*p.borrow_mut() = (0.0, 0.0);
‚ãÆ----
*p.borrow_mut() = (vx, vy);
‚ãÆ----
move_panel_to_bubble(next_x as i32, next_y as i32);
‚ãÆ----
let _ = DestroyWindow(hwnd);
‚ãÆ----
PostQuitMessage(0);
‚ãÆ----
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
</file>

<file path="src/overlay/html_components/font_manager.rs">
use std::net::TcpListener;
‚ãÆ----
use windows::Win32::Graphics::Gdi::AddFontMemResourceEx;
use wry::WebViewBuilder;
‚ãÆ----
include_bytes!("../../../assets/GoogleSansFlex-VariableFont_GRAD,ROND,opsz,slnt,wdth,wght.ttf");
‚ãÆ----
pub fn warmup_fonts() {
start_font_server();
load_gdi_font();
‚ãÆ----
fn load_gdi_font() {
‚ãÆ----
let len = GOOGLE_SANS_FLEX_TTF.len() as u32;
let handle = AddFontMemResourceEx(
GOOGLE_SANS_FLEX_TTF.as_ptr() as *mut _,
‚ãÆ----
if handle.is_invalid() {
eprintln!("Failed to load Google Sans Flex into GDI");
‚ãÆ----
pub fn configure_webview(builder: WebViewBuilder) -> WebViewBuilder {
‚ãÆ----
fn start_font_server() {
INIT_FONTS.call_once(|| {
‚ãÆ----
eprintln!("Failed to bind font server: {}", e);
‚ãÆ----
let addr = listener.local_addr().unwrap();
let url = format!("http://{}:{}/GoogleSansFlex.ttf", addr.ip(), addr.port());
‚ãÆ----
let mut url_guard = FONT_SERVER_URL.lock().unwrap();
*url_guard = Some(url);
‚ãÆ----
for stream in listener.incoming() {
‚ãÆ----
match stream.read(&mut buffer[bytes_read..]) {
‚ãÆ----
if bytes_read == buffer.len()
‚ãÆ----
.windows(4)
.any(|w| w == b"\r\n\r\n")
‚ãÆ----
let is_head = request_str.starts_with("HEAD");
let response_header = format!(
‚ãÆ----
if stream.write_all(response_header.as_bytes()).is_err() {
‚ãÆ----
if let Err(e) = stream.write_all(GOOGLE_SANS_FLEX_TTF) {
if e.raw_os_error() != Some(10053) {
eprintln!("Font server body error: {}", e);
‚ãÆ----
let _ = stream.flush();
‚ãÆ----
Err(e) => eprintln!("Font server request error: {}", e),
‚ãÆ----
pub fn get_font_css() -> String {
‚ãÆ----
if let Ok(guard) = FONT_SERVER_URL.lock() {
if let Some(url) = guard.as_ref() {
font_url = url.clone();
‚ãÆ----
if font_url.is_empty() {
eprintln!("ERROR: Could not get font server URL");
‚ãÆ----
format!(
</file>

<file path="src/overlay/process/pipeline.rs">
use crate::win_types::SendHwnd;
‚ãÆ----
use crate::overlay::preset_wheel;
‚ãÆ----
use crate::overlay::text_input;
‚ãÆ----
use super::types::reset_window_position_queue;
use super::window::create_processing_window;
pub fn start_text_processing(
‚ãÆ----
.first()
.map(|b| b.prompt.as_str())
.unwrap_or("");
let guide_text = if first_block_prompt.is_empty() {
‚ãÆ----
format!("{}...", localized_preset_name)
‚ãÆ----
let config_shared = Arc::new(config.clone());
let preset_shared = Arc::new(preset.clone());
let ui_lang = config.ui_language.clone();
// For MASTER presets: always keep window open initially (continuous_mode=true)
// We'll decide whether to close based on the SELECTED preset after wheel selection
‚ãÆ----
// For continuous mode: store the previous chain's cancellation token so we can close old windows
‚ãÆ----
let last_cancel_token_clone = last_cancel_token.clone();
// Check if this is a MASTER preset
‚ãÆ----
// CRITICAL: For MASTER presets, store the selected preset index after first wheel selection.
// Subsequent Enter presses will use this stored preset directly (no wheel).
// The text input window "transfers" to the selected preset.
‚ãÆ----
let selected_preset_idx_clone = selected_preset_idx.clone();
‚ãÆ----
let already_selected = selected_preset_idx_clone.lock().unwrap().clone();
‚ãÆ----
let app = crate::APP.lock().unwrap();
let p = app.config.presets[preset_idx].clone();
let c = app.config.clone();
‚ãÆ----
let _ = GetCursorPos(&mut cursor_pos);
‚ãÆ----
preset_wheel::show_preset_wheel("text", Some("type"), cursor_pos);
‚ãÆ----
*selected_preset_idx_clone.lock().unwrap() = Some(idx);
‚ãÆ----
let mut app = crate::APP.lock().unwrap();
‚ãÆ----
let p = app.config.presets[idx].clone();
‚ãÆ----
.map(|h| h.name.clone())
.unwrap_or_default();
let new_guide_text = if !hk_name.is_empty() {
format!("{} [{}]", localized_name, hk_name)
‚ãÆ----
(*preset_shared).clone(),
(*config_shared).clone(),
‚ãÆ----
let _ = PostMessageW(Some(input_hwnd), WM_CLOSE, WPARAM(0), LPARAM(0));
‚ãÆ----
if let Ok(token_guard) = last_cancel_token_clone.lock() {
‚ãÆ----
let last_token_update = last_cancel_token_clone.clone();
‚ãÆ----
if let Ok(mut token_guard) = last_token_update.lock() {
*token_guard = Some(new_token.clone());
‚ãÆ----
execute_chain_pipeline_with_token(
‚ãÆ----
let guide_text = localized_preset_name.clone();
‚ãÆ----
let mut modified_preset = (*preset).clone();
if let Some(block0) = modified_preset.blocks.get_mut(0) {
if block0.prompt.is_empty() {
block0.prompt = user_prompt.clone();
‚ãÆ----
format!("{}\n\nUser request: {}", block0.prompt, user_prompt);
‚ãÆ----
let config_clone = (*config).clone();
let initial_text_clone = (*initial_text).clone();
‚ãÆ----
execute_chain_pipeline(
‚ãÆ----
pub fn show_audio_result(
‚ãÆ----
app.config.clone()
‚ãÆ----
windows::Win32::UI::WindowsAndMessaging::IsWindow(Some(recording_hwnd)).as_bool()
‚ãÆ----
Some(recording_hwnd)
‚ãÆ----
reset_window_position_queue();
run_chain_step(
‚ãÆ----
preset.blocks.clone(),
preset.block_connections.clone(),
‚ãÆ----
processing_hwnd.map(SendHwnd),
‚ãÆ----
preset.id.clone(),
‚ãÆ----
pub fn start_processing_pipeline(
‚ãÆ----
if preset.prompt_mode == "dynamic" && !preset.blocks.is_empty() {
‚ãÆ----
let _ = cropped_img.write_to(
‚ãÆ----
let guide_text = format!("{}...", localized_name);
‚ãÆ----
.iter_mut()
.find(|b| b.block_type != "input_adapter")
‚ãÆ----
if target_block.prompt.is_empty() {
target_block.prompt = user_prompt.clone();
‚ãÆ----
format!("{}\n\nUser request: {}", target_block.prompt, user_prompt);
‚ãÆ----
let context = RefineContext::Image((*png_data).clone());
‚ãÆ----
let graphics_mode = config_clone.graphics_mode.clone();
‚ãÆ----
unsafe { create_processing_window(screen_rect, graphics_mode) };
‚ãÆ----
SendMessageW(processing_hwnd, WM_TIMER, Some(WPARAM(1)), Some(LPARAM(0)));
‚ãÆ----
let blocks = modified_preset.blocks.clone();
let connections = modified_preset.block_connections.clone();
let preset_id = modified_preset.id.clone();
let processing_hwnd_send = SendHwnd(processing_hwnd);
‚ãÆ----
Some(processing_hwnd_send),
‚ãÆ----
while GetMessageW(&mut msg, None, 0, 0).into() {
let _ = TranslateMessage(&msg);
DispatchMessageW(&msg);
if !IsWindow(Some(processing_hwnd)).as_bool() {
‚ãÆ----
let graphics_mode = config.graphics_mode.clone();
let processing_hwnd = unsafe { create_processing_window(screen_rect, graphics_mode) };
‚ãÆ----
let _ = SendMessageW(processing_hwnd, WM_TIMER, Some(WPARAM(1)), Some(LPARAM(0)));
‚ãÆ----
let conf_clone = config.clone();
let blocks = preset.blocks.clone();
let connections = preset.block_connections.clone();
let preset_id = preset.id.clone();
‚ãÆ----
let processing_hwnd = HWND(processing_hwnd_val as *mut std::ffi::c_void);
‚ãÆ----
Some(SendHwnd(processing_hwnd)),
‚ãÆ----
pub fn start_processing_pipeline_parallel(
‚ãÆ----
if let Ok(Some((img, _))) = rx.recv() {
start_processing_pipeline(img, screen_rect, config, preset);
‚ãÆ----
if let Ok(Some((_cropped_img, original_bytes))) = rx.recv() {
‚ãÆ----
let _ = PostMessageW(Some(processing_hwnd), WM_CLOSE, WPARAM(0), LPARAM(0));
</file>

<file path="src/overlay/realtime_webview/manager.rs">
use crate::APP;
use std::sync::atomic::Ordering;
use windows::core::w;
‚ãÆ----
use windows::Win32::Graphics::Gdi::HBRUSH;
use windows::Win32::System::LibraryLoader::GetModuleHandleW;
‚ãÆ----
pub fn is_realtime_overlay_active() -> bool {
unsafe { IS_ACTIVE && !std::ptr::addr_of!(REALTIME_HWND).read().is_invalid() }
‚ãÆ----
pub fn stop_realtime_overlay() {
crate::api::tts::TTS_MANAGER.stop();
crate::overlay::realtime_egui::MINIMAL_ACTIVE.store(false, std::sync::atomic::Ordering::SeqCst);
REALTIME_STOP_SIGNAL.store(true, Ordering::SeqCst);
‚ãÆ----
let popup_val = APP_SELECTION_HWND.load(std::sync::atomic::Ordering::SeqCst);
‚ãÆ----
let popup_hwnd = HWND(popup_val as *mut std::ffi::c_void);
let _ = PostMessageW(Some(popup_hwnd), WM_CLOSE, WPARAM(0), LPARAM(0));
APP_SELECTION_HWND.store(0, std::sync::atomic::Ordering::SeqCst);
‚ãÆ----
if !std::ptr::addr_of!(REALTIME_HWND).read().is_invalid() {
let _ = PostMessageW(
Some(REALTIME_HWND),
‚ãÆ----
WPARAM(0),
LPARAM(0),
‚ãÆ----
pub fn warmup() {
‚ãÆ----
internal_create_realtime_loop();
‚ãÆ----
pub fn show_realtime_overlay(preset_idx: usize) {
‚ãÆ----
let ui_lang = crate::APP.lock().unwrap().config.ui_language.clone();
‚ãÆ----
WPARAM(preset_idx),
‚ãÆ----
unsafe fn internal_create_realtime_loop() {
let instance = GetModuleHandleW(None).unwrap();
let class_name = w!("RealtimeWebViewOverlay");
REGISTER_REALTIME_CLASS.call_once(|| {
‚ãÆ----
wc.lpfnWndProc = Some(realtime_wnd_proc_internal);
wc.hInstance = instance.into();
wc.hCursor = LoadCursorW(None, IDC_ARROW).unwrap();
‚ãÆ----
wc.hbrBackground = HBRUSH(std::ptr::null_mut());
let _ = RegisterClassW(&wc);
‚ãÆ----
let trans_class = w!("RealtimeTranslationWebViewOverlay");
REGISTER_TRANSLATION_CLASS.call_once(|| {
‚ãÆ----
wc.lpfnWndProc = Some(translation_wnd_proc_internal);
‚ãÆ----
let main_hwnd = CreateWindowExW(
‚ãÆ----
w!("Realtime Transcription"),
‚ãÆ----
Some(instance.into()),
‚ãÆ----
.unwrap();
let trans_hwnd = CreateWindowExW(
‚ãÆ----
w!("Translation"),
‚ãÆ----
let _ = DwmSetWindowAttribute(
‚ãÆ----
create_realtime_webview(main_hwnd, false, "mic", "English", "google-gtx", 16);
create_realtime_webview(trans_hwnd, true, "mic", "English", "google-gtx", 16);
‚ãÆ----
while GetMessageW(&mut msg, None, 0, 0).into() {
let _ = TranslateMessage(&msg);
DispatchMessageW(&msg);
‚ãÆ----
destroy_realtime_webview(REALTIME_HWND);
destroy_realtime_webview(TRANSLATION_HWND);
‚ãÆ----
unsafe extern "system" fn realtime_wnd_proc_internal(
‚ãÆ----
handle_start_overlay(preset_idx);
return LRESULT(0);
‚ãÆ----
realtime_wnd_proc(hwnd, msg, wparam, lparam)
‚ãÆ----
unsafe extern "system" fn translation_wnd_proc_internal(
‚ãÆ----
translation_wnd_proc(hwnd, msg, wparam, lparam)
‚ãÆ----
unsafe fn handle_start_overlay(preset_idx: usize) {
‚ãÆ----
let mut preset = APP.lock().unwrap().config.presets[preset_idx].clone();
‚ãÆ----
REALTIME_STOP_SIGNAL.store(false, Ordering::SeqCst);
MIC_VISIBLE.store(true, Ordering::SeqCst);
TRANS_VISIBLE.store(true, Ordering::SeqCst);
AUDIO_SOURCE_CHANGE.store(false, Ordering::SeqCst);
LANGUAGE_CHANGE.store(false, Ordering::SeqCst);
TRANSLATION_MODEL_CHANGE.store(false, Ordering::SeqCst);
‚ãÆ----
let mut state = REALTIME_STATE.lock().unwrap();
‚ãÆ----
let app = APP.lock().unwrap();
‚ãÆ----
app.config.realtime_audio_source.clone(),
app.config.realtime_target_language.clone(),
app.config.realtime_translation_model.clone(),
‚ãÆ----
if !config_audio_source.is_empty() {
preset.audio_source = config_audio_source.clone();
if let Ok(mut new_source) = NEW_AUDIO_SOURCE.lock() {
*new_source = config_audio_source.clone();
‚ãÆ----
let target_language = if !config_language.is_empty() {
‚ãÆ----
} else if preset.blocks.len() > 1 {
‚ãÆ----
if !trans_block.selected_language.is_empty() {
trans_block.selected_language.clone()
‚ãÆ----
.get("language")
.cloned()
.or_else(|| trans_block.language_vars.get("language1").cloned())
.unwrap_or_else(|| "English".to_string())
‚ãÆ----
"English".to_string()
‚ãÆ----
if !target_language.is_empty() {
if let Ok(mut new_lang) = NEW_TARGET_LANGUAGE.lock() {
*new_lang = target_language.clone();
‚ãÆ----
LANGUAGE_CHANGE.store(true, Ordering::SeqCst);
‚ãÆ----
let screen_w = GetSystemMetrics(SM_CXSCREEN);
let screen_h = GetSystemMetrics(SM_CYSCREEN);
let has_translation = preset.blocks.len() > 1;
‚ãÆ----
let _ = SetWindowPos(
‚ãÆ----
Some(HWND_TOPMOST),
‚ãÆ----
let _ = ShowWindow(TRANSLATION_HWND, SW_HIDE);
‚ãÆ----
notify_webview_settings(
‚ãÆ----
resize_webview(REALTIME_HWND, main_w, main_h);
clear_webview_text(REALTIME_HWND);
‚ãÆ----
resize_webview(TRANSLATION_HWND, trans_w, trans_h);
clear_webview_text(TRANSLATION_HWND);
‚ãÆ----
sync_visibility_to_webviews();
‚ãÆ----
Some(TRANSLATION_HWND)
‚ãÆ----
start_realtime_transcription(
‚ãÆ----
REALTIME_STOP_SIGNAL.clone(),
‚ãÆ----
REALTIME_STATE.clone(),
‚ãÆ----
fn notify_webview_settings(hwnd: HWND, source: &str, lang: &str, model: &str, font_size: u32) {
‚ãÆ----
let script = format!(
‚ãÆ----
REALTIME_WEBVIEWS.with(|wvs| {
if let Some(webview) = wvs.borrow().get(&hwnd_key) {
let _ = webview.evaluate_script(&script);
‚ãÆ----
fn resize_webview(hwnd: HWND, width: i32, height: i32) {
‚ãÆ----
let _ = webview.set_bounds(wry::Rect {
</file>

<file path="src/overlay/favorite_bubble/state.rs">
use std::cell::RefCell;
‚ãÆ----
thread_local! {
‚ãÆ----
const ICON_PNG_BYTES: &[u8] = include_bytes!("../../../assets/app-icon-small.png");
const ICON_LIGHT_PNG_BYTES: &[u8] = include_bytes!("../../../assets/app-icon-small-light.png");
‚ãÆ----
fn decode_icon(bytes: &[u8]) -> Vec<u8> {
‚ãÆ----
let resized = img.resize_exact(
‚ãÆ----
resized.to_rgba8().into_raw()
‚ãÆ----
vec![]
</file>

<file path="src/overlay/result/refine_input.rs">
use std::collections::HashMap;
use std::num::NonZeroIsize;
use std::sync::Mutex;
use windows::core::w;
‚ãÆ----
struct RefineInputState {
‚ãÆ----
unsafe impl Send for RefineInputState {}
thread_local! {
‚ãÆ----
struct HwndWrapper(HWND);
impl HasWindowHandle for HwndWrapper {
fn window_handle(&self) -> Result<WindowHandle<'_>, HandleError> {
‚ãÆ----
Ok(unsafe { WindowHandle::borrow_raw(raw) })
‚ãÆ----
Err(HandleError::Unavailable)
‚ãÆ----
/// Window procedure for the refine input child window
unsafe extern "system" fn refine_wnd_proc(
‚ãÆ----
unsafe extern "system" fn refine_wnd_proc(
‚ãÆ----
// Apply pending text from cross-thread call
apply_pending_text();
LRESULT(0)
‚ãÆ----
// Apply history text replacement from cross-thread call
apply_history_text();
‚ãÆ----
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
‚ãÆ----
/// Internal function to apply pending text (insert at cursor position)
fn apply_pending_text() {
‚ãÆ----
fn apply_pending_text() {
let pending = PENDING_TEXT.lock().unwrap().take();
‚ãÆ----
.replace('\\', "\\\\")
.replace('`', "\\`")
.replace("${", "\\${")
.replace('\n', " ") // Refine input is single line
.replace('\r', "");
REFINE_WEBVIEWS.with(|webviews| {
if let Some(wv) = webviews.borrow().get(&parent_key) {
// Insert at cursor position instead of replacing all text
let script = format!(
‚ãÆ----
let _ = wv.evaluate_script(&script);
‚ãÆ----
/// Internal function to apply history text (replace all content)
fn apply_history_text() {
‚ãÆ----
fn apply_history_text() {
let pending = PENDING_HISTORY_TEXT.lock().unwrap().take();
‚ãÆ----
.replace('\n', " ")
‚ãÆ----
// Replace all text (for history navigation)
‚ãÆ----
/// CSS for the compact refine input
const REFINE_CSS: &str = r#"
‚ãÆ----
/// Generate HTML for the refine input
fn get_refine_html(placeholder: &str) -> String {
‚ãÆ----
fn get_refine_html(placeholder: &str) -> String {
‚ãÆ----
let escaped = placeholder.replace('\'', "\\'");
format!(
‚ãÆ----
/// Show the refine input above the markdown view
/// Returns the child window handle for positioning
‚ãÆ----
/// Returns the child window handle for positioning
pub fn show_refine_input(parent_hwnd: HWND, placeholder: &str) -> bool {
‚ãÆ----
pub fn show_refine_input(parent_hwnd: HWND, placeholder: &str) -> bool {
‚ãÆ----
// Check if already exists
let exists = REFINE_WEBVIEWS.with(|webviews| webviews.borrow().contains_key(&parent_key));
‚ãÆ----
// Just focus existing
focus_refine_input(parent_hwnd);
‚ãÆ----
let _ = GetClientRect(parent_hwnd, &mut parent_rect);
‚ãÆ----
let width = parent_rect.right - 4; // 2px margin each side
// Create the child window for the WebView
let instance = GetModuleHandleW(None).unwrap();
// Use a simple static child window class
‚ãÆ----
let class_name = w!("SGT_RefineInput");
‚ãÆ----
wc.lpfnWndProc = Some(refine_wnd_proc);
wc.hInstance = instance.into();
‚ãÆ----
CLASS_ATOM = RegisterClassW(&wc);
‚ãÆ----
let child_hwnd = CreateWindowExW(
‚ãÆ----
w!("SGT_RefineInput"),
w!(""),
‚ãÆ----
input_height, // Position at top with small margin
Some(parent_hwnd),
‚ãÆ----
Some(instance.into()),
‚ãÆ----
if child_hwnd.is_err() {
‚ãÆ----
// Create WebView inside the child window
let html = get_refine_html(placeholder);
let child_hwnd = child_hwnd.unwrap();
let wrapper = HwndWrapper(child_hwnd);
// Initialize shared WebContext if needed (uses same data dir as other modules)
REFINE_WEB_CONTEXT.with(|ctx| {
if ctx.borrow().is_none() {
‚ãÆ----
*ctx.borrow_mut() = Some(WebContext::new(Some(shared_data_dir)));
‚ãÆ----
let result = REFINE_WEB_CONTEXT.with(|ctx| {
let mut ctx_ref = ctx.borrow_mut();
let builder = if let Some(web_ctx) = ctx_ref.as_mut() {
‚ãÆ----
.with_bounds(Rect {
‚ãÆ----
.with_html(&html)
.with_transparent(false)
.with_ipc_handler(move |msg: wry::http::Request<String>| {
let body = msg.body();
let mut states = REFINE_STATES.lock().unwrap();
if let Some(state) = states.get_mut(&parent_key_for_ipc) {
if body.starts_with("submit:") {
let text = body.strip_prefix("submit:").unwrap_or("").to_string();
// Save to history before submitting
‚ãÆ----
} else if body.starts_with("history_up:") {
let current = body.strip_prefix("history_up:").unwrap_or("");
‚ãÆ----
// Get the child window handle for posting message
‚ãÆ----
drop(states); // Release lock before posting
*PENDING_HISTORY_TEXT.lock().unwrap() =
Some((parent_key_for_ipc, text));
let _ = PostMessageW(
Some(child_hwnd),
‚ãÆ----
WPARAM(0),
LPARAM(0),
‚ãÆ----
} else if body.starts_with("history_down:") {
let current = body.strip_prefix("history_down:").unwrap_or("");
‚ãÆ----
drop(states);
‚ãÆ----
let app = crate::APP.lock().unwrap();
‚ãÆ----
.iter()
.position(|p| p.id == "preset_transcribe")
‚ãÆ----
.build_as_child(&wrapper)
‚ãÆ----
webviews.borrow_mut().insert(parent_key, webview);
‚ãÆ----
states.insert(
‚ãÆ----
let _ = DestroyWindow(child_hwnd);
‚ãÆ----
pub fn focus_refine_input(parent_hwnd: HWND) {
‚ãÆ----
let _ = SetForegroundWindow(parent_hwnd);
‚ãÆ----
if let Some(webview) = webviews.borrow().get(&parent_key) {
let _ = webview.focus();
let _ = webview.evaluate_script("document.getElementById('editor').focus();");
‚ãÆ----
pub fn poll_refine_input(parent_hwnd: HWND) -> (bool, bool, String) {
‚ãÆ----
if let Some(state) = states.get_mut(&parent_key) {
let result = (state.submitted, state.cancelled, state.text.clone());
‚ãÆ----
state.text.clear();
‚ãÆ----
pub fn hide_refine_input(parent_hwnd: HWND) {
‚ãÆ----
webviews.borrow_mut().remove(&parent_key);
‚ãÆ----
if let Some(state) = states.remove(&parent_key) {
‚ãÆ----
let _ = DestroyWindow(state.hwnd);
‚ãÆ----
pub fn is_refine_input_active(parent_hwnd: HWND) -> bool {
‚ãÆ----
let states = REFINE_STATES.lock().unwrap();
states.contains_key(&parent_key)
‚ãÆ----
pub fn bring_to_top(parent_hwnd: HWND) {
‚ãÆ----
if let Some(state) = states.get(&parent_key) {
‚ãÆ----
let _ = SetWindowPos(
‚ãÆ----
Some(HWND_TOP),
‚ãÆ----
pub fn is_any_refine_active() -> bool {
‚ãÆ----
!states.is_empty()
‚ãÆ----
pub fn get_active_refine_parent() -> Option<HWND> {
‚ãÆ----
.keys()
.next()
.map(|&k| HWND(k as *mut std::ffi::c_void))
‚ãÆ----
pub fn set_refine_text(parent_hwnd: HWND, text: &str) {
‚ãÆ----
states.get(&parent_key).map(|s| s.hwnd)
‚ãÆ----
*PENDING_TEXT.lock().unwrap() = Some((parent_key, text.to_string()));
‚ãÆ----
let _ = PostMessageW(Some(hwnd), WM_APP_SET_TEXT, WPARAM(0), LPARAM(0));
‚ãÆ----
pub fn resize_refine_input(parent_hwnd: HWND) {
‚ãÆ----
Some(HWND::default()),
‚ãÆ----
let _ = webview.set_bounds(Rect {
</file>

<file path="src/overlay/selection.rs">
use super::process::start_processing_pipeline;
‚ãÆ----
use std::sync::Arc;
‚ãÆ----
type MagInitializeFn = unsafe extern "system" fn() -> BOOL;
type MagUninitializeFn = unsafe extern "system" fn() -> BOOL;
type MagSetFullscreenTransformFn = unsafe extern "system" fn(f32, i32, i32) -> BOOL;
static mut MAG_DLL: HMODULE = HMODULE(std::ptr::null_mut());
‚ãÆ----
static mut SELECTION_OVERLAY_HWND: SendHwnd = SendHwnd(HWND(std::ptr::null_mut()));
‚ãÆ----
static mut SELECTION_HOOK: HHOOK = HHOOK(std::ptr::null_mut());
static mut CACHED_BITMAP: SendHbitmap = SendHbitmap(HBITMAP(std::ptr::null_mut()));
‚ãÆ----
unsafe fn load_magnification_api() -> bool {
let mag_dll = std::ptr::addr_of!(MAG_DLL).read();
if !mag_dll.is_invalid() {
‚ãÆ----
let dll_name = w!("Magnification.dll");
let dll = LoadLibraryW(dll_name);
‚ãÆ----
if let Some(init) = GetProcAddress(h, s!("MagInitialize")) {
MAG_INITIALIZE = Some(std::mem::transmute(init));
‚ãÆ----
if let Some(uninit) = GetProcAddress(h, s!("MagUninitialize")) {
MAG_UNINITIALIZE = Some(std::mem::transmute(uninit));
‚ãÆ----
if let Some(transform) = GetProcAddress(h, s!("MagSetFullscreenTransform")) {
MAG_SET_FULLSCREEN_TRANSFORM = Some(std::mem::transmute(transform));
‚ãÆ----
let init_ptr = std::ptr::addr_of!(MAG_INITIALIZE).read();
let trans_ptr = std::ptr::addr_of!(MAG_SET_FULLSCREEN_TRANSFORM).read();
return init_ptr.is_some() && trans_ptr.is_some();
‚ãÆ----
unsafe fn extract_crop_from_hbitmap(
‚ãÆ----
let hdc_screen = GetDC(None);
let hdc_mem = CreateCompatibleDC(Some(hdc_screen));
let old_obj = SelectObject(hdc_mem, capture.hbitmap.into());
let w = (crop_rect.right - crop_rect.left).abs();
let h = (crop_rect.bottom - crop_rect.top).abs();
‚ãÆ----
let mut buffer: Vec<u8> = vec![0; (w * h * 4) as usize];
let hdc_temp = CreateCompatibleDC(Some(hdc_screen));
let hbm_temp = CreateCompatibleBitmap(hdc_screen, w, h);
SelectObject(hdc_temp, hbm_temp.into());
let v_x = GetSystemMetrics(SM_XVIRTUALSCREEN);
let v_y = GetSystemMetrics(SM_YVIRTUALSCREEN);
‚ãÆ----
let _ = BitBlt(hdc_temp, 0, 0, w, h, Some(hdc_mem), src_x, src_y, SRCCOPY).ok();
GetDIBits(
‚ãÆ----
Some(buffer.as_mut_ptr() as *mut _),
‚ãÆ----
for chunk in buffer.chunks_exact_mut(4) {
chunk.swap(0, 2);
‚ãÆ----
let _ = DeleteObject(hbm_temp.into());
let _ = DeleteDC(hdc_temp);
SelectObject(hdc_mem, old_obj);
let _ = DeleteDC(hdc_mem);
ReleaseDC(None, hdc_screen);
image::ImageBuffer::from_raw(w as u32, h as u32, buffer).unwrap()
‚ãÆ----
pub fn is_selection_overlay_active_and_dismiss() -> bool {
‚ãÆ----
.read()
.is_invalid()
‚ãÆ----
let _ = PostMessageW(
Some(SELECTION_OVERLAY_HWND.0),
‚ãÆ----
WPARAM(0),
LPARAM(0),
‚ãÆ----
pub fn show_selection_overlay(preset_idx: usize) {
‚ãÆ----
SELECTION_ABORT_SIGNAL.store(false, Ordering::SeqCst);
let instance = GetModuleHandleW(None).unwrap();
let class_name = w!("SnippingOverlay");
‚ãÆ----
if !GetClassInfoW(Some(instance.into()), class_name, &mut wc).is_ok() {
wc.lpfnWndProc = Some(selection_wnd_proc);
wc.hInstance = instance.into();
wc.hCursor = LoadCursorW(None, IDC_CROSS).unwrap();
‚ãÆ----
wc.hbrBackground = CreateSolidBrush(COLORREF(0x00000000));
RegisterClassW(&wc);
‚ãÆ----
let x = GetSystemMetrics(SM_XVIRTUALSCREEN);
let y = GetSystemMetrics(SM_YVIRTUALSCREEN);
let w = GetSystemMetrics(SM_CXVIRTUALSCREEN);
let h = GetSystemMetrics(SM_CYVIRTUALSCREEN);
let hwnd = CreateWindowExW(
‚ãÆ----
w!("Snipping"),
‚ãÆ----
Some(instance.into()),
‚ãÆ----
.unwrap_or_default();
SELECTION_OVERLAY_HWND = SendHwnd(hwnd);
let hook = SetWindowsHookExW(
‚ãÆ----
Some(selection_hook_proc),
Some(GetModuleHandleW(None).unwrap().into()),
‚ãÆ----
sync_layered_window_contents(hwnd);
let _ = ShowWindow(hwnd, SW_SHOWNOACTIVATE);
let _ = SetTimer(Some(hwnd), FADE_TIMER_ID, 16, None);
‚ãÆ----
while PeekMessageW(&mut msg, None, 0, 0, PM_REMOVE).as_bool() {
let _ = TranslateMessage(&msg);
let _ = DispatchMessageW(&msg);
‚ãÆ----
if SELECTION_ABORT_SIGNAL.load(Ordering::SeqCst) {
let _ = SendMessageW(hwnd, WM_CLOSE, Some(WPARAM(0)), Some(LPARAM(0)));
‚ãÆ----
let _ = WaitMessage();
‚ãÆ----
let hook = std::ptr::addr_of!(SELECTION_HOOK).read();
if !hook.is_invalid() {
let _ = UnhookWindowsHookEx(hook);
SELECTION_HOOK = HHOOK(std::ptr::null_mut());
‚ãÆ----
unsafe extern "system" fn selection_hook_proc(
‚ãÆ----
SELECTION_ABORT_SIGNAL.store(true, Ordering::SeqCst);
let hwnd = std::ptr::addr_of!(SELECTION_OVERLAY_HWND).read().0;
if !hwnd.is_invalid() {
let _ = PostMessageW(Some(hwnd), WM_NULL, WPARAM(0), LPARAM(0));
‚ãÆ----
return LRESULT(1);
‚ãÆ----
CallNextHookEx(None, code, wparam, lparam)
‚ãÆ----
unsafe extern "system" fn selection_wnd_proc(
‚ãÆ----
let _ = GetCursorPos(std::ptr::addr_of_mut!(START_POS));
‚ãÆ----
SetCapture(hwnd);
‚ãÆ----
LRESULT(0)
‚ãÆ----
let _ = GetCursorPos(std::ptr::addr_of_mut!(LAST_PAN_POS));
‚ãÆ----
let _ = SetTimer(Some(hwnd), ZOOM_TIMER_ID, 16, None);
‚ãÆ----
let _ = ReleaseCapture();
‚ãÆ----
let _ = GetCursorPos(std::ptr::addr_of_mut!(CURR_POS));
‚ãÆ----
let _ = GetCursorPos(&mut curr_pan);
‚ãÆ----
let _ = GetCursorPos(&mut cursor);
‚ãÆ----
ZOOM_LEVEL = (ZOOM_LEVEL + ZOOM_STEP).min(MAX_ZOOM);
‚ãÆ----
ZOOM_LEVEL = (ZOOM_LEVEL - ZOOM_STEP).max(MIN_ZOOM);
‚ãÆ----
if load_magnification_api() {
‚ãÆ----
if init_fn().as_bool() {
‚ãÆ----
left: START_POS.x.min(CURR_POS.x),
top: START_POS.y.min(CURR_POS.y),
right: START_POS.x.max(CURR_POS.x),
bottom: START_POS.y.max(CURR_POS.y),
‚ãÆ----
let width = (rect.right - rect.left).abs();
let height = (rect.bottom - rect.top).abs();
‚ãÆ----
let _ = GetCursorPos(&mut pt);
let guard = APP.lock().unwrap();
‚ãÆ----
let old_bmp = SelectObject(hdc_mem, capture.hbitmap.into());
let sx = GetSystemMetrics(SM_XVIRTUALSCREEN);
let sy = GetSystemMetrics(SM_YVIRTUALSCREEN);
‚ãÆ----
let color = GetPixel(hdc_mem, local_x, local_y);
SelectObject(hdc_mem, old_bmp);
‚ãÆ----
let _ = ReleaseDC(None, hdc_screen);
‚ãÆ----
let hex_color = format!("#{:02X}{:02X}{:02X}", r, g, b);
‚ãÆ----
let _ = transform_fn(1.0, 0, 0);
‚ãÆ----
return LRESULT(0);
‚ãÆ----
.get(CURRENT_PRESET_IDX)
.map(|p| p.is_master)
.unwrap_or(false)
‚ãÆ----
let _ = GetCursorPos(&mut cursor_pos);
ZOOM_ALPHA_OVERRIDE = Some(60);
‚ãÆ----
Some(idx)
‚ãÆ----
SetTimer(Some(hwnd), FADE_TIMER_ID, 16, None);
‚ãÆ----
Some(CURRENT_PRESET_IDX)
‚ãÆ----
let mut guard = APP.lock().unwrap();
‚ãÆ----
.as_ref()
.expect("Screenshot handle missing");
let config_clone = guard.config.clone();
let preset_clone = guard.config.presets[preset_idx].clone();
let img = extract_crop_from_hbitmap(capture, rect);
‚ãÆ----
start_processing_pipeline(cropped_img, rect, config, preset);
‚ãÆ----
if diff_zoom.abs() > 0.001 {
‚ãÆ----
if dx.abs() > 0.1 || dy.abs() > 0.1 {
‚ãÆ----
let screen_w = GetSystemMetrics(SM_CXVIRTUALSCREEN);
let screen_h = GetSystemMetrics(SM_CYVIRTUALSCREEN);
let screen_x = GetSystemMetrics(SM_XVIRTUALSCREEN);
let screen_y = GetSystemMetrics(SM_YVIRTUALSCREEN);
‚ãÆ----
.max(screen_x as f32)
.min((screen_x + screen_w) as f32 - view_w);
‚ãÆ----
.max(screen_y as f32)
.min((screen_y + screen_h) as f32 - view_h);
let _ = transform_fn(RENDER_ZOOM, off_x as i32, off_y as i32);
‚ãÆ----
let _ = KillTimer(Some(hwnd), ZOOM_TIMER_ID);
‚ãÆ----
let _ = KillTimer(Some(hwnd), FADE_TIMER_ID);
let _ = DestroyWindow(hwnd);
PostQuitMessage(0);
‚ãÆ----
.min(TARGET_OPACITY as u16)
‚ãÆ----
let _ = BeginPaint(hwnd, &mut ps);
‚ãÆ----
let _ = EndPaint(hwnd, &mut ps);
‚ãÆ----
WM_ERASEBKGND => LRESULT(1),
‚ãÆ----
let _ = uninit_fn();
‚ãÆ----
if !std::ptr::addr_of!(CACHED_BITMAP).read().is_invalid() {
let _ = DeleteObject(CACHED_BITMAP.0.into());
‚ãÆ----
DefWindowProcW(hwnd, msg, wparam, lparam)
‚ãÆ----
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
‚ãÆ----
unsafe fn sync_layered_window_contents(hwnd: HWND) {
let width = GetSystemMetrics(SM_CXVIRTUALSCREEN);
let height = GetSystemMetrics(SM_CYVIRTUALSCREEN);
‚ãÆ----
if std::ptr::addr_of!(CACHED_BITMAP).read().is_invalid()
‚ãÆ----
let hbm = CreateDIBSection(Some(hdc_screen), &bmi, DIB_RGB_COLORS, &mut bits, None, 0);
‚ãÆ----
CACHED_BITMAP = SendHbitmap(h);
‚ãÆ----
let mem_dc = CreateCompatibleDC(Some(hdc_screen));
let old_bmp = SelectObject(mem_dc, CACHED_BITMAP.0.into());
‚ãÆ----
zoom_alpha.min(CURRENT_ALPHA)
‚ãÆ----
pixels_u32.fill(bg_val);
‚ãÆ----
let w = (r.right - r.left).abs();
let h = (r.bottom - r.top).abs();
‚ãÆ----
let pen = CreatePen(PS_SOLID, 2, COLORREF(0x00FFFFFF));
let old_pen = SelectObject(mem_dc, pen.into());
let null_brush = GetStockObject(NULL_BRUSH);
let old_brush = SelectObject(mem_dc, null_brush);
let _ = RoundRect(mem_dc, r.left, r.top, r.right, r.bottom, 12, 12);
SelectObject(mem_dc, old_brush);
SelectObject(mem_dc, old_pen);
let _ = DeleteObject(pen.into());
let b_left = (r.left - 5).max(0);
let b_top = (r.top - 5).max(0);
let b_right = (r.right + 5).min(width);
let b_bottom = (r.bottom + 5).min(height);
‚ãÆ----
if row_start < pixels_u32.len() && row_end <= pixels_u32.len() {
‚ãÆ----
x: GetSystemMetrics(SM_XVIRTUALSCREEN),
y: GetSystemMetrics(SM_YVIRTUALSCREEN),
‚ãÆ----
let _ = UpdateLayeredWindow(
‚ãÆ----
Some(hdc_screen),
Some(&screen_pos),
Some(&wnd_size),
Some(mem_dc),
Some(&src_pos),
COLORREF(0),
Some(&blend),
‚ãÆ----
SelectObject(mem_dc, old_bmp);
let _ = DeleteDC(mem_dc);
</file>

<file path="promptdj-midi/components/PromptDjMidi.ts">
import { css, html, LitElement } from 'lit';
import { customElement, property, state, query } from 'lit/decorators.js';
import { styleMap } from 'lit/directives/style-map.js';
import { throttle } from '../utils/throttle';
‚ãÆ----
import type { PlaybackState, Prompt } from '../types';
import { MidiDispatcher } from '../utils/MidiDispatcher';
import { LOCALES, Lang } from '../utils/Locales';
‚ãÆ----
export class PromptDjMidi extends LitElement
‚ãÆ----
// Recording playback state
‚ãÆ----
@state() private optimisticPlaying: boolean | null = null; // null = follow real state
‚ãÆ----
private clickCooldownUntil: number = 0; // epoch ms; during this window, ignore extra toggles
// Background drift control
@state() private driftStrength: number = 0; // 0 = at base, 1 = full drift
‚ãÆ----
// Left add-column activation state (4 slots)
‚ãÆ----
// Track which base grid slots are removed (to render add buttons in-grid)
‚ãÆ----
constructor(
    initialPrompts: Map<string, Prompt>,
)
‚ãÆ----
// Deep-copy base prompts
‚ãÆ----
// Start with defaults, BUT leave the last 2 (Custom) as empty slots
// There are 24 slots total. We want 22 active, 2 empty.
‚ãÆ----
// Load saved state and MERGE it
‚ãÆ----
// Only update if it corresponds to a valid base prompt or a known extra
// (For now, we trust the defaults structure more for the base grid)
‚ãÆ----
// Restore USER state (text, weight, color) but keep structure valid
‚ãÆ----
// Restore extra slots
‚ãÆ----
// Only respect removal of keys that actually exist in our base order
‚ãÆ----
public showRecording(blob: Blob)
private closeModal()
private downloadRecording()
private renderModal()
private saveState()
private handlePromptChanged(e: CustomEvent<Prompt>)
/** Generates radial gradients for each prompt based on weight and color, with gentle drift while playing. */
‚ãÆ----
const clamp01 = (v: number)
‚ãÆ----
const t = performance.now() * 0.0006; // time base for gentle drift
‚ãÆ----
// Stable alpha and size based on weight (no level-based pulsing)
‚ãÆ----
// Base grid position
‚ãÆ----
// Gentle, eased drift per prompt scaled by driftStrength
const phase = i * 1.37; // unique-ish per index
const driftAmp = 4 * (this.driftStrength || 0); // percent units
‚ãÆ----
30, // don't re-render more than once every XXms
‚ãÆ----
public async setShowMidi(show: boolean)
‚ãÆ----
// Notify listeners (iframe bridge) that inputs are available/updated
‚ãÆ----
// Public API used by parent (main app) via postMessage bridge
public getShowMidi(): boolean
public async refreshMidiInputs(): Promise<void>
public getMidiInputs(): string[]
public getActiveMidiInputId(): string | null
public setActiveMidiInputId(id: string)
// Localized placeholder text
private trPlaceholder(): string
private playPause(e: Event)
‚ãÆ----
// Prevent the bubbling play-pause event from also reaching outer listeners
‚ãÆ----
// Debounce rapid clicks to avoid double toggles
‚ãÆ----
// If currently playing or loading: this click means STOP
‚ãÆ----
this.optimisticPlaying = false; // pause -> play morph immediately
this.optimisticLoading = false; // ensure spinner is off
‚ãÆ----
this.dispatchEvent(new CustomEvent('pause', { bubbles: true })); // explicit pause/stop
‚ãÆ----
// If paused/stopped: this click means PLAY
‚ãÆ----
this.optimisticLoading = true; // show spinner immediately
this.optimisticPlaying = null; // follow real state for icon
‚ãÆ----
public addFilteredPrompt(prompt: string)
public setPromptLabels(labels: string[])
public getPrompts(): Map<string, Prompt>
private addExtraSlot(idx: number)
private addBaseSlot(idx: number)
‚ãÆ----
// Always use placeholder text when adding (user deleted the original intentionally)
‚ãÆ----
private clearPrompt(promptId: string)
‚ãÆ----
// Remove extra prompt and deactivate slot
‚ãÆ----
// Remove built-in prompt and mark slot as removed to render add button in-grid
‚ãÆ----
public resetAll()
‚ãÆ----
// Reset to original base prompts
// BUT maintain the "22 active, 2 empty" rule
‚ãÆ----
private formatDuration(sec: number)
private toggleRecording()
‚ãÆ----
// Sensitivity threshold bumped to 0.02
‚ãÆ----
private toggleMidiPanel()
‚ãÆ----
// Reset MIDI state when toggling on to allow retry after denial
‚ãÆ----
private handleVolumeChange(e: Event)
‚ãÆ----
// 1. IPC to native
‚ãÆ----
// 2. Global variable for hooks
‚ãÆ----
// 3. Audio tags
‚ãÆ----
// 4. Captured AudioContext Gains (from mod.rs hook)
‚ãÆ----
// smooth transition
‚ãÆ----
protected updated(changedProps: Map<string, any>)
‚ãÆ----
// Set drift target based on state and ensure the animation loop is running
‚ãÆ----
private ensureDriftLoop()
‚ãÆ----
const tick = () =>
‚ãÆ----
const dt = Math.max(0, now - this.lastDriftTick) / 1000; // seconds
‚ãÆ----
// Approach driftTarget smoothly (exponential smoothing)
const speed = 3.0; // higher = faster return/engage
‚ãÆ----
// Force a re-render so gradients animate (uses performance.now in makeBackground)
‚ãÆ----
// If we're returning to base and very close, stop the loop; otherwise keep running
‚ãÆ----
override render()
private renderPromptWithClear(promptId: string)
private renderPrompts()
‚ãÆ----
// Render in base grid order, allowing removed slots to show an add button
</file>

<file path="promptdj-midi/index.tsx">
import type { PlaybackState, Prompt } from './types';
import { GoogleGenAI, LiveMusicFilteredPrompt } from '@google/genai';
import { PromptDjMidi } from './components/PromptDjMidi';
import { ToastMessage } from './components/ToastMessage';
import { LiveMusicHelper } from './utils/LiveMusicHelper';
import { AudioAnalyser } from './utils/AudioAnalyser';
import { processAudioBlob } from './utils/AudioProcessing';
import { LOCALES, Lang } from './utils/Locales';
‚ãÆ----
function main()
‚ãÆ----
const attachHelperListeners = () =>
const attachAnalyserListener = () =>
function initWithApiKey(apiKey: string)
function startRecording()
function stopRecording()
function normalizeLang(lang: string | undefined): 'en' | 'ko' | 'vi'
‚ãÆ----
function buildInitialPrompts()
</file>

<file path="src/api/audio.rs">
use super::client::UREQ_AGENT;
use crate::config::Preset;
‚ãÆ----
use crate::APP;
use anyhow::Result;
‚ãÆ----
pub fn transcribe_audio_gemini<F>(
‚ãÆ----
if gemini_api_key.trim().is_empty() {
return Err(anyhow::anyhow!("NO_API_KEY:google"));
‚ãÆ----
let b64_audio = general_purpose::STANDARD.encode(&wav_data);
let url = format!(
‚ãÆ----
if !model.contains("gemma-3-27b-it") {
‚ãÆ----
.post(&url)
.header("x-goog-api-key", gemini_api_key)
.send_json(payload)
.map_err(|e| {
let err_str = e.to_string();
if err_str.contains("401") || err_str.contains("403") {
‚ãÆ----
let reader = BufReader::new(resp.into_body().into_reader());
for line in reader.lines() {
let line = line.map_err(|e| anyhow::anyhow!("Failed to read line: {}", e))?;
if line.starts_with("data: ") {
let json_str = &line["data: ".len()..];
if json_str.trim() == "[DONE]" {
‚ãÆ----
if let Some(candidates) = chunk_resp.get("candidates").and_then(|c| c.as_array()) {
if let Some(first_candidate) = candidates.first() {
‚ãÆ----
.get("content")
.and_then(|c| c.get("parts"))
.and_then(|p| p.as_array())
‚ãÆ----
if let Some(first_part) = parts.first() {
if let Some(text) = first_part.get("text").and_then(|t| t.as_str())
‚ãÆ----
full_content.push_str(text);
on_chunk(text);
‚ãÆ----
if full_content.is_empty() {
return Err(anyhow::anyhow!("No content received from Gemini Audio API"));
‚ãÆ----
Ok(full_content)
‚ãÆ----
fn upload_audio_to_whisper(
‚ãÆ----
let boundary = format!(
‚ãÆ----
body.extend_from_slice(format!("--{}\r\n", boundary).as_bytes());
body.extend_from_slice(b"Content-Disposition: form-data; name=\"model\"\r\n\r\n");
body.extend_from_slice(model.as_bytes());
body.extend_from_slice(b"\r\n");
‚ãÆ----
body.extend_from_slice(
‚ãÆ----
body.extend_from_slice(b"Content-Type: audio/wav\r\n\r\n");
body.extend_from_slice(&audio_data);
‚ãÆ----
body.extend_from_slice(format!("--{}--\r\n", boundary).as_bytes());
‚ãÆ----
.post("https://api.groq.com/openai/v1/audio/transcriptions")
.header("Authorization", &format!("Bearer {}", api_key))
.header(
‚ãÆ----
&format!("multipart/form-data; boundary={}", boundary),
‚ãÆ----
.send(&body);
‚ãÆ----
return Err(anyhow::anyhow!("API request failed: {}", err_str));
‚ãÆ----
.headers()
.get("x-ratelimit-remaining-requests")
.and_then(|v| v.to_str().ok())
‚ãÆ----
.get("x-ratelimit-limit-requests")
‚ãÆ----
.unwrap_or("?");
let usage_str = format!("{} / {}", remaining, limit);
if let Ok(mut app) = APP.lock() {
app.model_usage_stats.insert(model.to_string(), usage_str);
‚ãÆ----
.into_body()
.read_json()
.map_err(|e| anyhow::anyhow!("Failed to parse response: {}", e))?;
‚ãÆ----
.get("text")
.and_then(|t| t.as_str())
.ok_or_else(|| anyhow::anyhow!("No text in response"))?;
Ok(text.to_string())
‚ãÆ----
fn execute_audio_processing_logic(preset: &Preset, wav_data: Vec<u8>) -> anyhow::Result<String> {
‚ãÆ----
match preset.blocks.iter().find(|b| b.block_type == "audio") {
Some(b) => (b.clone(), false),
‚ãÆ----
.iter()
.find(|b| b.block_type == "input_adapter")
‚ãÆ----
Some(b) => (b.clone(), true),
‚ãÆ----
let debug_types: Vec<_> = preset.blocks.iter().map(|b| &b.block_type).collect();
eprintln!(
‚ãÆ----
return Err(anyhow::anyhow!(
‚ãÆ----
return Ok(String::new());
‚ãÆ----
let model_config = get_model_by_id(&audio_block.model);
‚ãÆ----
let model_name = model_config.full_name.clone();
let provider = model_config.provider.clone();
‚ãÆ----
let app = crate::APP.lock().unwrap();
‚ãÆ----
app.config.api_key.clone(),
app.config.gemini_api_key.clone(),
‚ãÆ----
let mut final_prompt = if model_is_non_llm(&audio_block.model) {
‚ãÆ----
audio_block.prompt.clone()
‚ãÆ----
let pattern = format!("{{{}}}", key);
final_prompt = final_prompt.replace(&pattern, value);
‚ãÆ----
if final_prompt.contains("{language1}") && !audio_block.language_vars.contains_key("language1")
‚ãÆ----
final_prompt = final_prompt.replace("{language1}", &audio_block.selected_language);
‚ãÆ----
final_prompt = final_prompt.replace("{language}", &audio_block.selected_language);
‚ãÆ----
if groq_api_key.trim().is_empty() {
Err(anyhow::anyhow!("NO_API_KEY:groq"))
‚ãÆ----
upload_audio_to_whisper(&groq_api_key, &model_name, wav_data)
‚ãÆ----
Err(anyhow::anyhow!("NO_API_KEY:google"))
‚ãÆ----
transcribe_audio_gemini(&gemini_api_key, final_prompt, model_name, wav_data, |_| {})
‚ãÆ----
Err(anyhow::anyhow!("Unsupported audio provider: {}", provider))
‚ãÆ----
pub fn record_audio_and_transcribe(
‚ãÆ----
cpal::host_from_id(cpal::HostId::Wasapi).unwrap_or(cpal::default_host())
‚ãÆ----
match host.default_output_device() {
‚ãÆ----
eprintln!("Error: No default output device found for loopback.");
‚ãÆ----
let _ = PostMessageW(Some(overlay_hwnd), WM_CLOSE, WPARAM(0), LPARAM(0));
‚ãÆ----
eprintln!("Error: Device capture not supported on this OS or no device found.");
‚ãÆ----
match host.default_input_device() {
‚ãÆ----
eprintln!("Error: No input device available.");
‚ãÆ----
match device.default_output_config() {
‚ãÆ----
Err(_) => match device.default_input_config() {
‚ãÆ----
eprintln!("Failed to get audio config: {}", e);
‚ãÆ----
match device.default_input_config() {
‚ãÆ----
let sample_rate = config.sample_rate();
let channels = config.channels();
‚ãÆ----
let err_fn = |err| eprintln!("Audio stream error: {}", err);
‚ãÆ----
let stream_res = match config.sample_format() {
cpal::SampleFormat::F32 => device.build_input_stream(
&config.into(),
‚ãÆ----
if !pause_signal.load(Ordering::Relaxed) {
let _ = tx.send(data.to_vec());
‚ãÆ----
rms = (rms / data.len() as f32).sqrt();
‚ãÆ----
.store(true, Ordering::SeqCst);
‚ãÆ----
cpal::SampleFormat::I16 => device.build_input_stream(
‚ãÆ----
data.iter().map(|&s| s as f32 / i16::MAX as f32).collect();
let _ = tx.send(f32_data);
‚ãÆ----
Err(cpal::BuildStreamError::StreamConfigNotSupported)
‚ãÆ----
eprintln!("Failed to build stream: {}", e);
‚ãÆ----
let stream = stream_res.unwrap();
if let Err(e) = stream.play() {
eprintln!("Failed to play stream: {}", e);
‚ãÆ----
while !stop_signal.load(Ordering::SeqCst) {
while let Ok(chunk) = rx.try_recv() {
collected_samples.extend(chunk);
‚ãÆ----
if auto_stop_enabled && !stop_signal.load(Ordering::Relaxed) {
let rms_bits = crate::overlay::recording::CURRENT_RMS.load(Ordering::Relaxed);
‚ãÆ----
first_speech_time = Some(std::time::Instant::now());
‚ãÆ----
.map(|t| t.elapsed().as_millis())
.unwrap_or(0);
‚ãÆ----
let silence_duration = last_active_time.elapsed().as_millis();
‚ãÆ----
stop_signal.store(true, Ordering::SeqCst);
‚ãÆ----
if !unsafe { IsWindow(Some(overlay_hwnd)).as_bool() } {
‚ãÆ----
drop(stream);
if abort_signal.load(Ordering::SeqCst) {
‚ãÆ----
if IsWindow(Some(overlay_hwnd)).as_bool() {
‚ãÆ----
.map(|&s| (s.clamp(-1.0, 1.0) * i16::MAX as f32) as i16)
.collect();
if samples.is_empty() {
println!("Warning: Recorded audio buffer is empty.");
‚ãÆ----
hound::WavWriter::new(&mut wav_cursor, spec).expect("Failed to create memory writer");
‚ãÆ----
.write_sample(*sample)
.expect("Failed to write sample");
‚ãÆ----
writer.finalize().expect("Failed to finalize WAV");
‚ãÆ----
let wav_data = wav_cursor.into_inner();
‚ãÆ----
let screen_w = unsafe { GetSystemMetrics(SM_CXSCREEN) };
let screen_h = unsafe { GetSystemMetrics(SM_CYSCREEN) };
‚ãÆ----
let audio_mode = Some(preset.audio_source.as_str());
‚ãÆ----
let mut app = crate::APP.lock().unwrap();
‚ãÆ----
app.config.presets[idx].clone()
‚ãÆ----
preset.clone()
‚ãÆ----
let wav_data_for_history = wav_data.clone();
let transcription_result = execute_audio_processing_logic(&working_preset, wav_data);
‚ãÆ----
let wav_data_for_overlay = wav_data_for_history.clone();
‚ãÆ----
.save_audio(wav_data_for_history, transcription_text.clone());
‚ãÆ----
let has_multiple_blocks = working_preset.blocks.len() > 1;
‚ãÆ----
Some(RECT {
‚ãÆ----
eprintln!("Transcription error: {}", e);
‚ãÆ----
pub fn process_audio_file_request(preset: Preset, wav_data: Vec<u8>) {
let processing_result = execute_audio_processing_logic(&preset, wav_data.clone());
‚ãÆ----
.save_audio(wav_data.clone(), result_text.clone());
‚ãÆ----
unsafe { (GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN)) };
let has_multiple_blocks = preset.blocks.len() > 1;
‚ãÆ----
HWND(std::ptr::null_mut()),
‚ãÆ----
eprintln!("Audio file processing error: {}", e);
</file>

<file path="src/gui/app/input_handler.rs">
use crate::overlay::preset_wheel::show_preset_wheel;
‚ãÆ----
use crate::overlay::utils::get_clipboard_image_bytes;
use crate::APP;
use eframe::egui;
‚ãÆ----
use std::io::Cursor;
use std::path::Path;
use std::sync::mpsc;
‚ãÆ----
use windows::Win32::UI::WindowsAndMessaging::GetCursorPos;
‚ãÆ----
fn is_image_extension(ext: &str) -> bool {
IMAGE_EXTENSIONS.contains(&ext.to_lowercase().as_str())
‚ãÆ----
fn is_audio_extension(ext: &str) -> bool {
AUDIO_EXTENSIONS.contains(&ext.to_lowercase().as_str())
‚ãÆ----
fn load_text_file(path: &Path) -> Option<String> {
std::fs::read_to_string(path).ok()
‚ãÆ----
fn load_audio_file(path: &Path) -> Option<Vec<u8>> {
use symphonia::core::audio::SampleBuffer;
use symphonia::core::codecs::DecoderOptions;
use symphonia::core::formats::FormatOptions;
use symphonia::core::io::MediaSourceStream;
use symphonia::core::meta::MetadataOptions;
use symphonia::core::probe::Hint;
let file = std::fs::File::open(path).ok()?;
‚ãÆ----
if let Some(ext) = path.extension().and_then(|e| e.to_str()) {
hint.with_extension(ext);
‚ãÆ----
.format(
‚ãÆ----
.ok()?;
‚ãÆ----
.tracks()
.iter()
.find(|t| t.codec_params.codec != symphonia::core::codecs::CODEC_TYPE_NULL)?;
‚ãÆ----
let codec_params = track.codec_params.clone();
let sample_rate = codec_params.sample_rate.unwrap_or(44100);
let channels = codec_params.channels.map(|c| c.count()).unwrap_or(2) as u16;
‚ãÆ----
.make(&codec_params, &DecoderOptions::default())
‚ãÆ----
let packet = match format.next_packet() {
‚ãÆ----
if e.kind() == std::io::ErrorKind::UnexpectedEof =>
‚ãÆ----
if packet.track_id() != track_id {
‚ãÆ----
let decoded = match decoder.decode(&packet) {
‚ãÆ----
let spec = *decoded.spec();
let duration = decoded.capacity() as u64;
‚ãÆ----
sample_buf.copy_interleaved_ref(decoded);
all_samples.extend(sample_buf.samples());
‚ãÆ----
if all_samples.is_empty() {
‚ãÆ----
let mut writer = hound::WavWriter::new(&mut wav_cursor, spec).ok()?;
‚ãÆ----
writer.write_sample(*sample).ok()?;
‚ãÆ----
writer.finalize().ok()?;
‚ãÆ----
Some(wav_cursor.into_inner())
‚ãÆ----
fn get_cursor_pos() -> POINT {
‚ãÆ----
let _ = GetCursorPos(&mut pos);
‚ãÆ----
fn get_screen_rect_at_cursor() -> RECT {
let pos = get_cursor_pos();
‚ãÆ----
fn process_image_content(img: ImageBuffer<Rgba<u8>, Vec<u8>>) {
let cursor_pos = get_cursor_pos();
let selected = show_preset_wheel("image", None, cursor_pos);
‚ãÆ----
let mut app = APP.lock().unwrap();
‚ãÆ----
(app.config.clone(), app.config.presets[preset_idx].clone())
‚ãÆ----
let rect = get_screen_rect_at_cursor();
‚ãÆ----
start_processing_pipeline(img, rect, config, preset);
‚ãÆ----
fn process_text_content(text: String) {
‚ãÆ----
let selected = show_preset_wheel("text", None, cursor_pos);
‚ãÆ----
let ui_lang = config.ui_language.clone();
‚ãÆ----
.first()
.map(|h| h.name.clone())
.unwrap_or_default();
‚ãÆ----
start_text_processing(text, rect, config, preset, localized_name, cancel_hotkey);
‚ãÆ----
fn process_image_parallel(rx: mpsc::Receiver<Option<(ImageBuffer<Rgba<u8>, Vec<u8>>, Vec<u8>)>>) {
‚ãÆ----
start_processing_pipeline_parallel(rx, rect, config, preset);
‚ãÆ----
fn process_text_parallel(rx: mpsc::Receiver<Option<String>>) {
‚ãÆ----
if let Ok(Some(text)) = rx.recv() {
‚ãÆ----
fn process_audio_parallel(rx: mpsc::Receiver<Option<Vec<u8>>>) {
‚ãÆ----
let selected = show_preset_wheel("audio", None, cursor_pos);
‚ãÆ----
app.config.presets[preset_idx].clone()
‚ãÆ----
if let Ok(Some(wav_data)) = rx.recv() {
‚ãÆ----
pub fn handle_dropped_files(ctx: &egui::Context) -> bool {
let dropped_files = ctx.input(|i| i.raw.dropped_files.clone());
if dropped_files.is_empty() {
‚ãÆ----
if let Some(file) = dropped_files.first() {
‚ãÆ----
let path_clone = path.clone();
let ext = path.extension().and_then(|e| e.to_str()).unwrap_or("");
if is_image_extension(ext) {
‚ãÆ----
// Read file bytes directly (preserves original format e.g. JPEG)
‚ãÆ----
let _ = tx.send(Some((img.to_rgba8(), bytes)));
‚ãÆ----
let _ = tx.send(None);
‚ãÆ----
process_image_parallel(rx);
‚ãÆ----
} else if is_audio_extension(ext) {
‚ãÆ----
let _ = tx.send(load_audio_file(&path_clone));
‚ãÆ----
process_audio_parallel(rx);
‚ãÆ----
// Default to Text (covers text files and unknown extensions)
‚ãÆ----
let _ = tx.send(load_text_file(&path_clone));
‚ãÆ----
process_text_parallel(rx);
‚ãÆ----
// If path is not available, use existing byte handling (already threaded but serial load->process)
‚ãÆ----
let bytes_clone = bytes.clone();
‚ãÆ----
// Try to interpret as image first
‚ãÆ----
let rgba = img.to_rgba8();
// For direct bytes drop, we also pass the bytes as "original"
process_image_content(rgba);
‚ãÆ----
else if let Ok(text) = String::from_utf8(bytes_clone.to_vec()) {
process_text_content(text);
‚ãÆ----
pub fn is_files_hovered(ctx: &egui::Context) -> bool {
ctx.input(|i| !i.raw.hovered_files.is_empty())
‚ãÆ----
fn get_clipboard_text() -> Option<String> {
use windows::Win32::Foundation::HGLOBAL;
‚ãÆ----
if OpenClipboard(None).is_ok() {
if let Ok(h_data) = GetClipboardData(13) {
let ptr = GlobalLock(HGLOBAL(h_data.0));
if !ptr.is_null() {
‚ãÆ----
while *wide_ptr.add(len) != 0 {
‚ãÆ----
let _ = GlobalUnlock(HGLOBAL(h_data.0));
let _ = CloseClipboard();
if !text.is_empty() {
return Some(text);
‚ãÆ----
pub fn handle_paste(ctx: &egui::Context) -> bool {
‚ãÆ----
let has_focus = ctx.input(|i| i.focused);
‚ãÆ----
let ctrl_down = unsafe { (GetAsyncKeyState(VK_CONTROL.0 as i32) as u16 & 0x8000) != 0 };
let v_down = unsafe { (GetAsyncKeyState(VK_V.0 as i32) as u16 & 0x8000) != 0 };
let v_was_down = LAST_V_STATE.swap(v_down, Ordering::SeqCst);
‚ãÆ----
let paste_event = ctx.input(|i| {
‚ãÆ----
.any(|e| matches!(e, egui::Event::Paste(_)))
‚ãÆ----
if let Some(img_bytes) = get_clipboard_image_bytes() {
‚ãÆ----
if let Some(text) = get_clipboard_text() {
</file>

<file path="src/overlay/mod.rs">
pub mod auto_copy_badge;
pub mod broom_assets;
pub mod input_history;
pub mod paint_utils;
pub mod preset_wheel;
pub mod process;
pub mod prompt_dj;
pub mod recording;
pub mod result;
mod selection;
pub mod text_input;
pub mod text_selection;
pub mod utils;
pub mod favorite_bubble;
pub mod html_components;
pub mod realtime_egui;
pub mod realtime_html;
pub mod realtime_webview;
pub mod tray_popup;
‚ãÆ----
pub use text_selection::show_text_selection_tag;
‚ãÆ----
pub fn get_shared_webview_data_dir() -> std::path::PathBuf {
let mut path = dirs::data_dir().unwrap_or_else(|| std::path::PathBuf::from("."));
path.push("SGT");
path.push("webview_data");
‚ãÆ----
pub fn clear_webview_permissions() -> bool {
‚ãÆ----
if path.exists() {
‚ãÆ----
println!("WebView data cleared successfully at {:?}", path);
‚ãÆ----
eprintln!("Failed to clear WebView data: {:?}", e);
</file>

<file path="src/overlay/preset_wheel/html.rs">
use crate::config::Preset;
use crate::gui::settings_ui::get_localized_preset_name;
pub fn escape_html(s: &str) -> String {
s.replace('&', "&amp;")
.replace('<', "&lt;")
.replace('>', "&gt;")
.replace('"', "&quot;")
.replace('\'', "&#39;")
‚ãÆ----
fn calculate_row_distribution(n: usize) -> Vec<usize> {
‚ãÆ----
return vec![];
‚ãÆ----
return vec![1];
‚ãÆ----
let cols = ((n as f64 / squish_factor).sqrt().ceil() as usize).max(1);
‚ãÆ----
rows.push(base + 1);
‚ãÆ----
rows.push(base);
‚ãÆ----
pub fn generate_items_html(presets: &[(usize, Preset)], ui_lang: &str) -> String {
let n = presets.len();
let row_distribution = calculate_row_distribution(n);
‚ãÆ----
for (row_idx, &items_in_row) in row_distribution.iter().enumerate() {
html.push_str(&format!(
‚ãÆ----
if item_idx < presets.len() {
‚ãÆ----
let name = escape_html(&get_localized_preset_name(&preset.id, ui_lang));
let color_class = format!("color-{}", item_idx % 12);
‚ãÆ----
html.push_str("</div>");
‚ãÆ----
/// Returns the static HTML skeleton with CSS and JS (loaded once)
pub fn get_wheel_template(is_dark: bool) -> String {
‚ãÆ----
pub fn get_wheel_template(is_dark: bool) -> String {
‚ãÆ----
let css = generate_css(is_dark);
let js = get_js();
format!(
‚ãÆ----
/// Generate CSS for the wheel with light/dark theme support
pub fn generate_css(is_dark: bool) -> String {
‚ãÆ----
pub fn generate_css(is_dark: bool) -> String {
// Theme-specific colors
‚ãÆ----
fn get_js() -> &'static str {
</file>

<file path="src/overlay/auto_copy_badge.rs">
use crate::APP;
use std::cell::RefCell;
‚ãÆ----
use windows::Win32::Graphics::Dwm::DwmExtendFrameIntoClientArea;
‚ãÆ----
use windows::Win32::UI::Controls::MARGINS;
‚ãÆ----
use crate::win_types::SendHwnd;
‚ãÆ----
static mut BADGE_HWND: SendHwnd = SendHwnd(HWND(std::ptr::null_mut()));
‚ãÆ----
pub enum NotificationType {
‚ãÆ----
thread_local! {
‚ãÆ----
struct HwndWrapper(HWND);
unsafe impl Send for HwndWrapper {}
unsafe impl Sync for HwndWrapper {}
‚ãÆ----
fn window_handle(
‚ãÆ----
std::num::NonZeroIsize::new(self.0 .0 as isize).expect("HWND cannot be null"),
‚ãÆ----
unsafe { Ok(raw_window_handle::WindowHandle::borrow_raw(handle)) }
‚ãÆ----
pub fn show_auto_copy_badge_text(text: &str) {
*PENDING_CONTENT.lock().unwrap() = text.to_string();
*PENDING_NOTIFICATION_TYPE.lock().unwrap() = NotificationType::Success;
ensure_window_and_post(WM_APP_SHOW_TEXT);
‚ãÆ----
pub fn show_auto_copy_badge_image() {
‚ãÆ----
ensure_window_and_post(WM_APP_SHOW_IMAGE);
‚ãÆ----
/// Show a loading/info notification with just a title (yellow theme)
pub fn show_notification(title: &str) {
‚ãÆ----
pub fn show_notification(title: &str) {
*PENDING_CONTENT.lock().unwrap() = title.to_string();
*PENDING_NOTIFICATION_TYPE.lock().unwrap() = NotificationType::Info;
ensure_window_and_post(WM_APP_SHOW_NOTIFICATION);
‚ãÆ----
/// Show an update available notification (blue theme, longer duration)
pub fn show_update_notification(title: &str) {
‚ãÆ----
pub fn show_update_notification(title: &str) {
‚ãÆ----
*PENDING_NOTIFICATION_TYPE.lock().unwrap() = NotificationType::Update;
ensure_window_and_post(WM_APP_SHOW_UPDATE);
‚ãÆ----
fn ensure_window_and_post(msg: u32) {
‚ãÆ----
if std::ptr::addr_of!(BADGE_HWND).read().is_invalid() {
warmup();
// Wait longer for WebView to initialize
‚ãÆ----
let hwnd = std::ptr::addr_of!(BADGE_HWND).read().0;
if !hwnd.is_invalid() {
let _ = PostMessageW(Some(hwnd), msg, WPARAM(0), LPARAM(0));
‚ãÆ----
pub fn warmup() {
‚ãÆ----
internal_create_window_loop();
‚ãÆ----
fn get_badge_html() -> String {
‚ãÆ----
format!(
‚ãÆ----
fn internal_create_window_loop() {
‚ãÆ----
let instance = GetModuleHandleW(None).unwrap();
let class_name = w!("SGT_AutoCopyBadgeWebView");
REGISTER_BADGE_CLASS.call_once(|| {
‚ãÆ----
wc.lpfnWndProc = Some(badge_wnd_proc);
wc.hInstance = instance.into();
wc.hCursor = LoadCursorW(None, IDC_ARROW).unwrap();
‚ãÆ----
wc.hbrBackground = HBRUSH(std::ptr::null_mut());
let _ = RegisterClassW(&wc);
‚ãÆ----
let hwnd = CreateWindowExW(
‚ãÆ----
w!("SGT AutoCopy Badge"),
‚ãÆ----
Some(instance.into()),
‚ãÆ----
.unwrap_or_default();
BADGE_HWND = SendHwnd(hwnd);
‚ãÆ----
let _ = DwmExtendFrameIntoClientArea(hwnd, &margins);
let wrapper = HwndWrapper(hwnd);
BADGE_WEB_CONTEXT.with(|ctx| {
if ctx.borrow().is_none() {
‚ãÆ----
*ctx.borrow_mut() = Some(WebContext::new(Some(shared_data_dir)));
‚ãÆ----
let webview = BADGE_WEB_CONTEXT.with(|ctx| {
let mut ctx_ref = ctx.borrow_mut();
let builder = if let Some(web_ctx) = ctx_ref.as_mut() {
‚ãÆ----
.with_transparent(true)
.with_bounds(Rect {
‚ãÆ----
.with_html(&get_badge_html())
.with_ipc_handler(move |msg: wry::http::Request<String>| {
let body = msg.body();
‚ãÆ----
let _ = ShowWindow(hwnd, SW_HIDE);
‚ãÆ----
.build(&wrapper)
‚ãÆ----
BADGE_WEBVIEW.with(|cell| {
*cell.borrow_mut() = Some(wv);
‚ãÆ----
while GetMessageW(&mut msg, None, 0, 0).into() {
let _ = TranslateMessage(&msg);
DispatchMessageW(&msg);
‚ãÆ----
BADGE_HWND = SendHwnd(HWND(std::ptr::null_mut()));
‚ãÆ----
unsafe extern "system" fn badge_wnd_proc(
‚ãÆ----
let app = APP.lock().unwrap();
let ui_lang = app.config.ui_language.clone();
‚ãÆ----
let text = PENDING_CONTENT.lock().unwrap().clone();
let clean_text = text.replace('\n', " ").replace('\r', "");
format!("\"{}\"", clean_text)
‚ãÆ----
locale.auto_copied_image_badge.to_string()
‚ãÆ----
drop(app);
let screen_w = GetSystemMetrics(SM_CXSCREEN);
let screen_h = GetSystemMetrics(SM_CYSCREEN);
‚ãÆ----
let _ = SetWindowPos(
‚ãÆ----
Some(HWND_TOPMOST),
‚ãÆ----
BADGE_WEBVIEW.with(|wv| {
if let Some(webview) = wv.borrow().as_ref() {
// 1. Set notification type and update theme
let _ = webview.evaluate_script("window.setNotificationType('success');");
let theme_script = format!("window.setTheme({});", is_dark);
let _ = webview.evaluate_script(&theme_script);
// 2. Show content
‚ãÆ----
.replace('\\', "\\\\")
.replace('"', "\\\"")
.replace('\'', "\\'");
‚ãÆ----
let script = format!("window.show('{}', '{}');", safe_title, safe_snippet);
let _ = webview.evaluate_script(&script);
‚ãÆ----
LRESULT(0)
‚ãÆ----
let title = PENDING_CONTENT.lock().unwrap().clone();
‚ãÆ----
format!("window.setNotificationType('{}');", notification_type);
let _ = webview.evaluate_script(&type_script);
‚ãÆ----
let script = format!("window.show('{}', '');", safe_title);
‚ãÆ----
PostQuitMessage(0);
‚ãÆ----
WM_ERASEBKGND => LRESULT(1),
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
</file>

<file path="src/overlay/process/chain.rs">
use crate::gui::settings_ui::get_localized_preset_name;
‚ãÆ----
use crate::overlay::text_input;
use crate::win_types::SendHwnd;
‚ãÆ----
use super::window::create_processing_window;
pub fn execute_chain_pipeline(
‚ãÆ----
let graphics_mode = config.graphics_mode.clone();
let processing_hwnd = unsafe { create_processing_window(rect, graphics_mode) };
‚ãÆ----
let _ = SendMessageW(processing_hwnd, WM_TIMER, Some(WPARAM(1)), Some(LPARAM(0)));
‚ãÆ----
let conf_clone = config.clone();
let blocks = preset.blocks.clone();
let connections = preset.block_connections.clone();
let preset_id = preset.id.clone();
let processing_hwnd_send = SendHwnd(processing_hwnd);
‚ãÆ----
reset_window_position_queue();
run_chain_step(
‚ãÆ----
Some(processing_hwnd_send),
‚ãÆ----
while GetMessageW(&mut msg, None, 0, 0).into() {
let _ = TranslateMessage(&msg);
DispatchMessageW(&msg);
if !IsWindow(Some(processing_hwnd)).as_bool() {
‚ãÆ----
pub fn execute_chain_pipeline_with_token(
‚ãÆ----
preset.id.clone(),
‚ãÆ----
pub fn run_chain_step(
‚ãÆ----
if cancel_token.load(Ordering::Relaxed) {
‚ãÆ----
let _ = PostMessageW(Some(h.0), WM_CLOSE, WPARAM(0), LPARAM(0));
‚ãÆ----
if block_idx >= blocks.len() {
‚ãÆ----
let model_id = block.model.clone();
‚ãÆ----
.clone()
.map(|m| m.provider)
.unwrap_or("groq".to_string());
let model_full_name = model_conf.map(|m| m.full_name).unwrap_or(model_id.clone());
let mut final_prompt = block.prompt.clone();
‚ãÆ----
final_prompt = final_prompt.replace(&format!("{{{}}}", key), value);
‚ãÆ----
if final_prompt.contains("{language1}") && !block.language_vars.contains_key("language1") {
final_prompt = final_prompt.replace("{language1}", &block.selected_language);
‚ãÆ----
final_prompt = final_prompt.replace("{language}", &block.selected_language);
‚ãÆ----
.iter()
.take(block_idx)
.filter(|b| b.show_overlay)
.count();
let bg_color = get_chain_color(visible_count_before);
‚ãÆ----
get_next_window_position(current_rect)
‚ãÆ----
context.clone()
‚ãÆ----
let m_id = model_id.clone();
let prov = provider.clone();
let prompt_c = final_prompt.clone();
‚ãÆ----
let render_md = block.render_mode.clone();
let parent_clone = parent_hwnd.clone();
‚ãÆ----
block.block_type == "input_adapter" && matches!(context, RefineContext::Image(_));
‚ãÆ----
use base64::Engine;
let base64_img = base64::engine::general_purpose::STANDARD.encode(img_data);
let mime_type = if img_data.starts_with(&[0xff, 0xd8, 0xff]) {
‚ãÆ----
} else if img_data.starts_with(&[0x89, 0x50, 0x4e, 0x47]) {
‚ãÆ----
format!(
‚ãÆ----
let base64_audio = base64::engine::general_purpose::STANDARD.encode(wav_data);
‚ãÆ----
RefineContext::None => input_text.clone(),
‚ãÆ----
let initial_content_clone = initial_content.clone();
let cancel_token_thread = cancel_token.clone();
‚ãÆ----
// NOTE: wry handles COM internally, explicit initialization may interfere
let hwnd = create_result_window(
‚ãÆ----
// Assign cancellation token immediately for linking/grouping
// This is critical for input adapters since we don't wait for them in main thread
‚ãÆ----
let mut s = WINDOW_STATES.lock().unwrap();
if let Some(st) = s.get_mut(&(hwnd.0 as isize)) {
st.cancellation_token = Some(cancel_token_thread.clone());
‚ãÆ----
if let Ok(p_guard) = parent_clone.lock() {
‚ãÆ----
link_windows(ph.0, hwnd);
‚ãÆ----
// For image blocks: DON'T show window yet - keep it hidden
// It will be shown when first data arrives (in the streaming callback)
// For text blocks: show immediately with refining animation
‚ãÆ----
let _ = ShowWindow(hwnd, SW_SHOW);
‚ãÆ----
let _ = tx_hwnd.send(SendHwnd(hwnd));
‚ãÆ----
// If it's an image input adapter, set opacity to 255 (full opaque)
// This allows the image itself to be fully visible, while the slider controls the image opacity
‚ãÆ----
// Import SetLayeredWindowAttributes locally if needed, or assume it's available via windows crate
use windows::Win32::Foundation::COLORREF;
‚ãÆ----
let _ = SetLayeredWindowAttributes(hwnd, COLORREF(0), 255, LWA_ALPHA);
‚ãÆ----
while GetMessageW(&mut m, None, 0, 0).into() {
let _ = TranslateMessage(&m);
DispatchMessageW(&m);
if !IsWindow(Some(hwnd)).as_bool() {
‚ãÆ----
my_hwnd = rx_hwnd.recv().ok().map(|h| h.0);
‚ãÆ----
if let Some(st) = s.get_mut(&(h.0 as isize)) {
st.cancellation_token = Some(cancel_token.clone());
‚ãÆ----
if !skip_execution && my_hwnd.is_some() {
‚ãÆ----
if let Some(st) = s.get_mut(&(my_hwnd.unwrap().0 as isize)) {
‚ãÆ----
st.input_text = input_text.clone();
‚ãÆ----
let input_text_for_history = input_text.clone();
‚ãÆ----
input_text.clone()
‚ãÆ----
update_window_text(h, &input_text);
‚ãÆ----
let groq_key = config.api_key.clone();
let gemini_key = config.gemini_api_key.clone();
let use_json = block_idx == 0 && blocks.len() == 1 && blocks[0].block_type == "image";
‚ãÆ----
let acc_clone = accumulated.clone();
‚ãÆ----
.position(|b| b.block_type != "input_adapter")
.map(|pos| pos == block_idx)
.unwrap_or(false);
let model_name_for_error = model_full_name.clone();
‚ãÆ----
let window_shown_clone = window_shown.clone();
‚ãÆ----
let processing_hwnd_clone = processing_hwnd_shared.clone();
‚ãÆ----
&& matches!(context, RefineContext::Image(_))
‚ãÆ----
if let RefineContext::Image(img_data) = context.clone() {
‚ãÆ----
.expect("Failed to load png")
.to_rgba8();
let acc_clone_inner = acc_clone.clone();
‚ãÆ----
let window_shown_inner = window_shown_clone.clone();
let proc_hwnd_inner = processing_hwnd_clone.clone();
translate_image_streaming(
‚ãÆ----
Some(img_data),
‚ãÆ----
let mut t = acc_clone_inner.lock().unwrap();
if chunk.starts_with(crate::api::WIPE_SIGNAL) {
t.clear();
t.push_str(&chunk[crate::api::WIPE_SIGNAL.len()..]);
‚ãÆ----
t.push_str(chunk);
‚ãÆ----
let mut shown = window_shown_inner.lock().unwrap();
‚ãÆ----
let _ = ShowWindow(h, SW_SHOW);
‚ãÆ----
let mut proc_hwnd = proc_hwnd_inner.lock().unwrap();
if let Some(ph) = proc_hwnd.take() {
‚ãÆ----
let _ = PostMessageW(
Some(ph.0),
‚ãÆ----
WPARAM(0),
LPARAM(0),
‚ãÆ----
update_window_text(h, &t);
‚ãÆ----
Err(anyhow::anyhow!("Missing image context"))
‚ãÆ----
let search_label = Some(get_localized_preset_name(&preset_id, &config.ui_language));
translate_text_streaming(
‚ãÆ----
let mut t = acc_clone.lock().unwrap();
‚ãÆ----
update_window_text(h, &txt);
‚ãÆ----
let lang = config.ui_language.clone();
‚ãÆ----
&e.to_string(),
‚ãÆ----
Some(&model_name_for_error),
‚ãÆ----
let mut shown = window_shown.lock().unwrap();
‚ãÆ----
let mut proc_hwnd = processing_hwnd_shared.lock().unwrap();
‚ãÆ----
PostMessageW(Some(ph.0), WM_CLOSE, WPARAM(0), LPARAM(0));
‚ãÆ----
update_window_text(h, &err);
‚ãÆ----
let has_content = !result_text.trim().is_empty();
‚ãÆ----
let img_data_clone = img_data.clone();
‚ãÆ----
let image_copied = is_input_adapter && matches!(context, RefineContext::Image(_));
‚ãÆ----
let txt_c = result_text.clone();
let txt_for_badge = result_text.clone();
‚ãÆ----
let preset_id_clone = preset_id.clone();
‚ãÆ----
let app = crate::APP.lock().unwrap();
‚ãÆ----
app.config.presets.iter().find(|p| p.id == preset_id_clone)
‚ãÆ----
if active_idx < app.config.presets.len() {
‚ãÆ----
let final_text = if !txt_c.trim().is_empty() {
‚ãÆ----
format!("{}\n", txt_c)
‚ãÆ----
txt_c.clone()
‚ãÆ----
if txt_c.trim().is_empty() {
‚ãÆ----
if block.auto_speak && !result_text.trim().is_empty() {
let txt_s = result_text.clone();
‚ãÆ----
crate::api::tts::TTS_MANAGER.speak(&txt_s, 0);
‚ãÆ----
if block.show_overlay && !result_text.trim().is_empty() {
let text_for_history = result_text.clone();
‚ãÆ----
let input_text_clone = input_text_for_history.clone();
‚ãÆ----
if let Ok(app) = crate::APP.lock() {
app.history.save_text(text_for_history, input_text_clone);
‚ãÆ----
if let RefineContext::Image(img_bytes) = context.clone() {
‚ãÆ----
let img_buffer = img_dynamic.to_rgba8();
‚ãÆ----
app.history.save_image(img_buffer, text_for_history);
‚ãÆ----
let should_continue = !result_text.trim().is_empty() || block.block_type == "input_adapter";
‚ãÆ----
.filter(|(from, _)| *from == block_idx)
.map(|(_, to)| *to)
.collect();
let next_blocks: Vec<usize> = if connections.is_empty() {
if block_idx + 1 < blocks.len() {
vec![block_idx + 1]
‚ãÆ----
vec![]
‚ãÆ----
if next_blocks.is_empty() {
‚ãÆ----
let next_parent = if my_hwnd.is_some() {
Arc::new(Mutex::new(my_hwnd.map(|h| SendHwnd(h))))
‚ãÆ----
let base_rect = if my_hwnd.is_some() {
‚ãÆ----
let parallel_branches: Vec<usize> = next_blocks.into_iter().skip(1).collect();
‚ãÆ----
let _s_w = unsafe { GetSystemMetrics(SM_CXSCREEN) };
let _s_h = unsafe { GetSystemMetrics(SM_CYSCREEN) };
for (branch_index, next_idx) in parallel_branches.iter().enumerate() {
let result_clone = result_text.clone();
let blocks_clone = blocks.clone();
let conns_clone = connections.clone();
let config_clone = config.clone();
let cancel_clone = cancel_token.clone();
let parent_clone = next_parent.clone();
‚ãÆ----
let branch_context = next_context.clone();
‚ãÆ----
let _ = CoInitializeEx(None, COINIT_APARTMENTTHREADED);
‚ãÆ----
blocks.clone(),
</file>

<file path="src/overlay/text_input.rs">
use crate::gui::locale::LocaleText;
‚ãÆ----
use std::cell::RefCell;
use std::num::NonZeroIsize;
‚ãÆ----
use crate::win_types::SendHwnd;
‚ãÆ----
static mut INPUT_HWND: SendHwnd = SendHwnd(HWND(std::ptr::null_mut()));
‚ãÆ----
thread_local! {
‚ãÆ----
struct HwndWrapper(HWND);
impl HasWindowHandle for HwndWrapper {
fn window_handle(&self) -> std::result::Result<WindowHandle<'_>, HandleError> {
‚ãÆ----
Ok(unsafe { WindowHandle::borrow_raw(raw) })
‚ãÆ----
Err(HandleError::Unavailable)
‚ãÆ----
/// CSS for the modern text input editor
fn get_editor_css() -> &'static str {
‚ãÆ----
fn get_editor_css() -> &'static str {
‚ãÆ----
fn get_editor_html(placeholder: &str) -> String {
let css = get_editor_css();
‚ãÆ----
.replace('\\', "\\\\")
.replace('"', "\\\"")
.replace('\n', "\\n");
format!(
‚ãÆ----
pub fn is_active() -> bool {
‚ãÆ----
!std::ptr::addr_of!(INPUT_HWND).read().is_invalid()
&& IsWindowVisible(INPUT_HWND.0).as_bool()
‚ãÆ----
pub fn cancel_input() {
‚ãÆ----
if !std::ptr::addr_of!(INPUT_HWND).read().is_invalid() {
// Just hide the window, don't destroy
let _ = ShowWindow(INPUT_HWND.0, SW_HIDE);
‚ãÆ----
/// Set text content in the webview editor (for paste operations)
/// This is thread-safe and can be called from any thread
‚ãÆ----
/// This is thread-safe and can be called from any thread
pub fn set_editor_text(text: &str) {
‚ãÆ----
pub fn set_editor_text(text: &str) {
‚ãÆ----
// Store the text in the mutex
*PENDING_TEXT.lock().unwrap() = Some(text.to_string());
// Post message to the text input window to trigger the injection
‚ãÆ----
let _ = PostMessageW(Some(INPUT_HWND.0), WM_APP_SET_TEXT, WPARAM(0), LPARAM(0));
‚ãÆ----
/// Internal function to apply pending text (called on the window's thread)
/// Inserts text at the current cursor position instead of replacing all content
‚ãÆ----
/// Inserts text at the current cursor position instead of replacing all content
fn apply_pending_text() {
‚ãÆ----
fn apply_pending_text() {
let text = PENDING_TEXT.lock().unwrap().take();
‚ãÆ----
// Check if this is a history replacement (replace all) or insertion
‚ãÆ----
if let Some(stripped) = text.strip_prefix("__REPLACE_ALL__") {
(true, stripped.to_string())
‚ãÆ----
.replace('`', "\\`")
.replace("${", "\\${")
.replace('\n', "\\n")
.replace('\r', "");
TEXT_INPUT_WEBVIEW.with(|webview| {
if let Some(wv) = webview.borrow().as_ref() {
‚ãÆ----
// Replace all text (for history navigation)
‚ãÆ----
// Insert at cursor position (for paste/transcription)
‚ãÆ----
let _ = wv.evaluate_script(&script);
‚ãÆ----
/// Clear the webview editor content and refocus (for continuous input mode)
pub fn clear_editor_text() {
‚ãÆ----
pub fn clear_editor_text() {
‚ãÆ----
let _ = wv.evaluate_script(script);
‚ãÆ----
/// Update the UI text (header) and trigger a repaint
pub fn update_ui_text(header_text: String) {
‚ãÆ----
pub fn update_ui_text(header_text: String) {
‚ãÆ----
*CFG_TITLE.lock().unwrap() = header_text;
let _ = InvalidateRect(Some(INPUT_HWND.0), None, true);
‚ãÆ----
/// Bring the text input window to foreground and focus the editor
/// Call this after closing modal windows like the preset wheel
‚ãÆ----
/// Call this after closing modal windows like the preset wheel
pub fn refocus_editor() {
‚ãÆ----
pub fn refocus_editor() {
‚ãÆ----
use windows::Win32::UI::Input::KeyboardAndMouse::SetFocus;
‚ãÆ----
// Aggressive focus: try multiple methods
let _ = BringWindowToTop(INPUT_HWND.0);
let _ = SetForegroundWindow(INPUT_HWND.0);
let _ = SetFocus(Some(INPUT_HWND.0));
// Focus the webview editor immediately
‚ãÆ----
// First focus the WebView itself (native focus)
let _ = wv.focus();
// Then focus the textarea inside via JavaScript
let _ = wv.evaluate_script("document.getElementById('editor').focus();");
‚ãÆ----
// Schedule another focus attempt after 200ms via timer ID 3
// This will be handled in WM_TIMER in the same thread
let _ = SetTimer(Some(INPUT_HWND.0), 3, 200, None);
‚ãÆ----
/// Get the current window rect of the text input window (if active)
pub fn get_window_rect() -> Option<RECT> {
‚ãÆ----
pub fn get_window_rect() -> Option<RECT> {
‚ãÆ----
if GetWindowRect(INPUT_HWND.0, &mut rect).is_ok() {
return Some(rect);
‚ãÆ----
/// Start the persistent hidden window (called from main)
pub fn warmup() {
‚ãÆ----
pub fn warmup() {
‚ãÆ----
internal_create_window_loop();
‚ãÆ----
pub fn show(
‚ãÆ----
// Clone lang for locale notification before moving/consuming it
let lang_for_locale = ui_language.clone();
// Update shared state FIRST so it's ready when window shows up
*CFG_TITLE.lock().unwrap() = prompt_guide;
*CFG_LANG.lock().unwrap() = ui_language;
*CFG_CANCEL.lock().unwrap() = cancel_hotkey_name;
*CFG_CONTINUOUS.lock().unwrap() = continuous_mode;
*CFG_CALLBACK.lock().unwrap() = Some(Box::new(on_submit));
*SUBMITTED_TEXT.lock().unwrap() = None;
*SHOULD_CLOSE.lock().unwrap() = false;
*SHOULD_CLEAR_ONLY.lock().unwrap() = false;
// Check if warmed up
‚ãÆ----
// Trigger warmup for recovery
warmup();
// Show localized message that feature is not ready yet
‚ãÆ----
// Spawn thread to wait and auto-show
‚ãÆ----
// SAFETY: Accessing static muts INPUT_HWND and IS_WARMED_UP (lexically inside unsafe block)
let ready = !std::ptr::addr_of!(INPUT_HWND).read().is_invalid() && IS_WARMED_UP;
‚ãÆ----
let hwnd_wrapper = std::ptr::addr_of!(INPUT_HWND).read();
‚ãÆ----
PostMessageW(Some(hwnd_wrapper.0), WM_APP_SHOW, WPARAM(0), LPARAM(0));
‚ãÆ----
// Window exists, wake it up
let _ = PostMessageW(Some(INPUT_HWND.0), WM_APP_SHOW, WPARAM(0), LPARAM(0));
‚ãÆ----
fn internal_create_window_loop() {
‚ãÆ----
let instance = GetModuleHandleW(None).unwrap();
let class_name = w!("SGT_TextInputWry");
REGISTER_INPUT_CLASS.call_once(|| {
‚ãÆ----
wc.lpfnWndProc = Some(input_wnd_proc);
wc.hInstance = instance.into();
wc.hCursor = LoadCursorW(None, IDC_ARROW).unwrap();
‚ãÆ----
let _ = RegisterClassW(&wc);
‚ãÆ----
let screen_w = GetSystemMetrics(SM_CXSCREEN);
let screen_h = GetSystemMetrics(SM_CYSCREEN);
‚ãÆ----
let hwnd = CreateWindowExW(
‚ãÆ----
w!("Text Input"),
‚ãÆ----
Some(instance.into()),
‚ãÆ----
.unwrap_or_default();
INPUT_HWND = SendHwnd(hwnd);
let _ = SetLayeredWindowAttributes(hwnd, COLORREF(0), 0, LWA_ALPHA);
let rgn = CreateRoundRectRgn(0, 0, win_w, win_h, 16, 16);
let _ = SetWindowRgn(hwnd, Some(rgn), true);
init_webview(hwnd, win_w, win_h);
‚ãÆ----
while GetMessageW(&mut msg, None, 0, 0).as_bool() {
let _ = TranslateMessage(&msg);
let _ = DispatchMessageW(&msg);
‚ãÆ----
TEXT_INPUT_WEBVIEW.with(|wv| {
*wv.borrow_mut() = None;
‚ãÆ----
unsafe fn init_webview(hwnd: HWND, w: i32, h: i32) {
‚ãÆ----
let html = get_editor_html(placeholder);
let wrapper = HwndWrapper(hwnd);
TEXT_INPUT_WEB_CONTEXT.with(|ctx| {
if ctx.borrow().is_none() {
‚ãÆ----
*ctx.borrow_mut() = Some(WebContext::new(Some(shared_data_dir)));
‚ãÆ----
let result = TEXT_INPUT_WEB_CONTEXT.with(|ctx| {
let mut ctx_ref = ctx.borrow_mut();
let builder = if let Some(web_ctx) = ctx_ref.as_mut() {
‚ãÆ----
.with_bounds(Rect {
‚ãÆ----
.with_html(&html)
.with_transparent(false)
.with_ipc_handler(move |msg: wry::http::Request<String>| {
let body = msg.body();
if body.starts_with("submit:") {
let text = body.strip_prefix("submit:").unwrap_or("").to_string();
if !text.trim().is_empty() {
// Save to history before submitting
‚ãÆ----
*SUBMITTED_TEXT.lock().unwrap() = Some(text);
*SHOULD_CLOSE.lock().unwrap() = true;
‚ãÆ----
} else if body.starts_with("history_up:") {
let current = body.strip_prefix("history_up:").unwrap_or("");
‚ãÆ----
*PENDING_TEXT.lock().unwrap() = Some(format!("__REPLACE_ALL__{}", text));
‚ãÆ----
let _ = PostMessageW(
Some(INPUT_HWND.0),
‚ãÆ----
WPARAM(0),
LPARAM(0),
‚ãÆ----
} else if body.starts_with("history_down:") {
let current = body.strip_prefix("history_down:").unwrap_or("");
‚ãÆ----
let app = crate::APP.lock().unwrap();
‚ãÆ----
.iter()
.position(|p| p.id == "preset_transcribe")
‚ãÆ----
.build_as_child(&wrapper)
‚ãÆ----
*wv.borrow_mut() = Some(webview);
‚ãÆ----
unsafe extern "system" fn input_wnd_proc(
‚ãÆ----
let prompt_guide = CFG_TITLE.lock().unwrap().clone();
let ui_language = CFG_LANG.lock().unwrap().clone();
let _ = SetWindowTextW(hwnd, &HSTRING::from(prompt_guide));
‚ãÆ----
let placeholder = locale.text_input_placeholder.to_string();
‚ãÆ----
if let Some(webview) = wv.borrow().as_ref() {
let script = format!(
‚ãÆ----
let _ = webview.evaluate_script(&script);
‚ãÆ----
let _ = GetWindowRect(hwnd, &mut rect);
‚ãÆ----
let _ = SetWindowPos(
‚ãÆ----
Some(HWND::default()),
‚ãÆ----
let _ = ShowWindow(hwnd, SW_SHOW);
let _ = SetForegroundWindow(hwnd);
let _ = SetFocus(Some(hwnd));
let _ = UpdateWindow(hwnd);
SetTimer(Some(hwnd), 1, 16, None);
SetTimer(Some(hwnd), 2, 50, None);
LRESULT(0)
‚ãÆ----
apply_pending_text();
‚ãÆ----
let _ = ShowWindow(hwnd, SW_HIDE);
let _ = KillTimer(Some(hwnd), 1);
let _ = KillTimer(Some(hwnd), 2);
let _ = KillTimer(Some(hwnd), 3);
‚ãÆ----
PostQuitMessage(0);
‚ãÆ----
WM_ERASEBKGND => LRESULT(1),
‚ãÆ----
SetLayeredWindowAttributes(hwnd, COLORREF(0), FADE_ALPHA as u8, LWA_ALPHA);
‚ãÆ----
wv.evaluate_script("document.getElementById('editor').focus();");
‚ãÆ----
let should_close = *SHOULD_CLOSE.lock().unwrap();
‚ãÆ----
let submitted = SUBMITTED_TEXT.lock().unwrap().take();
‚ãÆ----
let continuous = *CFG_CONTINUOUS.lock().unwrap();
‚ãÆ----
let cb_lock = CFG_CALLBACK.lock().unwrap();
if let Some(cb) = cb_lock.as_ref() {
cb(text, hwnd);
‚ãÆ----
clear_editor_text();
‚ãÆ----
let _ = GetClientRect(hwnd, &mut rect);
‚ãÆ----
if (x - close_x).abs() < 15 && (y - close_y).abs() < 15 {
let _ = PostMessageW(Some(hwnd), WM_CLOSE, WPARAM(0), LPARAM(0));
return LRESULT(0);
‚ãÆ----
let _ = ReleaseCapture();
SendMessageW(hwnd, WM_SYSCOMMAND, Some(WPARAM(0xF012)), Some(LPARAM(0)));
‚ãÆ----
let hdc = BeginPaint(hwnd, &mut ps);
‚ãÆ----
let mem_dc = CreateCompatibleDC(Some(hdc));
let mem_bmp = CreateCompatibleBitmap(hdc, w, h);
let old_bmp = SelectObject(mem_dc, mem_bmp.into());
let brush_bg = CreateSolidBrush(COLORREF(COL_DARK_BG));
FillRect(mem_dc, &rect, brush_bg);
let _ = DeleteObject(brush_bg.into());
‚ãÆ----
SetPixel(mem_dc, px_screen, py_screen, COLORREF(fill_color));
‚ãÆ----
SetPixel(
‚ãÆ----
COLORREF((r << 16) | (g << 8) | b),
‚ãÆ----
SetBkMode(mem_dc, TRANSPARENT);
SetTextColor(mem_dc, COLORREF(0x00FFFFFF));
let h_font = CreateFontW(
‚ãÆ----
FONT_CHARSET(DEFAULT_CHARSET.0 as u8),
FONT_OUTPUT_PRECISION(OUT_DEFAULT_PRECIS.0 as u8),
FONT_CLIP_PRECISION(CLIP_DEFAULT_PRECIS.0 as u8),
FONT_QUALITY(CLEARTYPE_QUALITY.0 as u8),
‚ãÆ----
w!("Segoe UI"),
‚ãÆ----
let old_font = SelectObject(mem_dc, h_font.into());
let title_str = CFG_TITLE.lock().unwrap().clone();
let cur_lang = CFG_LANG.lock().unwrap().clone();
let cur_cancel = CFG_CANCEL.lock().unwrap().clone();
‚ãÆ----
let display_title = if !title_str.is_empty() {
‚ãÆ----
locale.text_input_title_default.to_string()
‚ãÆ----
DrawTextW(
‚ãÆ----
let h_font_small = CreateFontW(
‚ãÆ----
SelectObject(mem_dc, h_font_small.into());
SetTextColor(mem_dc, COLORREF(0x00AAAAAA));
let esc_text = if cur_cancel.is_empty() {
"Esc".to_string()
‚ãÆ----
format!("Esc / {}", cur_cancel)
‚ãÆ----
let hint = format!(
‚ãÆ----
DrawTextW(mem_dc, &mut hint_w, &mut r_hint, DT_CENTER | DT_SINGLELINE);
SelectObject(mem_dc, old_font);
let _ = DeleteObject(h_font.into());
let _ = DeleteObject(h_font_small.into());
‚ãÆ----
let pen = CreatePen(PS_SOLID, 2, COLORREF(0x00AAAAAA));
let old_pen = SelectObject(mem_dc, pen.into());
let _ = MoveToEx(mem_dc, c_cx - 5, c_cy - 5, None);
let _ = LineTo(mem_dc, c_cx + 5, c_cy + 5);
let _ = MoveToEx(mem_dc, c_cx + 5, c_cy - 5, None);
let _ = LineTo(mem_dc, c_cx - 5, c_cy + 5);
SelectObject(mem_dc, old_pen);
let _ = DeleteObject(pen.into());
let _ = BitBlt(hdc, 0, 0, w, h, Some(mem_dc), 0, 0, SRCCOPY);
SelectObject(mem_dc, old_bmp);
let _ = DeleteObject(mem_bmp.into());
let _ = DeleteDC(mem_dc);
let _ = EndPaint(hwnd, &mut ps);
‚ãÆ----
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
</file>

<file path="src/overlay/favorite_bubble/html.rs">
use crate::config::Preset;
use crate::gui::settings_ui::get_localized_preset_name;
pub fn generate_panel_html(
‚ãÆ----
let css = generate_panel_css(is_dark);
let favorites_html = get_favorite_presets_html(presets, lang, is_dark);
‚ãÆ----
format!(
‚ãÆ----
pub fn generate_panel_css(is_dark: bool) -> String {
‚ãÆ----
// Theme-specific colors
‚ãÆ----
pub fn get_favorite_presets_html(presets: &[Preset], lang: &str, is_dark: bool) -> String {
‚ãÆ----
for (idx, preset) in presets.iter().enumerate() {
‚ãÆ----
let name = if preset.id.starts_with("preset_") {
get_localized_preset_name(&preset.id, lang)
‚ãÆ----
preset.name.clone()
‚ãÆ----
let (icon_svg, color_hex) = match preset.preset_type.as_str() {
‚ãÆ----
let item = format!(
‚ãÆ----
html_items.push_str(&item);
‚ãÆ----
if html_items.is_empty() {
‚ãÆ----
html_items = format!(
‚ãÆ----
fn html_escape(s: &str) -> String {
s.replace('&', "&amp;")
.replace('<', "&lt;")
.replace('>', "&gt;")
.replace('"', "&quot;")
‚ãÆ----
pub fn escape_js(text: &str) -> String {
text.replace('\\', "\\\\")
.replace('"', "\\\"")
.replace('\n', "\\n")
.replace('\r', "")
</file>

<file path="src/overlay/recording.rs">
use crate::APP;
use std::cell::RefCell;
‚ãÆ----
use windows::Win32::UI::Controls::MARGINS;
‚ãÆ----
pub fn update_audio_viz(rms: f32) {
let bits = rms.to_bits();
CURRENT_RMS.store(bits, Ordering::Relaxed);
‚ãÆ----
thread_local! {
‚ãÆ----
pub fn is_recording_overlay_active() -> bool {
RECORDING_STATE.load(Ordering::SeqCst) == 2
‚ãÆ----
pub fn stop_recording_and_submit() {
if is_recording_overlay_active() {
let was_stopped = AUDIO_STOP_SIGNAL.load(Ordering::SeqCst);
‚ãÆ----
AUDIO_ABORT_SIGNAL.store(true, Ordering::SeqCst);
let hwnd_val = RECORDING_HWND_VAL.load(Ordering::SeqCst);
‚ãÆ----
let hwnd = HWND(hwnd_val as *mut _);
‚ãÆ----
let _ = PostMessageW(Some(hwnd), WM_APP_HIDE, WPARAM(0), LPARAM(0));
‚ãÆ----
AUDIO_STOP_SIGNAL.store(true, Ordering::SeqCst);
‚ãÆ----
let _ = PostMessageW(Some(hwnd), WM_APP_UPDATE_STATE, WPARAM(0), LPARAM(0));
‚ãÆ----
pub fn warmup_recording_overlay() {
‚ãÆ----
.compare_exchange(0, 1, Ordering::SeqCst, Ordering::SeqCst)
.is_ok()
‚ãÆ----
internal_create_recording_window();
‚ãÆ----
pub fn show_recording_overlay(preset_idx: usize) {
let current = RECORDING_STATE.load(Ordering::SeqCst);
if current == 0 || (current == 1 && RECORDING_HWND_VAL.load(Ordering::SeqCst) == 0) {
‚ãÆ----
RECORDING_STATE.store(0, Ordering::SeqCst);
‚ãÆ----
warmup_recording_overlay();
let ui_lang = APP.lock().unwrap().config.ui_language.clone();
‚ãÆ----
if RECORDING_HWND_VAL.load(Ordering::SeqCst) != 0 {
‚ãÆ----
let hwnd = HWND(RECORDING_HWND_VAL.load(Ordering::SeqCst) as *mut _);
‚ãÆ----
PostMessageW(Some(hwnd), WM_APP_SHOW, WPARAM(preset_idx), LPARAM(0));
‚ãÆ----
AUDIO_STOP_SIGNAL.store(false, Ordering::SeqCst);
AUDIO_PAUSE_SIGNAL.store(false, Ordering::SeqCst);
AUDIO_ABORT_SIGNAL.store(false, Ordering::SeqCst);
AUDIO_WARMUP_COMPLETE.store(false, Ordering::SeqCst);
CURRENT_RMS.store(0, Ordering::Relaxed);
‚ãÆ----
let _ = PostMessageW(
Some(HWND(hwnd_val as *mut _)),
‚ãÆ----
WPARAM(preset_idx),
LPARAM(0),
‚ãÆ----
struct HwndWrapper(HWND);
unsafe impl Send for HwndWrapper {}
unsafe impl Sync for HwndWrapper {}
‚ãÆ----
fn window_handle(
‚ãÆ----
std::num::NonZeroIsize::new(self.0 .0 as isize).expect("HWND cannot be null"),
‚ãÆ----
unsafe { Ok(raw_window_handle::WindowHandle::borrow_raw(handle)) }
‚ãÆ----
fn internal_create_recording_window() {
‚ãÆ----
let _ = CoInitialize(None); // Required for WebView
let instance = GetModuleHandleW(None).unwrap();
let class_name = w!("SGT_Recording_Persistent");
REGISTER_RECORDING_CLASS.call_once(|| {
‚ãÆ----
wc.lpfnWndProc = Some(recording_wnd_proc);
wc.hInstance = instance.into();
wc.hCursor = LoadCursorW(None, IDC_ARROW).unwrap();
‚ãÆ----
RegisterClassW(&wc);
‚ãÆ----
// Create window OFF-SCREEN initially (-4000, -4000)
// WS_POPUP | WS_VISIBLE (so WebView renders) but off-screen.
// Using Layered window for transparency
let hwnd = CreateWindowExW(
‚ãÆ----
w!("SGT Recording Web"),
‚ãÆ----
Some(instance.into()),
‚ãÆ----
.unwrap();
RECORDING_HWND_VAL.store(hwnd.0 as isize, Ordering::SeqCst);
// Windows 11 Rounded Corners - Disable native rounding to hide native border/shadow
// We rely on CSS for rounded corners + transparency
let corner_pref = 1u32; // DWMWCP_DONOTROUND
let _ = DwmSetWindowAttribute(
‚ãÆ----
// Glass Frame Extension (critical for per-pixel alpha with WebView)
‚ãÆ----
let _ = DwmExtendFrameIntoClientArea(hwnd, &margins);
// --- WEBVIEW CREATION ---
let wrapper = HwndWrapper(hwnd);
let html = generate_html();
RECORDING_WEB_CONTEXT.with(|ctx| {
if ctx.borrow().is_none() {
‚ãÆ----
*ctx.borrow_mut() = Some(WebContext::new(Some(shared_data_dir)));
‚ãÆ----
let webview_res = RECORDING_WEB_CONTEXT.with(|ctx| {
let mut ctx_ref = ctx.borrow_mut();
let mut builder = if let Some(web_ctx) = ctx_ref.as_mut() {
‚ãÆ----
.with_bounds(Rect {
‚ãÆ----
.with_transparent(true)
.with_background_color((0, 0, 0, 0)) // Fully transparent background
.with_html(&html)
.with_ipc_handler(move |msg: wry::http::Request<String>| {
let hwnd = HWND(ipc_hwnd_val as *mut std::ffi::c_void);
let body = msg.body().as_str();
‚ãÆ----
let paused = AUDIO_PAUSE_SIGNAL.load(Ordering::SeqCst);
AUDIO_PAUSE_SIGNAL.store(!paused, Ordering::SeqCst);
‚ãÆ----
// Handshake: WebView is ready (from resetState), so now we can REAL_SHOW
// Kill fallback timer 99
let _ = KillTimer(Some(hwnd), 99);
// Add a tiny delay to ensure paint catch-up
let _ = SetTimer(Some(hwnd), 2, 20, None);
‚ãÆ----
let _ = ReleaseCapture();
‚ãÆ----
Some(hwnd),
‚ãÆ----
WPARAM(2 as usize), // HTCAPTION = 2
LPARAM(0 as isize),
‚ãÆ----
.build(&wrapper)
‚ãÆ----
RECORDING_WEBVIEW.with(|cell| *cell.borrow_mut() = Some(wv));
// Setup Global Key Hook for ESC (This needs to be persistent or installed/uninstalled on show/hide)
// Better to install once and check `is_recording_overlay_active()` inside hook.
let hook = SetWindowsHookExW(
‚ãÆ----
Some(recording_hook_proc),
Some(GetModuleHandleW(None).unwrap().into()),
‚ãÆ----
// Message Loop
‚ãÆ----
while GetMessageW(&mut msg, None, 0, 0).as_bool() {
let _ = TranslateMessage(&msg);
let _ = DispatchMessageW(&msg);
‚ãÆ----
let _ = UnhookWindowsHookEx(h);
‚ãÆ----
// Cleanup on FULL EXIT
RECORDING_WEBVIEW.with(|cell| *cell.borrow_mut() = None);
‚ãÆ----
let _ = CoUninitialize();
‚ãÆ----
fn start_audio_thread(hwnd: HWND, preset_idx: usize) {
let preset = APP.lock().unwrap().config.presets[preset_idx].clone();
‚ãÆ----
let hwnd = HWND(hwnd_val as *mut std::ffi::c_void);
‚ãÆ----
AUDIO_STOP_SIGNAL.clone(),
AUDIO_PAUSE_SIGNAL.clone(),
AUDIO_ABORT_SIGNAL.clone(),
‚ãÆ----
unsafe extern "system" fn recording_wnd_proc(
‚ãÆ----
// 1. Prepare Content (while still off-screen)
‚ãÆ----
// Reset JS state
RECORDING_WEBVIEW.with(|cell| {
if let Some(wv) = cell.borrow().as_ref() {
let _ = wv.evaluate_script("resetState();");
‚ãÆ----
// 2. Start Audio Logic
start_audio_thread(hwnd, preset_idx);
// 3. Mark state as Active (Visible)
RECORDING_STATE.store(2, Ordering::SeqCst);
// 5. Fallback Timer (99) - If IPC ready signal doesn't come in 500ms, show anyway
SetTimer(Some(hwnd), 99, 500, None);
‚ãÆ----
.duration_since(std::time::UNIX_EPOCH)
.unwrap_or_default()
.as_millis() as u64;
LAST_SHOW_TIME.store(now, Ordering::SeqCst);
LRESULT(0)
‚ãÆ----
let _ = KillTimer(Some(hwnd), 2);
let _ = PostMessageW(Some(hwnd), WM_APP_REAL_SHOW, WPARAM(0), LPARAM(0));
‚ãÆ----
println!("Warning: Recording overlay IPC timed out, forcing show");
‚ãÆ----
let is_processing = AUDIO_STOP_SIGNAL.load(Ordering::SeqCst);
let is_paused = AUDIO_PAUSE_SIGNAL.load(Ordering::SeqCst);
let warming_up = !AUDIO_WARMUP_COMPLETE.load(Ordering::SeqCst);
let rms_bits = CURRENT_RMS.load(Ordering::Relaxed);
‚ãÆ----
let script = format!("updateState('{}', {});", state_str, rms);
‚ãÆ----
let _ = wv.evaluate_script(&script);
‚ãÆ----
if let Ok(app) = APP.try_lock() {
‚ãÆ----
let last_dark = LAST_THEME_IS_DARK.load(Ordering::SeqCst);
‚ãÆ----
LAST_THEME_IS_DARK.store(current_is_dark, Ordering::SeqCst);
‚ãÆ----
let theme_script = format!(
‚ãÆ----
let _ = wv.evaluate_script(&theme_script);
‚ãÆ----
let screen_x = GetSystemMetrics(SM_CXSCREEN);
let screen_y = GetSystemMetrics(SM_CYSCREEN);
‚ãÆ----
let _ = SetWindowPos(
‚ãÆ----
Some(HWND_TOPMOST),
‚ãÆ----
let _ = SetTimer(Some(hwnd), 1, 16, None);
‚ãÆ----
let _ = wv.evaluate_script(
‚ãÆ----
let _ = KillTimer(Some(hwnd), 1);
‚ãÆ----
let _ = wv.evaluate_script("hideState();");
‚ãÆ----
RECORDING_STATE.store(1, Ordering::SeqCst);
‚ãÆ----
let is_stop = AUDIO_STOP_SIGNAL.load(Ordering::SeqCst);
let is_abort = AUDIO_ABORT_SIGNAL.load(Ordering::SeqCst);
‚ãÆ----
let last = LAST_SHOW_TIME.load(Ordering::SeqCst);
‚ãÆ----
let _ = DestroyWindow(hwnd);
PostQuitMessage(0);
‚ãÆ----
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
‚ãÆ----
unsafe extern "system" fn recording_hook_proc(
‚ãÆ----
stop_recording_and_submit();
return LRESULT(1);
‚ãÆ----
CallNextHookEx(None, code, wparam, lparam)
‚ãÆ----
fn generate_html() -> String {
‚ãÆ----
let app = APP.lock().unwrap();
let lang = app.config.ui_language.as_str();
‚ãÆ----
LAST_THEME_IS_DARK.store(is_dark, Ordering::SeqCst);
‚ãÆ----
format!(
</file>

<file path="src/overlay/result/markdown_view.rs">
use std::collections::HashMap;
use std::num::NonZeroIsize;
‚ãÆ----
use windows::core::w;
‚ãÆ----
static mut WARMUP_HWND: HWND = HWND(std::ptr::null_mut());
‚ãÆ----
thread_local! {
‚ãÆ----
struct HwndWrapper(HWND);
impl HasWindowHandle for HwndWrapper {
fn window_handle(&self) -> Result<WindowHandle<'_>, HandleError> {
‚ãÆ----
// hinstance is optional, can be null
‚ãÆ----
// Safety: the handle is valid for the lifetime of HwndWrapper
Ok(unsafe { WindowHandle::borrow_raw(raw) })
‚ãÆ----
Err(HandleError::Unavailable)
‚ãÆ----
/// Warmup markdown WebView - call from main.rs at app startup
/// This pre-initializes WebView2 infrastructure from the main thread context
‚ãÆ----
/// This pre-initializes WebView2 infrastructure from the main thread context
pub fn warmup() {
‚ãÆ----
pub fn warmup() {
‚ãÆ----
warmup_internal();
‚ãÆ----
fn warmup_internal() {
‚ãÆ----
let instance = GetModuleHandleW(None).unwrap();
let class_name = w!("SGT_MarkdownWarmup");
REGISTER_WARMUP_CLASS.call_once(|| {
‚ãÆ----
wc.lpfnWndProc = Some(warmup_wnd_proc);
wc.hInstance = instance.into();
‚ãÆ----
wc.hbrBackground = HBRUSH(std::ptr::null_mut());
let _ = RegisterClassW(&wc);
‚ãÆ----
// Create a small hidden window with WS_EX_NOACTIVATE to prevent focus stealing
let hwnd = CreateWindowExW(
‚ãÆ----
w!("MarkdownWarmup"),
‚ãÆ----
Some(instance.into()),
‚ãÆ----
.unwrap_or_default();
‚ãÆ----
// Make it transparent (invisible)
let _ = SetLayeredWindowAttributes(hwnd, COLORREF(0), 0, LWA_ALPHA);
// Initialize shared WebContext for this thread (reduces RAM by sharing browser processes)
// All modules use the same data directory, so WebView2 shares browser processes
‚ãÆ----
SHARED_WEB_CONTEXT.with(|ctx| {
if ctx.borrow().is_none() {
*ctx.borrow_mut() = Some(WebContext::new(Some(shared_data_dir)));
‚ãÆ----
// Create a WebView to warm up WebView2 infrastructure using shared context
// Include font CSS AND render text in those fonts to force browser to download them
let warmup_html = format!(
‚ãÆ----
let wrapper = HwndWrapper(hwnd);
let result = SHARED_WEB_CONTEXT.with(|ctx| {
let mut ctx_ref = ctx.borrow_mut();
if let Some(web_ctx) = ctx_ref.as_mut() {
‚ãÆ----
.with_bounds(Rect {
‚ãÆ----
.with_html(&warmup_html)
.with_transparent(false);
‚ãÆ----
.build_as_child(&wrapper)
‚ãÆ----
// Fallback without context
‚ãÆ----
WARMUP_WEBVIEW.with(|wv| {
*wv.borrow_mut() = Some(webview);
‚ãÆ----
// Mark as ready
if let Ok(mut ready) = WEBVIEW_READY.lock() {
‚ãÆ----
// Warmup failed - WebView2 may not work
‚ãÆ----
// Message loop to keep the warmup thread alive
‚ãÆ----
while GetMessageW(&mut msg, None, 0, 0).into() {
let _ = TranslateMessage(&msg);
DispatchMessageW(&msg);
‚ãÆ----
unsafe extern "system" fn warmup_wnd_proc(
‚ãÆ----
DefWindowProcW(hwnd, msg, wparam, lparam)
‚ãÆ----
fn get_font_style() -> String {
format!(
‚ãÆ----
fn is_html_content(content: &str) -> bool {
let trimmed = content.trim();
trimmed.starts_with("<!DOCTYPE") ||
trimmed.starts_with("<!doctype") ||
trimmed.starts_with("<html") ||
trimmed.starts_with("<HTML") ||
(trimmed.contains("<html") && trimmed.contains("</html>")) ||
(trimmed.contains("<head") && trimmed.contains("</head>")) ||
is_html_fragment(content)
‚ãÆ----
fn is_html_fragment(content: &str) -> bool {
let lower = content.to_lowercase();
(lower.contains("<script") || lower.contains("<style"))
&& !lower.contains("<!doctype")
&& !lower.contains("<html")
‚ãÆ----
fn wrap_html_fragment(fragment: &str) -> String {
‚ãÆ----
/// Inject localStorage/sessionStorage polyfill into HTML for WebView2 compatibility
/// WebView2's with_html() runs in a sandboxed context that denies storage access
‚ãÆ----
/// WebView2's with_html() runs in a sandboxed context that denies storage access
/// This provides an in-memory fallback so scripts don't crash
‚ãÆ----
/// This provides an in-memory fallback so scripts don't crash
fn inject_storage_polyfill(html: &str) -> String {
‚ãÆ----
fn inject_storage_polyfill(html: &str) -> String {
// First, wrap HTML fragments in a proper document structure
// This ensures WebView2 can properly parse the DOM (fixes "null" getElementById errors)
let html = if is_html_fragment(html) {
wrap_html_fragment(html)
‚ãÆ----
html.to_string()
‚ãÆ----
let lower = html.to_lowercase();
if let Some(pos) = lower.find("<head>") {
‚ãÆ----
let mut result = html[..insert_pos].to_string();
result.push_str(polyfill);
result.push_str(&html[insert_pos..]);
‚ãÆ----
} else if let Some(pos) = lower.find("<head ") {
if let Some(end) = html[pos..].find('>') {
‚ãÆ----
format!("{}{}", polyfill, html)
‚ãÆ----
} else if let Some(pos) = lower.find("<html>") {
‚ãÆ----
} else if let Some(pos) = lower.find("<html ") {
‚ãÆ----
fn inject_gridjs(html: &str) -> String {
if !html.contains("<table") {
return html.to_string();
‚ãÆ----
let gridjs_head = format!(
‚ãÆ----
let gridjs_body = format!(
‚ãÆ----
let mut result = html.to_string();
// Inject CSS/JS into <head>
if let Some(pos) = lower.find("</head>") {
result.insert_str(pos, &gridjs_head);
} else if let Some(pos) = lower.find("<body>") {
‚ãÆ----
result.insert_str(0, &gridjs_head);
‚ãÆ----
// Inject init script into <body>
let lower_updated = result.to_lowercase();
if let Some(pos) = lower_updated.find("</body>") {
result.insert_str(pos, &gridjs_body);
‚ãÆ----
result.push_str(&gridjs_body);
‚ãÆ----
/// Convert markdown text to styled HTML, or pass through raw HTML
pub fn markdown_to_html(
‚ãÆ----
pub fn markdown_to_html(
‚ãÆ----
let combined = if input_text.is_empty() {
preset_prompt.to_string()
‚ãÆ----
format!("{}\n\n{}", preset_prompt, input_text)
‚ãÆ----
return format!(
‚ãÆ----
// If input is already HTML, inject localStorage polyfill and Grid.js
if is_html_content(markdown) {
let with_storage = inject_storage_polyfill(markdown);
return inject_gridjs(&with_storage);
‚ãÆ----
options.insert(Options::ENABLE_TABLES);
options.insert(Options::ENABLE_STRIKETHROUGH);
options.insert(Options::ENABLE_TASKLISTS);
‚ãÆ----
// Grid.js Integration
let has_table = html_output.contains("<table");
‚ãÆ----
/// Create a WebView child window for markdown rendering
/// Must be called from the main thread!
‚ãÆ----
/// Must be called from the main thread!
pub fn create_markdown_webview(parent_hwnd: HWND, markdown_text: &str, is_hovered: bool) -> bool {
‚ãÆ----
pub fn create_markdown_webview(parent_hwnd: HWND, markdown_text: &str, is_hovered: bool) -> bool {
// Check if warmed up
let is_ready = WEBVIEW_READY.lock().map(|g| *g).unwrap_or(false);
‚ãÆ----
// Trigger warmup for recovery
warmup();
// Show localized message that feature is not ready yet
let ui_lang = crate::APP.lock().unwrap().config.ui_language.clone();
‚ãÆ----
// Wait up to 5 seconds
‚ãÆ----
if WEBVIEW_READY.lock().map(|g| *g).unwrap_or(false) {
‚ãÆ----
if !WEBVIEW_READY.lock().map(|g| *g).unwrap_or(false) {
‚ãÆ----
let states = super::state::WINDOW_STATES.lock().unwrap();
if let Some(state) = states.get(&hwnd_key) {
‚ãÆ----
state.preset_prompt.clone(),
state.input_text.clone(),
‚ãÆ----
create_markdown_webview_ex(
‚ãÆ----
/// Create a WebView child window for markdown rendering (Internal version, call without lock if possible)
pub fn create_markdown_webview_ex(
‚ãÆ----
pub fn create_markdown_webview_ex(
‚ãÆ----
// Check if we already have a webview
let exists = WEBVIEWS.with(|webviews| webviews.borrow().contains_key(&hwnd_key));
‚ãÆ----
return update_markdown_content_ex(
‚ãÆ----
// Get parent window rect
‚ãÆ----
let _ = GetClientRect(parent_hwnd, &mut rect);
‚ãÆ----
let html_content = markdown_to_html(markdown_text, is_refining, preset_prompt, input_text);
let wrapper = HwndWrapper(parent_hwnd);
// Small margin on edges for resize handle accessibility (2px)
// 52px at bottom for buttons (btn_size 28 + margin 12 * 2) if hovered
‚ãÆ----
let content_width = ((rect.right - rect.left) as f64 - edge_margin * 2.0).max(50.0);
‚ãÆ----
((rect.bottom - rect.top) as f64 - edge_margin - button_area_height).max(50.0);
// Create WebView with small margins so resize handles remain accessible
// Use Physical coordinates since GetClientRect returns physical pixels
‚ãÆ----
// SIMPLIFIED FOR DEBUGGING - minimal WebView creation
// CRITICAL: with_transparent(false) matches text_input's working config
‚ãÆ----
.with_html(&html_content)
.with_transparent(false)
.with_navigation_handler(move |url: String| {
// Check if we should skip this navigation (triggered by history.back())
‚ãÆ----
let mut skip_map = SKIP_NEXT_NAVIGATION.lock().unwrap();
if skip_map.get(&hwnd_key_for_nav).copied().unwrap_or(false) {
skip_map.insert(hwnd_key_for_nav, false);
‚ãÆ----
// This navigation was from history.back(), don't increment depth
‚ãÆ----
// Detect when user navigates to an external URL (clicked a link)
// CRITICAL: Exclude wry internal URLs to prevent counting original content as browsing
let is_internal = url.contains("wry.localhost")
|| url.contains("localhost")
|| url.contains("127.0.0.1")
|| url.starts_with("data:")
|| url.starts_with("about:");
‚ãÆ----
(url.starts_with("http://") || url.starts_with("https://")) && !is_internal;
‚ãÆ----
if let Ok(mut states) = super::state::WINDOW_STATES.lock() {
if let Some(state) = states.get_mut(&hwnd_key_for_nav) {
‚ãÆ----
super::refine_input::hide_refine_input(HWND(
‚ãÆ----
Some(HWND(hwnd_key_for_nav as *mut std::ffi::c_void)),
‚ãÆ----
.with_ipc_handler(move |msg: wry::http::Request<String>| {
let body = msg.body();
if body.starts_with("opacity:") {
if let Ok(opacity_percent) = body["opacity:".len()..].parse::<f32>() {
‚ãÆ----
use windows::Win32::Foundation::COLORREF;
‚ãÆ----
SetLayeredWindowAttributes(parent_hwnd, COLORREF(0), alpha, LWA_ALPHA);
‚ãÆ----
.build_as_child(&wrapper);
‚ãÆ----
WEBVIEWS.with(|webviews| {
webviews.borrow_mut().insert(hwnd_key, webview);
‚ãÆ----
let mut states = WEBVIEW_STATES.lock().unwrap();
states.insert(hwnd_key, true);
‚ãÆ----
pub fn go_back(parent_hwnd: HWND) {
‚ãÆ----
let mut states = super::state::WINDOW_STATES.lock().unwrap();
if let Some(state) = states.get_mut(&hwnd_key) {
‚ãÆ----
(true, state.full_text.clone(), state.is_hovered)
‚ãÆ----
create_markdown_webview(parent_hwnd, &markdown_text, is_hovered);
‚ãÆ----
let _ = windows::Win32::Graphics::Gdi::InvalidateRect(Some(parent_hwnd), None, false);
‚ãÆ----
skip_map.insert(hwnd_key, true);
‚ãÆ----
if let Some(webview) = webviews.borrow().get(&hwnd_key) {
let _ = webview.evaluate_script("history.back();");
‚ãÆ----
pub fn go_forward(parent_hwnd: HWND) {
‚ãÆ----
let _ = webview.evaluate_script("history.forward();");
‚ãÆ----
pub fn update_markdown_content(parent_hwnd: HWND, markdown_text: &str) -> bool {
‚ãÆ----
update_markdown_content_ex(
‚ãÆ----
fn content_needs_recreation(html: &str) -> bool {
‚ãÆ----
lower.contains("<script")
&& (lower.contains("localstorage")
|| lower.contains("sessionstorage")
|| lower.contains("indexeddb")
|| lower.contains("const ")
|| lower.contains("let ")
|| lower.contains("var "))
‚ãÆ----
pub fn update_markdown_content_ex(
‚ãÆ----
let html = markdown_to_html(markdown_text, is_refining, preset_prompt, input_text);
if content_needs_recreation(&html) {
destroy_markdown_webview(parent_hwnd);
‚ãÆ----
if let Ok(states) = super::state::WINDOW_STATES.lock() {
states.get(&hwnd_key).map(|s| s.is_hovered).unwrap_or(false)
‚ãÆ----
return create_markdown_webview_ex(
‚ãÆ----
.replace('\\', "\\\\")
.replace('`', "\\`")
.replace("${", "\\${");
let script = format!(
‚ãÆ----
let _ = webview.evaluate_script(&script);
‚ãÆ----
pub fn resize_markdown_webview(parent_hwnd: HWND, is_hovered: bool) {
‚ãÆ----
((rect.bottom - rect.top) as f64 - top_offset - button_area_height).max(50.0);
‚ãÆ----
let _ = webview.set_bounds(Rect {
‚ãÆ----
pub fn hide_markdown_webview(parent_hwnd: HWND) {
‚ãÆ----
let _ = webview.set_visible(false);
‚ãÆ----
pub fn show_markdown_webview(parent_hwnd: HWND) {
‚ãÆ----
let _ = webview.set_visible(true);
‚ãÆ----
pub fn destroy_markdown_webview(parent_hwnd: HWND) {
‚ãÆ----
webviews.borrow_mut().remove(&hwnd_key);
‚ãÆ----
states.remove(&hwnd_key);
‚ãÆ----
pub fn has_markdown_webview(parent_hwnd: HWND) -> bool {
‚ãÆ----
let states = WEBVIEW_STATES.lock().unwrap();
states.get(&hwnd_key).copied().unwrap_or(false)
‚ãÆ----
fn generate_filename(content: &str) -> String {
let default_name = "game.html".to_string();
let groq_key = if let Ok(app) = crate::APP.lock() {
app.config.api_key.clone()
‚ãÆ----
if groq_key.is_empty() {
‚ãÆ----
let prompt_content = if content.len() > 4000 {
‚ãÆ----
let prompt = format!(
‚ãÆ----
.post("https://api.groq.com/openai/v1/chat/completions")
.header("Authorization", &format!("Bearer {}", groq_key))
.send_json(payload)
‚ãÆ----
if let Ok(json) = resp.into_body().read_json::<serde_json::Value>() {
‚ãÆ----
.get("choices")
.and_then(|c| c.as_array())
.and_then(|c| c.first())
‚ãÆ----
.get("message")
.and_then(|m| m.get("content"))
.and_then(|s| s.as_str())
‚ãÆ----
let mut name = content.trim().to_string();
name = name.replace('"', "").replace('\'', "").replace('`', "");
// Remove potential .html extension if the model disobeyed
if name.to_lowercase().ends_with(".html") {
name = name[..name.len() - 5].to_string();
‚ãÆ----
if name.to_lowercase().ends_with("-html") {
‚ãÆ----
} else if name.to_lowercase().ends_with("_html") {
‚ãÆ----
.chars()
.filter(|c| !invalid_chars.contains(c))
.collect();
if name.is_empty() {
‚ãÆ----
name.push_str(".html");
‚ãÆ----
eprintln!("Failed to generate filename: {}", e);
‚ãÆ----
pub fn save_html_file(markdown_text: &str) -> bool {
use std::ffi::OsStr;
use std::os::windows::ffi::OsStrExt;
use windows::core::PCWSTR;
‚ãÆ----
use windows::Win32::UI::Shell::Common::COMDLG_FILTERSPEC;
use windows::Win32::UI::Shell::KNOWN_FOLDER_FLAG;
‚ãÆ----
let _ = CoInitializeEx(None, COINIT_APARTMENTTHREADED);
let dialog: IFileSaveDialog = match CoCreateInstance(&FileSaveDialog, None, CLSCTX_ALL) {
‚ãÆ----
CoUninitialize();
‚ãÆ----
.encode_wide()
.chain(std::iter::once(0))
‚ãÆ----
pszName: windows::core::PCWSTR(filter_name.as_ptr()),
pszSpec: windows::core::PCWSTR(filter_pattern.as_ptr()),
‚ãÆ----
let _ = dialog.SetFileTypes(&file_types);
let _ = dialog.SetFileTypeIndex(1);
‚ãÆ----
SHGetKnownFolderPath(&FOLDERID_Downloads, KNOWN_FOLDER_FLAG(0), None)
‚ãÆ----
SHCreateItemFromParsingName::<PCWSTR, _, IShellItem>(PCWSTR(downloads_path.0), None)
‚ãÆ----
let _ = dialog.SetFolder(&folder_item);
‚ãÆ----
let _ = dialog.SetDefaultExtension(windows::core::PCWSTR(default_ext.as_ptr()));
let filename = generate_filename(markdown_text);
‚ãÆ----
let _ = dialog.SetFileName(windows::core::PCWSTR(default_name.as_ptr()));
let _ = dialog.SetOptions(FOS_OVERWRITEPROMPT | FOS_STRICTFILETYPES);
if dialog.Show(None).is_err() {
‚ãÆ----
let result: windows::Win32::UI::Shell::IShellItem = match dialog.GetResult() {
‚ãÆ----
let path: windows::core::PWSTR = match result.GetDisplayName(SIGDN_FILESYSPATH) {
‚ãÆ----
let path_str = path.to_string().unwrap_or_default();
windows::Win32::System::Com::CoTaskMemFree(Some(path.0 as *const _));
‚ãÆ----
let html_content = markdown_to_html(markdown_text, false, "", "");
</file>

<file path="Cargo.toml">
[package]
name = "screen-goated-toolbox"
version = "3.9.0"
edition = "2021"

[build-dependencies]
winres = "0.1"
image = { version = "0.25", default-features = false, features = ["png", "bmp"] }

[dependencies]
# Network & Serialization
ureq = { version = "3.1", features = ["json"] }
tungstenite = { version = "0.28", features = ["native-tls"] }
native-tls = "0.2"
url = "2.5"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
anyhow = "1.0"
base64 = "0.22"
self_update = { version = "0.42", features = ["archive-zip", "compression-zip-deflate"] }
zip = "7.0"

# Image Processing (Common formats for drag-and-drop)
image = { version = "0.25", default-features = false, features = ["png", "bmp", "jpeg", "gif", "webp", "tiff"] }

# Time
chrono = { version = "0.4", features = ["serde"] }

# System
dirs = "6.0"
lazy_static = "1.5"
textwrap = "0.16"
open = "5.3"
sys-locale = "0.3"
winreg = "0.55"
auto-launch = "0.5"
urlencoding = "2.1"

# Language Data (Kept as requested)
isolang = { version = "2.4", features = ["serde", "english_names"] }
whatlang = "0.18"

# GUI & Media
eframe = { version = "0.33", default-features = false, features = ["glow"] }
egui-snarl = { path = "libs/egui-snarl", features = ["serde"] }
tray-icon = "0.21.3"
cpal = "0.17"
hound = "3.5"
wasapi = "0.22"
minimp3 = "0.6"
# Audio file decoding (MP3, FLAC, OGG, WAV, AAC, ALAC)
symphonia = { version = "0.5", features = ["mp3", "flac", "ogg", "wav", "aac", "alac", "pcm"] }

# Markdown Rendering
pulldown-cmark = "0.13"
wry = "0.53.5"
raw-window-handle = "0.6"
windows-core = "0.62"

[dependencies.windows]
version = "0.62"
features = [
    "Win32_Foundation",
    "Win32_UI_WindowsAndMessaging",
    "Win32_UI_Controls",
    "Win32_Graphics_Gdi",
    "Win32_UI_Input_KeyboardAndMouse",
    "Win32_System_LibraryLoader",
    "Win32_System_SystemServices",
    "Win32_Graphics_Dwm",
    "Win32_UI_HiDpi",
    "Win32_System_Threading",
    "Win32_Security",
    "Win32_System_Com",
    "Win32_System_DataExchange",
    "Win32_System_Memory",
    "Win32_Media_Audio",
    "Win32_System_SystemInformation",
    "Win32_UI_Shell",
    "Win32_UI_Shell_Common",
    "Win32_UI_Magnification",
]

[profile.release]
opt-level = "z"
lto = true
codegen-units = 1
strip = true
panic = "unwind"

# AV-safe profile for nopack version - keeps debug info for better AV analysis
[profile.release-safe]
inherits = "release"
strip = "symbols"  # Keep minimal debug info
debug = 1          # Include basic debug info for AV scanners
</file>

<file path="src/gui/settings_ui/sidebar.rs">
use super::ViewMode;
‚ãÆ----
use crate::gui::locale::LocaleText;
use eframe::egui;
pub fn get_localized_preset_name(preset_id: &str, lang_code: &str) -> String {
‚ãÆ----
("preset_translate", "vi") => "D·ªãch v√πng".to_string(),
("preset_extract_retranslate", "vi") => "D·ªãch v√πng (CHU·∫®N)".to_string(),
("preset_translate_auto_paste", "vi") => "D·ªãch v√πng (T·ª± d√°n)".to_string(),
("preset_translate_retranslate", "vi") => "D·ªãch v√πng+D·ªãch l·∫°i".to_string(),
("preset_extract_retrans_retrans", "vi") => "D.v√πng (CHU·∫®N)+D.l·∫°i".to_string(),
("preset_ocr", "vi") => "L·∫•y text t·ª´ ·∫£nh".to_string(),
("preset_quick_screenshot", "vi") => "Ch·ª•p MH nhanh".to_string(),
("preset_quick_screenshot", "ko") => "Îπ†Î•∏ Ïä§ÌÅ¨Î¶∞ÏÉ∑".to_string(),
("preset_quick_screenshot", _) => "Quick screenshot".to_string(),
("preset_ocr_read", "vi") => "ƒê·ªçc v√πng n√†y".to_string(),
("preset_summarize", "vi") => "T√≥m t·∫Øt v√πng".to_string(),
("preset_desc", "vi") => "M√¥ t·∫£ ·∫£nh".to_string(),
("preset_ask_image", "vi") => "H·ªèi v·ªÅ ·∫£nh".to_string(),
("preset_translate_select", "vi") => "D·ªãch".to_string(),
("preset_translate_arena", "vi") => "D·ªãch (Arena)".to_string(),
("preset_read_aloud", "vi") => "ƒê·ªçc to".to_string(),
("preset_trans_retrans_select", "vi") => "D·ªãch+ D·ªãch l·∫°i".to_string(),
("preset_select_translate_replace", "vi") => "D·ªãch v√† Thay".to_string(),
("preset_fix_grammar", "vi") => "S·ª≠a ng·ªØ ph√°p".to_string(),
("preset_rephrase", "vi") => "Vi·∫øt l·∫°i".to_string(),
("preset_make_formal", "vi") => "Chuy√™n nghi·ªáp h√≥a".to_string(),
("preset_explain", "vi") => "Gi·∫£i th√≠ch".to_string(),
("preset_ask_text", "vi") => "H·ªèi v·ªÅ text...".to_string(),
("preset_edit_as_follows", "vi") => "S·ª≠a nh∆∞ sau:".to_string(),
("preset_extract_table", "vi") => "Tr√≠ch b·∫£ng".to_string(),
("preset_qr_scanner", "vi") => "Qu√©t m√£ QR".to_string(),
("preset_trans_retrans_typing", "vi") => "D·ªãch+D·ªãch l·∫°i (T·ª± g√µ)".to_string(),
("preset_ask_ai", "vi") => "H·ªèi AI".to_string(),
("preset_internet_search", "vi") => "T√¨m ki·∫øm internet".to_string(),
("preset_make_game", "vi") => "T·∫°o con game".to_string(),
("preset_transcribe", "vi") => "L·ªùi n√≥i th√†nh vƒÉn".to_string(),
("preset_fix_pronunciation", "vi") => "Ch·ªânh ph√°t √¢m".to_string(),
("preset_study_language", "vi") => "H·ªçc ngo·∫°i ng·ªØ".to_string(),
("preset_transcribe_retranslate", "vi") => "Tr·∫£ l·ªùi ng.nc.ngo√†i 1".to_string(),
("preset_quicker_foreigner_reply", "vi") => "Tr·∫£ l·ªùi ng.nc.ngo√†i 2".to_string(),
("preset_fact_check", "vi") => "Ki·ªÉm ch·ª©ng th√¥ng tin".to_string(),
("preset_omniscient_god", "vi") => "Th·∫ßn Tr√≠ tu·ªá".to_string(),
("preset_realtime_audio_translate", "vi") => "D·ªãch cabin".to_string(),
("preset_quick_ai_question", "vi") => "H·ªèi nhanh AI".to_string(),
("preset_voice_search", "vi") => "N√≥i ƒë·ªÉ search".to_string(),
("preset_hang_image", "vi") => "Treo ·∫£nh".to_string(),
("preset_hang_text", "vi") => "Treo text".to_string(),
("preset_quick_note", "vi") => "Note nhanh".to_string(),
("preset_quick_record", "vi") => "Thu √¢m nhanh".to_string(),
("preset_record_device", "vi") => "Thu √¢m m√°y".to_string(),
("preset_image_master", "vi") => "·∫¢nh MASTER".to_string(),
("preset_text_select_master", "vi") => "B√¥i MASTER".to_string(),
("preset_text_type_master", "vi") => "G√µ MASTER".to_string(),
("preset_audio_mic_master", "vi") => "Mic MASTER".to_string(),
("preset_audio_device_master", "vi") => "Ti·∫øng MASTER".to_string(),
("preset_translate", "ko") => "ÏòÅÏó≠ Î≤àÏó≠".to_string(),
("preset_extract_retranslate", "ko") => "ÏòÅÏó≠ Î≤àÏó≠ (Ï†ïÌôï)".to_string(),
("preset_translate_auto_paste", "ko") => "ÏòÅÏó≠ Î≤àÏó≠ (ÏûêÎèô Î∂ô.)".to_string(),
("preset_translate_retranslate", "ko") => "ÏòÅÏó≠ Î≤àÏó≠+Ïû¨Î≤àÏó≠".to_string(),
("preset_extract_retrans_retrans", "ko") => "ÏòÅ.Î≤àÏó≠ (Ï†ïÌôï)+Ïû¨Î≤àÏó≠".to_string(),
("preset_ocr", "ko") => "ÌÖçÏä§Ìä∏ Ï∂îÏ∂ú".to_string(),
("preset_ocr_read", "ko") => "ÏòÅÏó≠ ÏùΩÍ∏∞".to_string(),
("preset_summarize", "ko") => "ÏòÅÏó≠ ÏöîÏïΩ".to_string(),
("preset_desc", "ko") => "Ïù¥ÎØ∏ÏßÄ ÏÑ§Î™Ö".to_string(),
("preset_ask_image", "ko") => "Ïù¥ÎØ∏ÏßÄ ÏßàÎ¨∏".to_string(),
("preset_translate_select", "ko") => "Î≤àÏó≠ (ÏÑ†ÌÉù ÌÖçÏä§Ìä∏)".to_string(),
("preset_translate_arena", "ko") => "Î≤àÏó≠ (ÏïÑÎ†àÎÇò)".to_string(),
("preset_read_aloud", "ko") => "ÌÅ¨Í≤å ÏùΩÍ∏∞".to_string(),
("preset_trans_retrans_select", "ko") => "Î≤àÏó≠+Ïû¨Î≤àÏó≠ (ÏÑ†ÌÉù)".to_string(),
("preset_select_translate_replace", "ko") => "ÏÑ†ÌÉù-Î≤àÏó≠-ÍµêÏ≤¥".to_string(),
("preset_fix_grammar", "ko") => "Î¨∏Î≤ï ÏàòÏ†ï".to_string(),
("preset_rephrase", "ko") => "Îã§Ïãú Ïì∞Í∏∞".to_string(),
("preset_make_formal", "ko") => "Í≥µÏãùÏ†ÅÏúºÎ°ú".to_string(),
("preset_explain", "ko") => "ÏÑ§Î™Ö".to_string(),
("preset_ask_text", "ko") => "ÌÖçÏä§Ìä∏ ÏßàÎ¨∏...".to_string(),
("preset_edit_as_follows", "ko") => "Îã§ÏùåÍ≥º Í∞ôÏù¥ ÏàòÏ†ï:".to_string(),
("preset_extract_table", "ko") => "Ìëú Ï∂îÏ∂ú".to_string(),
("preset_qr_scanner", "ko") => "QR Ïä§Ï∫î".to_string(),
("preset_trans_retrans_typing", "ko") => "Î≤àÏó≠+Ïû¨Î≤àÏó≠ (ÏûÖÎ†•)".to_string(),
("preset_ask_ai", "ko") => "AI ÏßàÎ¨∏".to_string(),
("preset_internet_search", "ko") => "Ïù∏ÌÑ∞ÎÑ∑ Í≤ÄÏÉâ".to_string(),
("preset_make_game", "ko") => "Í≤åÏûÑ ÎßåÎì§Í∏∞".to_string(),
("preset_transcribe", "ko") => "ÏùåÏÑ± Î∞õÏïÑÏì∞Í∏∞".to_string(),
("preset_fix_pronunciation", "ko") => "Î∞úÏùå ÍµêÏ†ï".to_string(),
("preset_study_language", "ko") => "Ïñ∏Ïñ¥ ÌïôÏäµ".to_string(),
("preset_transcribe_retranslate", "ko") => "Îπ†Î•∏ Ïô∏Íµ≠Ïù∏ ÎãµÎ≥Ä 1".to_string(),
("preset_quicker_foreigner_reply", "ko") => "Îπ†Î•∏ Ïô∏Íµ≠Ïù∏ ÎãµÎ≥Ä 2".to_string(),
("preset_fact_check", "ko") => "Ï†ïÎ≥¥ ÌôïÏù∏".to_string(),
("preset_omniscient_god", "ko") => "Ï†ÑÏßÄÏ†ÑÎä•Ìïú Ïã†".to_string(),
("preset_realtime_audio_translate", "ko") => "Ïã§ÏãúÍ∞Ñ ÏùåÏÑ± Î≤àÏó≠".to_string(),
("preset_quick_ai_question", "ko") => "Îπ†Î•∏ AI ÏßàÎ¨∏".to_string(),
("preset_voice_search", "ko") => "ÏùåÏÑ± Í≤ÄÏÉâ".to_string(),
("preset_hang_image", "ko") => "Ïù¥ÎØ∏ÏßÄ Ïò§Î≤ÑÎ†àÏù¥".to_string(),
("preset_hang_text", "ko") => "ÌÖçÏä§Ìä∏ Ïò§Î≤ÑÎ†àÏù¥".to_string(),
("preset_quick_note", "ko") => "Îπ†Î•∏ Î©îÎ™®".to_string(),
("preset_quick_record", "ko") => "Îπ†Î•∏ ÎÖπÏùå".to_string(),
("preset_record_device", "ko") => "ÏãúÏä§ÌÖú ÎÖπÏùå".to_string(),
("preset_image_master", "ko") => "Ïù¥ÎØ∏ÏßÄ ÎßàÏä§ÌÑ∞".to_string(),
("preset_text_select_master", "ko") => "ÏÑ†ÌÉù ÎßàÏä§ÌÑ∞".to_string(),
("preset_text_type_master", "ko") => "ÏûÖÎ†• ÎßàÏä§ÌÑ∞".to_string(),
("preset_audio_mic_master", "ko") => "ÎßàÏù¥ÌÅ¨ ÎßàÏä§ÌÑ∞".to_string(),
("preset_audio_device_master", "ko") => "ÏÇ¨Ïö¥Îìú ÎßàÏä§ÌÑ∞".to_string(),
("preset_translate", _) => "Translate region".to_string(),
("preset_extract_retranslate", _) => "Trans reg (ACCURATE)".to_string(),
("preset_translate_auto_paste", _) => "Trans reg (Auto paste)".to_string(),
("preset_translate_retranslate", _) => "Trans reg+Retrans".to_string(),
("preset_extract_retrans_retrans", _) => "Trans (ACC)+Retrans".to_string(),
("preset_ocr", _) => "Extract text".to_string(),
("preset_ocr_read", _) => "Read this region".to_string(),
("preset_summarize", _) => "Summarize region".to_string(),
("preset_desc", _) => "Describe image".to_string(),
("preset_ask_image", _) => "Ask about image".to_string(),
("preset_translate_select", _) => "Trans (Select text)".to_string(),
("preset_translate_arena", _) => "Trans (Arena)".to_string(),
("preset_read_aloud", _) => "Read aloud".to_string(),
("preset_trans_retrans_select", _) => "Trans+Retrans (Select)".to_string(),
("preset_select_translate_replace", _) => "Select-Trans-Replace".to_string(),
("preset_fix_grammar", _) => "Fix Grammar".to_string(),
("preset_rephrase", _) => "Rephrase".to_string(),
("preset_make_formal", _) => "Make Formal".to_string(),
("preset_explain", _) => "Explain".to_string(),
("preset_ask_text", _) => "Ask about text...".to_string(),
("preset_edit_as_follows", _) => "Edit as follows:".to_string(),
("preset_extract_table", _) => "Extract Table".to_string(),
("preset_qr_scanner", _) => "QR Scanner".to_string(),
("preset_trans_retrans_typing", _) => "Trans+Retrans (Type)".to_string(),
("preset_ask_ai", _) => "Ask AI".to_string(),
("preset_internet_search", _) => "Internet Search".to_string(),
("preset_make_game", _) => "Make a Game".to_string(),
("preset_transcribe", _) => "Transcribe speech".to_string(),
("preset_fix_pronunciation", _) => "Fix pronunciation".to_string(),
("preset_study_language", _) => "Study language".to_string(),
("preset_transcribe_retranslate", _) => "Quick 4NR reply 1".to_string(),
("preset_quicker_foreigner_reply", _) => "Quick 4NR reply 2".to_string(),
("preset_fact_check", _) => "Fact Check".to_string(),
("preset_omniscient_god", _) => "Omniscient God".to_string(),
("preset_realtime_audio_translate", _) => "Live Translate".to_string(),
("preset_quick_ai_question", _) => "Quick AI Question".to_string(),
("preset_voice_search", _) => "Voice Search".to_string(),
("preset_hang_image", _) => "Image Overlay".to_string(),
("preset_hang_text", _) => "Text Overlay".to_string(),
("preset_quick_note", _) => "Quick Note".to_string(),
("preset_quick_record", _) => "Quick Record".to_string(),
("preset_record_device", _) => "Device Record".to_string(),
("preset_image_master", _) => "Image MASTER".to_string(),
("preset_text_select_master", _) => "Select MASTER".to_string(),
("preset_text_type_master", _) => "Type MASTER".to_string(),
("preset_audio_mic_master", _) => "Mic MASTER".to_string(),
("preset_audio_device_master", _) => "Sound MASTER".to_string(),
‚ãÆ----
.strip_prefix("preset_")
.unwrap_or(preset_id)
.replace('_', " "),
‚ãÆ----
pub fn render_sidebar(
‚ãÆ----
let dragging_source_idx: Option<usize> = ui.memory(|mem| mem.data.get_temp(dragging_idx_id));
‚ãÆ----
for (i, p) in config.presets.iter().enumerate() {
match p.preset_type.as_str() {
"image" => image_indices.push(i),
"text" => text_indices.push(i),
"audio" | "video" => audio_video_indices.push(i),
_ => image_indices.push(i),
‚ãÆ----
let current_view_mode = view_mode.clone();
‚ãÆ----
thread_local! {
‚ãÆ----
ui.horizontal(|ui| {
ui.spacing_mut().item_spacing.x = 8.0;
let is_dark = ui.visuals().dark_mode;
‚ãÆ----
if icon_button_sized(ui, theme_icon, 20.0)
.on_hover_text(tooltip)
.clicked()
‚ãÆ----
let original_lang = config.ui_language.clone();
let lang_flag = match config.ui_language.as_str() {
‚ãÆ----
.width(32.0)
.selected_text(lang_flag)
.show_ui(ui, |ui| {
ui.selectable_value(&mut config.ui_language, "en".to_string(), "üá∫üá∏ English");
ui.selectable_value(&mut config.ui_language, "vi".to_string(), "üáªüá≥ Ti·∫øng Vi·ªát");
ui.selectable_value(&mut config.ui_language, "ko".to_string(), "üá∞üá∑ ÌïúÍµ≠Ïñ¥");
‚ãÆ----
ui.spacing_mut().item_spacing.x = 4.0;
draw_icon_static(ui, Icon::History, None);
let is_history = matches!(current_view_mode, ViewMode::History);
if ui.selectable_label(is_history, text.history_btn).clicked() {
‚ãÆ----
ui.add_space(8.0);
‚ãÆ----
.add(
‚ãÆ----
egui::RichText::new(format!("üéµ {}", text.prompt_dj_btn))
.color(egui::Color32::WHITE),
‚ãÆ----
.fill(egui::Color32::from_rgb(100, 100, 200))
.corner_radius(8.0),
‚ãÆ----
let remaining = (ui.available_width()).max(0.0);
ui.add_space(remaining * 0.9);
‚ãÆ----
egui::RichText::new(format!("‚ùì {}", text.help_assistant_btn))
‚ãÆ----
.fill(help_bg)
‚ãÆ----
.on_hover_text(text.help_assistant_title)
‚ãÆ----
ui.add_space(4.0);
‚ãÆ----
draw_icon_static(ui, Icon::Settings, None);
let is_global = matches!(current_view_mode, ViewMode::Global);
‚ãÆ----
.selectable_label(is_global, text.global_settings)
‚ãÆ----
.iter()
.fold(config.presets.len() as u64, |acc, p| {
acc.wrapping_mul(31).wrapping_add(
p.id.bytes()
.fold(0u64, |h, b| h.wrapping_mul(31).wrapping_add(b as u64)),
‚ãÆ----
let grid_id = egui::Id::new("presets_grid").with(preset_hash);
‚ãÆ----
.num_columns(6)
.spacing([8.0, 4.0])
.min_col_width(67.0)
.show(ui, |ui| {
‚ãÆ----
ui.add(
‚ãÆ----
.color(egui::Color32::WHITE)
.strong(),
‚ãÆ----
.fill(img_bg)
.corner_radius(12.0),
‚ãÆ----
.then(|| preset_to_add_type = Some("image"));
ui.label("");
// Text
‚ãÆ----
.fill(txt_bg)
‚ãÆ----
.then(|| preset_to_add_type = Some("text"));
‚ãÆ----
// Audio
‚ãÆ----
.fill(aud_bg)
‚ãÆ----
.then(|| preset_to_add_type = Some("audio"));
‚ãÆ----
ui.end_row();
// ROW 2+: Preset Items
‚ãÆ----
.len()
.max(text_indices.len())
.max(audio_video_indices.len());
‚ãÆ----
// Column 1&2: Image
if let Some(&idx) = image_indices.get(i) {
render_preset_item_parts(
‚ãÆ----
// Column 3&4: Text
if let Some(&idx) = text_indices.get(i) {
‚ãÆ----
// Column 5&6: Audio
if let Some(&idx) = audio_video_indices.get(i) {
‚ãÆ----
// Update cached grid width for next frame
GRID_WIDTH.with(|w| w.set(grid_response.response.rect.width()));
‚ãÆ----
if let Some(preset) = config.presets.get_mut(idx) {
‚ãÆ----
let mut new_preset = config.presets[idx].clone();
new_preset.id = format!(
‚ãÆ----
let base_name = if config.presets[idx].id.starts_with("preset_") {
get_localized_preset_name(&config.presets[idx].id, &config.ui_language)
‚ãÆ----
new_preset.name.clone()
‚ãÆ----
let mut new_name = format!("{} Copy", base_name);
‚ãÆ----
while config.presets.iter().any(|p| p.name == new_name) {
new_name = format!("{} Copy {}", base_name, counter);
‚ãÆ----
new_preset.hotkeys.clear();
config.presets.push(new_preset);
*view_mode = ViewMode::Preset(config.presets.len() - 1);
‚ãÆ----
config.presets.swap(idx_a, idx_b);
‚ãÆ----
new_preset.preset_type = "text".to_string();
new_preset.name = format!("Text {}", config.presets.len() + 1);
new_preset.text_input_mode = "select".to_string();
if let Some(block) = new_preset.blocks.first_mut() {
block.block_type = "text".to_string();
block.model = "text_accurate_kimi".to_string();
block.prompt = "Translate this text.".to_string();
‚ãÆ----
new_preset.preset_type = "audio".to_string();
new_preset.name = format!("Audio {}", config.presets.len() + 1);
new_preset.audio_source = "mic".to_string();
‚ãÆ----
block.block_type = "audio".to_string();
block.model = "whisper-fast".to_string();
‚ãÆ----
new_preset.name = format!("Image {}", config.presets.len() + 1);
‚ãÆ----
config.presets.remove(idx);
‚ãÆ----
} else if config.presets.is_empty() {
‚ãÆ----
fn render_preset_item_parts(
‚ãÆ----
let display_name = if preset.id.starts_with("preset_") {
get_localized_preset_name(&preset.id, lang)
‚ãÆ----
preset.name.clone()
‚ãÆ----
let is_selected = matches!(current_view_mode, ViewMode::Preset(i) if *i == idx);
let has_hotkey = !preset.hotkeys.is_empty();
let icon_type = match preset.preset_type.as_str() {
‚ãÆ----
ui.set_min_height(22.0);
‚ãÆ----
let rect = ui.available_rect_before_wrap();
‚ãÆ----
ui.painter().rect_filled(rect, 4.0, bg_color);
‚ãÆ----
ui.add_enabled_ui(false, |ui| {
draw_icon_static(ui, icon_type, Some(14.0));
let _ = ui.selectable_label(is_selected, &display_name);
‚ãÆ----
let label_response = ui.selectable_label(is_selected, &display_name);
let response = ui.interact(label_response.rect, label_response.id, egui::Sense::drag());
if label_response.clicked() {
*preset_idx_to_select = Some(idx);
‚ãÆ----
if response.drag_started() {
ui.memory_mut(|mem| mem.data.insert_temp(dragging_id, idx));
‚ãÆ----
if response.dragged() {
ui.ctx().set_cursor_icon(egui::CursorIcon::Grabbing);
‚ãÆ----
if response.drag_stopped() {
ui.memory_mut(|mem| mem.data.remove::<usize>(dragging_id));
‚ãÆ----
if source_idx != idx && response.hovered() && ui.input(|i| i.pointer.any_released())
‚ãÆ----
if get_group(source_preset) == get_group(preset) {
*preset_swap_request = Some((source_idx, idx));
‚ãÆ----
ui.spacing_mut().item_spacing.x = 0.0;
‚ãÆ----
if icon_button_sized(ui, Icon::CopySmall, 22.0).clicked() {
*preset_idx_to_clone = Some(idx);
‚ãÆ----
if icon_button_sized(ui, star_icon, 22.0).clicked() {
*preset_idx_to_toggle_favorite = Some(idx);
‚ãÆ----
if presets.len() > 1 {
if icon_button_sized(ui, Icon::Delete, 22.0).clicked() {
*preset_idx_to_delete = Some(idx);
</file>

<file path="src/overlay/favorite_bubble/panel.rs">
use super::render::update_bubble_visual;
‚ãÆ----
use super::utils::HwndWrapper;
use crate::APP;
use std::sync::atomic::Ordering;
use windows::core::w;
‚ãÆ----
use windows::Win32::Graphics::Gdi::HBRUSH;
use windows::Win32::System::LibraryLoader::GetModuleHandleW;
‚ãÆ----
use windows::Win32::UI::Input::KeyboardAndMouse::SetFocus;
‚ãÆ----
pub fn show_panel(bubble_hwnd: HWND) {
if IS_EXPANDED.load(Ordering::SeqCst) {
‚ãÆ----
let fg = GetForegroundWindow();
if !fg.is_invalid() {
LAST_FOREGROUND_HWND.store(fg.0 as isize, Ordering::SeqCst);
‚ãÆ----
ensure_panel_created(bubble_hwnd, true);
let panel_val = PANEL_HWND.load(Ordering::SeqCst);
‚ãÆ----
let panel_hwnd = HWND(panel_val as *mut std::ffi::c_void);
IS_EXPANDED.store(true, Ordering::SeqCst);
if let Ok(app) = APP.lock() {
‚ãÆ----
refresh_panel_layout_and_content(
‚ãÆ----
update_bubble_visual(bubble_hwnd);
‚ãÆ----
pub fn update_favorites_panel() {
let bubble_val = BUBBLE_HWND.load(Ordering::SeqCst);
‚ãÆ----
let bubble_hwnd = HWND(bubble_val as *mut std::ffi::c_void);
ensure_panel_created(bubble_hwnd, false);
‚ãÆ----
let _ = PostMessageW(Some(panel_hwnd), WM_REFRESH_PANEL, WPARAM(0), LPARAM(0));
‚ãÆ----
pub fn ensure_panel_created(bubble_hwnd: HWND, with_webview: bool) {
let panel_exists = PANEL_HWND.load(Ordering::SeqCst) != 0;
‚ãÆ----
create_panel_window_internal(bubble_hwnd);
‚ãÆ----
let has_webview = PANEL_WEBVIEW.with(|wv| wv.borrow().is_some());
‚ãÆ----
create_panel_webview(panel_hwnd);
‚ãÆ----
pub fn close_panel() {
if !IS_EXPANDED.swap(false, Ordering::SeqCst) {
‚ãÆ----
let webview_exists = PANEL_WEBVIEW.with(|wv| {
if let Some(webview) = wv.borrow().as_ref() {
let _ = webview.evaluate_script("if(window.closePanel) window.closePanel();");
‚ãÆ----
close_panel_internal();
‚ãÆ----
fn close_panel_internal() {
‚ãÆ----
let _ = ShowWindow(panel_hwnd, SW_HIDE);
‚ãÆ----
save_bubble_position();
‚ãÆ----
pub fn destroy_panel() {
let panel_val = PANEL_HWND.swap(0, Ordering::SeqCst);
‚ãÆ----
PANEL_WEBVIEW.with(|wv| {
*wv.borrow_mut() = None;
‚ãÆ----
let _ = DestroyWindow(panel_hwnd);
‚ãÆ----
pub fn move_panel_to_bubble(bubble_x: i32, bubble_y: i32) {
‚ãÆ----
let _ = GetWindowRect(panel_hwnd, &mut panel_rect);
‚ãÆ----
let screen_w = GetSystemMetrics(SM_CXSCREEN);
‚ãÆ----
let _ = SetWindowPos(
‚ãÆ----
panel_y.max(10),
‚ãÆ----
fn create_panel_window_internal(_bubble_hwnd: HWND) {
‚ãÆ----
let instance = GetModuleHandleW(None).unwrap_or_default();
let class_name = w!("SGTFavoritePanel");
REGISTER_PANEL_CLASS.call_once(|| {
‚ãÆ----
lpfnWndProc: Some(panel_wnd_proc),
hInstance: instance.into(),
‚ãÆ----
hCursor: LoadCursorW(None, IDC_ARROW).unwrap_or_default(),
hbrBackground: HBRUSH(std::ptr::null_mut()),
‚ãÆ----
RegisterClassW(&wc);
‚ãÆ----
let panel_hwnd = CreateWindowExW(
‚ãÆ----
w!("FavPanel"),
‚ãÆ----
Some(instance.into()),
‚ãÆ----
.unwrap_or_default();
if !panel_hwnd.is_invalid() {
PANEL_HWND.store(panel_hwnd.0 as isize, Ordering::SeqCst);
‚ãÆ----
unsafe fn refresh_panel_layout_and_content(
‚ãÆ----
let _ = GetWindowRect(bubble_hwnd, &mut bubble_rect);
‚ãÆ----
.iter()
.filter(|p| p.is_favorite && !p.is_upcoming)
.collect();
let fav_count = favs.len();
‚ãÆ----
(PANEL_WIDTH as i32 * 2).max(320)
‚ãÆ----
let panel_height = panel_height.max(50);
‚ãÆ----
let actual_panel_y = panel_y.max(10);
‚ãÆ----
let _ = ShowWindow(panel_hwnd, SW_SHOWNOACTIVATE);
‚ãÆ----
let _ = webview.set_bounds(Rect {
‚ãÆ----
let last_dark = LAST_THEME_IS_DARK.load(Ordering::SeqCst);
‚ãÆ----
let new_css = generate_panel_css(is_dark);
let escaped_css = escape_js(&new_css);
‚ãÆ----
let script = format!(
‚ãÆ----
let _ = webview.evaluate_script(&script);
‚ãÆ----
LAST_THEME_IS_DARK.store(is_dark, Ordering::SeqCst);
‚ãÆ----
let favorites_html = get_favorite_presets_html(presets, lang, is_dark);
update_panel_content(&favorites_html, num_cols);
‚ãÆ----
fn create_panel_webview(panel_hwnd: HWND) {
‚ãÆ----
let _ = GetClientRect(panel_hwnd, &mut rect);
‚ãÆ----
let html = if let Ok(app) = APP.lock() {
‚ãÆ----
generate_panel_html(
‚ãÆ----
let wrapper = HwndWrapper(panel_hwnd);
PANEL_WEB_CONTEXT.with(|ctx| {
if ctx.borrow().is_none() {
‚ãÆ----
*ctx.borrow_mut() = Some(WebContext::new(Some(shared_data_dir)));
‚ãÆ----
let result = PANEL_WEB_CONTEXT.with(|ctx| {
let mut ctx_ref = ctx.borrow_mut();
let builder = if let Some(web_ctx) = ctx_ref.as_mut() {
‚ãÆ----
.with_bounds(Rect {
‚ãÆ----
.with_html(&html)
.with_transparent(true)
.with_ipc_handler(move |msg: wry::http::Request<String>| {
let body = msg.body();
‚ãÆ----
use windows::Win32::UI::Input::KeyboardAndMouse::ReleaseCapture;
let _ = ReleaseCapture();
SendMessageW(
‚ãÆ----
Some(WPARAM(HTCAPTION as usize)),
Some(LPARAM(0)),
‚ãÆ----
close_panel();
‚ãÆ----
} else if body.starts_with("trigger:") {
‚ãÆ----
IS_EXPANDED.store(false, Ordering::SeqCst);
trigger_preset(idx);
‚ãÆ----
} else if body.starts_with("trigger_only:") {
‚ãÆ----
} else if body.starts_with("set_keep_open:") {
‚ãÆ----
if let Ok(mut app) = APP.lock() {
‚ãÆ----
.build_as_child(&wrapper)
‚ãÆ----
*wv.borrow_mut() = Some(webview);
‚ãÆ----
unsafe extern "system" fn panel_wnd_proc(
‚ãÆ----
LRESULT(0)
‚ãÆ----
WM_KILLFOCUS => LRESULT(0),
‚ãÆ----
let bubble_hwnd = HWND(BUBBLE_HWND.load(Ordering::SeqCst) as *mut std::ffi::c_void);
‚ãÆ----
DefWindowProcW(hwnd, msg, wparam, lparam)
‚ãÆ----
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
‚ãÆ----
fn trigger_preset(preset_idx: usize) {
‚ãÆ----
let saved_fg = LAST_FOREGROUND_HWND.load(Ordering::SeqCst);
‚ãÆ----
let fg_hwnd = HWND(saved_fg as *mut std::ffi::c_void);
if !fg_hwnd.is_invalid() {
let _ = SetForegroundWindow(fg_hwnd);
let _ = SetFocus(Some(fg_hwnd));
‚ãÆ----
let class = w!("HotkeyListenerClass");
let title = w!("Listener");
let hwnd = FindWindowW(class, title).unwrap_or_default();
if !hwnd.is_invalid() {
‚ãÆ----
let _ = PostMessageW(Some(hwnd), WM_HOTKEY, WPARAM(hotkey_id as usize), LPARAM(0));
‚ãÆ----
fn save_bubble_position() {
‚ãÆ----
let _ = GetWindowRect(bubble_hwnd, &mut rect);
‚ãÆ----
app.config.favorite_bubble_position = Some((rect.left, rect.top));
‚ãÆ----
fn update_panel_content(html: &str, cols: usize) {
‚ãÆ----
let escaped = escape_js(html);
</file>

<file path="src/main.rs">
mod api;
mod config;
pub mod gui;
mod history;
mod icon_gen;
mod model_config;
mod overlay;
mod updater;
pub mod win_types;
‚ãÆ----
use gui::locale::LocaleText;
use history::HistoryManager;
use lazy_static::lazy_static;
use std::collections::HashMap;
use std::panic;
‚ãÆ----
use windows::Win32::System::Com::CoInitialize;
‚ãÆ----
lazy_static! {
‚ãÆ----
pub struct GdiCapture {
‚ãÆ----
unsafe impl Send for GdiCapture {}
unsafe impl Sync for GdiCapture {}
impl Drop for GdiCapture {
fn drop(&mut self) {
‚ãÆ----
if !self.hbitmap.is_invalid() {
let _ = DeleteObject(self.hbitmap.into());
‚ãÆ----
pub struct AppState {
‚ãÆ----
fn enable_dark_mode_for_app() {
use windows::core::w;
‚ãÆ----
if let Ok(uxtheme) = LoadLibraryW(w!("uxtheme.dll")) {
‚ãÆ----
if let Some(set_preferred_app_mode) = GetProcAddress(uxtheme, proc_name) {
‚ãÆ----
func(ALLOW_DARK);
‚ãÆ----
fn main() -> eframe::Result<()> {
‚ãÆ----
let _ = CoInitialize(None);
‚ãÆ----
enable_dark_mode_for_app();
‚ãÆ----
if let Some(exe_dir) = exe_path.parent() {
let staging_path = exe_dir.join("update_pending.exe");
let backup_path = exe_path.with_extension("exe.old");
if staging_path.exists() {
‚ãÆ----
if std::fs::rename(&staging_path, &exe_path).is_ok() {
‚ãÆ----
let current_exe_name = exe_path.file_name().and_then(|n| n.to_str()).unwrap_or("");
‚ãÆ----
for entry in entries.filter_map(|e| e.ok()) {
let file_name = entry.file_name();
let name_str = file_name.to_string_lossy();
// Delete old ScreenGoatedToolbox_v*.exe files (keep only current)
if (name_str.starts_with("ScreenGoatedToolbox_v") && name_str.ends_with(".exe"))
&& name_str.as_ref() != current_exe_name
‚ãÆ----
let _ = std::fs::remove_file(entry.path());
‚ãÆ----
if name_str.ends_with(".exe.old") {
‚ãÆ----
let location = if let Some(location) = panic_info.location() {
format!("File: {}\nLine: {}", location.file(), location.line())
‚ãÆ----
"Unknown location".to_string()
‚ãÆ----
let payload = if let Some(s) = panic_info.payload().downcast_ref::<&str>() {
s.to_string()
} else if let Some(s) = panic_info.payload().downcast_ref::<String>() {
s.clone()
‚ãÆ----
"Unknown panic payload".to_string()
‚ãÆ----
let error_msg = format!(
‚ãÆ----
let wide_msg: Vec<u16> = error_msg.encode_utf16().chain(std::iter::once(0)).collect();
‚ãÆ----
.encode_utf16()
.chain(std::iter::once(0))
.collect();
‚ãÆ----
MessageBoxW(
‚ãÆ----
PCWSTR(wide_msg.as_ptr()),
PCWSTR(wide_title.as_ptr()),
‚ãÆ----
let _ = RESTORE_EVENT.as_ref();
‚ãÆ----
let instance = CreateMutexW(
‚ãÆ----
w!("Global\\ScreenGoatedToolboxSingleInstanceMutex"),
‚ãÆ----
if GetLastError() == ERROR_ALREADY_EXISTS {
if let Some(event) = RESTORE_EVENT.as_ref() {
let _ = SetEvent(event.0);
‚ãÆ----
let _ = CloseHandle(handle);
return Ok(());
‚ãÆ----
Some(handle)
‚ãÆ----
run_hotkey_listener();
‚ãÆ----
let mut config = APP.lock().unwrap();
‚ãÆ----
wait_for_popup_close();
‚ãÆ----
let initial_config = APP.lock().unwrap().config.clone();
‚ãÆ----
let has_favorites = initial_config.presets.iter().any(|p| p.is_favorite);
‚ãÆ----
let _ = tray_menu.append(&tray_favorite_bubble_item);
let _ = tray_menu.append(&tray_settings_item);
let _ = tray_menu.append(&tray_quit_item);
‚ãÆ----
.with_inner_size([WINDOW_WIDTH, WINDOW_HEIGHT])
.with_resizable(true)
.with_visible(false)
.with_transparent(false)
.with_decorations(true);
‚ãÆ----
viewport_builder = viewport_builder.with_icon(std::sync::Arc::new(icon_data));
‚ãÆ----
*gui::GUI_CONTEXT.lock().unwrap() = Some(cc.egui_ctx.clone());
‚ãÆ----
cc.egui_ctx.set_visuals(eframe::egui::Visuals::dark());
‚ãÆ----
cc.egui_ctx.set_visuals(eframe::egui::Visuals::light());
‚ãÆ----
Ok(Box::new(gui::SettingsApp::new(
‚ãÆ----
APP.clone(),
‚ãÆ----
cc.egui_ctx.clone(),
‚ãÆ----
fn register_all_hotkeys(hwnd: HWND) {
let mut app = APP.lock().unwrap();
‚ãÆ----
for (p_idx, preset) in presets.iter().enumerate() {
for (h_idx, hotkey) in preset.hotkeys.iter().enumerate() {
if [0x04, 0x05, 0x06].contains(&hotkey.code) {
‚ãÆ----
let _ = RegisterHotKey(
Some(hwnd),
‚ãÆ----
HOT_KEY_MODIFIERS(hotkey.modifiers),
‚ãÆ----
registered_ids.push(id);
‚ãÆ----
fn unregister_all_hotkeys(hwnd: HWND) {
let app = APP.lock().unwrap();
‚ãÆ----
let _ = UnregisterHotKey(Some(hwnd), id);
‚ãÆ----
unsafe extern "system" fn mouse_hook_proc(code: i32, wparam: WPARAM, lparam: LPARAM) -> LRESULT {
‚ãÆ----
WM_MBUTTONDOWN => Some(0x04),
‚ãÆ----
Some(0x05)
‚ãÆ----
Some(0x06)
‚ãÆ----
if (GetAsyncKeyState(VK_MENU.0 as i32) as u16 & 0x8000) != 0 {
‚ãÆ----
if (GetAsyncKeyState(VK_CONTROL.0 as i32) as u16 & 0x8000) != 0 {
‚ãÆ----
if (GetAsyncKeyState(VK_SHIFT.0 as i32) as u16 & 0x8000) != 0 {
‚ãÆ----
if (GetAsyncKeyState(VK_LWIN.0 as i32) as u16 & 0x8000) != 0
|| (GetAsyncKeyState(VK_RWIN.0 as i32) as u16 & 0x8000) != 0
‚ãÆ----
if let Ok(app) = APP.lock() {
for (p_idx, preset) in app.config.presets.iter().enumerate() {
‚ãÆ----
found_id = Some((p_idx as i32 * 1000) + (h_idx as i32) + 1);
‚ãÆ----
if found_id.is_some() {
‚ãÆ----
if let Ok(hwnd_target) = LISTENER_HWND.lock() {
if !hwnd_target.0.is_invalid() {
let _ = PostMessageW(
Some(hwnd_target.0),
‚ãÆ----
WPARAM(id as usize),
LPARAM(0),
‚ãÆ----
return LRESULT(1);
‚ãÆ----
CallNextHookEx(None, code, wparam, lparam)
‚ãÆ----
fn run_hotkey_listener() {
‚ãÆ----
let instance = match GetModuleHandleW(None) {
‚ãÆ----
eprintln!("Error: Failed to get module handle for hotkey listener");
‚ãÆ----
let class_name = w!("HotkeyListenerClass");
‚ãÆ----
lpfnWndProc: Some(hotkey_proc),
hInstance: instance.into(),
‚ãÆ----
let _ = RegisterClassW(&wc);
let hwnd = CreateWindowExW(
‚ãÆ----
w!("Listener"),
‚ãÆ----
Some(instance.into()),
‚ãÆ----
.unwrap_or_default();
if hwnd.is_invalid() {
eprintln!("Error: Failed to create hotkey listener window");
‚ãÆ----
if let Ok(mut guard) = LISTENER_HWND.lock() {
*guard = SendHwnd(hwnd);
‚ãÆ----
SetWindowsHookExW(WH_MOUSE_LL, Some(mouse_hook_proc), Some(instance.into()), 0)
‚ãÆ----
if let Ok(mut hook_guard) = MOUSE_HOOK.lock() {
*hook_guard = SendHhook(hhook);
‚ãÆ----
eprintln!("Warning: Failed to install low-level mouse hook");
‚ãÆ----
register_all_hotkeys(hwnd);
‚ãÆ----
if GetMessageW(&mut msg, None, 0, 0).as_bool() {
‚ãÆ----
unregister_all_hotkeys(hwnd);
‚ãÆ----
if let Ok(mut app) = APP.lock() {
‚ãÆ----
let _ = TranslateMessage(&msg);
DispatchMessageW(&msg);
‚ãÆ----
unsafe extern "system" fn hotkey_proc(
‚ãÆ----
return LRESULT(0);
‚ãÆ----
if preset_idx < app.config.presets.len() {
‚ãÆ----
let p_type = p.preset_type.clone();
let t_mode = p.text_input_mode.clone();
‚ãÆ----
let hk_name = if hk_idx < p.hotkeys.len() {
p.hotkeys[hk_idx].name.clone()
‚ãÆ----
"image".to_string(),
"select".to_string(),
‚ãÆ----
app.last_active_window = target_window.map(crate::win_types::SendHwnd);
‚ãÆ----
.load(std::sync::atomic::Ordering::SeqCst);
‚ãÆ----
let config = app.config.clone();
let preset = config.presets[preset_idx].clone();
let screen_w = GetSystemMetrics(SM_CXSCREEN);
let screen_h = GetSystemMetrics(SM_CYSCREEN);
‚ãÆ----
let hotkey_name_clone = hotkey_name.clone();
‚ãÆ----
let app_clone = APP.clone();
‚ãÆ----
std::thread::spawn(move || match capture_screen_fast() {
‚ãÆ----
if let Ok(mut app) = app_clone.lock() {
app.screenshot_handle = Some(capture);
‚ãÆ----
eprintln!("Capture Error: {}", e);
‚ãÆ----
LRESULT(0)
‚ãÆ----
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
‚ãÆ----
fn capture_screen_fast() -> anyhow::Result<GdiCapture> {
‚ãÆ----
let x = GetSystemMetrics(SM_XVIRTUALSCREEN);
let y = GetSystemMetrics(SM_YVIRTUALSCREEN);
let width = GetSystemMetrics(SM_CXVIRTUALSCREEN);
let height = GetSystemMetrics(SM_CYVIRTUALSCREEN);
‚ãÆ----
return Err(anyhow::anyhow!(
‚ãÆ----
let hdc_screen = GetDC(None);
if hdc_screen.is_invalid() {
‚ãÆ----
let hdc_mem = CreateCompatibleDC(Some(hdc_screen));
if hdc_mem.is_invalid() {
let _ = ReleaseDC(None, hdc_screen);
‚ãÆ----
let hbitmap = CreateCompatibleBitmap(hdc_screen, width, height);
if hbitmap.is_invalid() {
let _ = DeleteDC(hdc_mem);
‚ãÆ----
SelectObject(hdc_mem, hbitmap.into());
BitBlt(
‚ãÆ----
Some(hdc_screen),
‚ãÆ----
ReleaseDC(None, hdc_screen);
Ok(GdiCapture {
</file>

<file path="src/overlay/preset_wheel/window.rs">
use crate::config::Preset;
use crate::APP;
use std::cell::RefCell;
‚ãÆ----
use windows::core::w;
‚ãÆ----
use windows::Win32::Graphics::Dwm::DwmExtendFrameIntoClientArea;
‚ãÆ----
use windows::Win32::System::LibraryLoader::GetModuleHandleW;
use windows::Win32::UI::Controls::MARGINS;
‚ãÆ----
thread_local! {
‚ãÆ----
struct HwndWrapper(HWND);
unsafe impl Send for HwndWrapper {}
unsafe impl Sync for HwndWrapper {}
‚ãÆ----
fn window_handle(
‚ãÆ----
std::num::NonZeroIsize::new(self.0 .0 as isize).expect("HWND cannot be null"),
‚ãÆ----
unsafe { Ok(raw_window_handle::WindowHandle::borrow_raw(handle)) }
‚ãÆ----
pub fn warmup() {
// Prevent multiple warmup threads from spawning
‚ãÆ----
.compare_exchange(false, true, Ordering::SeqCst, Ordering::SeqCst)
.is_err()
‚ãÆ----
internal_create_window_loop();
‚ãÆ----
pub fn show_preset_wheel(
‚ãÆ----
// Check if warmed up first
‚ãÆ----
if !IS_WARMED_UP.load(Ordering::SeqCst) {
// Try to trigger warmup for recovery
warmup();
// Show localized message that feature is not ready yet
let ui_lang = APP.lock().unwrap().config.ui_language.clone();
‚ãÆ----
// Wait up to 5 seconds for it to become ready
‚ãÆ----
if IS_WARMED_UP.load(Ordering::SeqCst) {
// It's ready! Proceed to show logic (fall through)
‚ãÆ----
WHEEL_RESULT.store(-1, Ordering::SeqCst);
WHEEL_ACTIVE.store(true, Ordering::SeqCst);
*SELECTED_PRESET.lock().unwrap() = None;
‚ãÆ----
let app = APP.lock().unwrap();
‚ãÆ----
app.config.presets.clone(),
app.config.ui_language.clone(),
‚ãÆ----
let themed_css = generate_css(is_dark);
‚ãÆ----
.iter()
.enumerate()
.filter(|(_, p)| {
‚ãÆ----
.map(|(i, p)| (i, p.clone()))
.collect();
if filtered.is_empty() {
WHEEL_ACTIVE.store(false, Ordering::SeqCst);
‚ãÆ----
let dismiss_label = match ui_lang.as_str() {
‚ãÆ----
let screen_w = GetSystemMetrics(SM_CXSCREEN);
let screen_h = GetSystemMetrics(SM_CYSCREEN);
‚ãÆ----
.max(0)
.min(screen_w - WHEEL_WIDTH);
‚ãÆ----
.min(screen_h - WHEEL_HEIGHT);
let items_html = generate_items_html(&filtered, &ui_lang);
*PENDING_ITEMS_HTML.lock().unwrap() = items_html;
*PENDING_DISMISS_LABEL.lock().unwrap() = dismiss_label.to_string();
*PENDING_CSS.lock().unwrap() = themed_css;
*PENDING_POS.lock().unwrap() = (win_x, win_y);
let hwnd_val = WHEEL_HWND.load(Ordering::SeqCst);
let wheel_hwnd = HWND(hwnd_val as *mut _);
if !wheel_hwnd.is_invalid() {
let _ = PostMessageW(Some(wheel_hwnd), WM_APP_SHOW, WPARAM(0), LPARAM(0));
‚ãÆ----
let res = WHEEL_RESULT.load(Ordering::SeqCst);
‚ãÆ----
if PeekMessageW(&mut msg, None, 0, 0, PM_REMOVE).as_bool() {
let _ = TranslateMessage(&msg);
DispatchMessageW(&msg);
‚ãÆ----
Some(res as usize)
‚ãÆ----
pub fn dismiss_wheel() {
‚ãÆ----
let _ = PostMessageW(Some(wheel_hwnd), WM_APP_HIDE, WPARAM(0), LPARAM(0));
‚ãÆ----
WHEEL_RESULT.store(-2, Ordering::SeqCst);
‚ãÆ----
pub fn is_wheel_active() -> bool {
WHEEL_ACTIVE.load(Ordering::SeqCst)
‚ãÆ----
fn internal_create_window_loop() {
‚ãÆ----
let _ = CoInitialize(None);
let instance = GetModuleHandleW(None).unwrap_or_default();
‚ãÆ----
let overlay_class = w!("SGTWheelOverlayPersistent");
REGISTER_OVERLAY_CLASS.call_once(|| {
‚ãÆ----
lpfnWndProc: Some(overlay_wnd_proc),
hInstance: instance.into(),
‚ãÆ----
hCursor: LoadCursorW(None, IDC_ARROW).unwrap_or_default(),
hbrBackground: HBRUSH(std::ptr::null_mut()),
‚ãÆ----
RegisterClassW(&wc);
‚ãÆ----
let overlay_hwnd = CreateWindowExW(
‚ãÆ----
w!("WheelOverlay"),
‚ãÆ----
Some(instance.into()),
‚ãÆ----
.unwrap_or_default();
OVERLAY_HWND.store(overlay_hwnd.0 as isize, Ordering::SeqCst);
let _ = SetLayeredWindowAttributes(overlay_hwnd, COLORREF(0), 1, LWA_ALPHA);
let class_name = w!("SGTPresetWheelPersistent");
REGISTER_WHEEL_CLASS.call_once(|| {
‚ãÆ----
lpfnWndProc: Some(wheel_wnd_proc),
‚ãÆ----
let hwnd = CreateWindowExW(
‚ãÆ----
w!("PresetWheel"),
‚ãÆ----
let _ = DwmExtendFrameIntoClientArea(hwnd, &margins);
let wrapper = HwndWrapper(hwnd);
WHEEL_WEB_CONTEXT.with(|ctx| {
if ctx.borrow().is_none() {
‚ãÆ----
*ctx.borrow_mut() = Some(WebContext::new(Some(shared_data_dir)));
‚ãÆ----
let webview_res = WHEEL_WEB_CONTEXT.with(|ctx| {
let mut ctx_ref = ctx.borrow_mut();
let builder = if let Some(web_ctx) = ctx_ref.as_mut() {
‚ãÆ----
let template_html = get_wheel_template(true);
‚ãÆ----
.with_transparent(true)
.with_background_color((0, 0, 0, 0))
.with_html(template_html)
.with_bounds(Rect {
‚ãÆ----
.with_ipc_handler(move |msg: wry::http::Request<String>| {
let body = msg.body();
‚ãÆ----
let _ = PostMessageW(
Some(wheel_hwnd),
‚ãÆ----
WPARAM(0),
LPARAM(0),
‚ãÆ----
PostMessageW(Some(wheel_hwnd), WM_APP_HIDE, WPARAM(0), LPARAM(0));
‚ãÆ----
} else if let Some(idx_str) = body.strip_prefix("select:") {
‚ãÆ----
*SELECTED_PRESET.lock().unwrap() = Some(idx);
WHEEL_RESULT.store(idx as i32, Ordering::SeqCst);
‚ãÆ----
.build(&wrapper)
‚ãÆ----
WHEEL_WEBVIEW.with(|cell| {
*cell.borrow_mut() = Some(wv);
‚ãÆ----
let _ = ShowWindow(hwnd, SW_HIDE);
WHEEL_HWND.store(hwnd.0 as isize, Ordering::SeqCst);
IS_WARMING_UP.store(false, Ordering::SeqCst);
IS_WARMED_UP.store(true, Ordering::SeqCst);
‚ãÆ----
let _ = DestroyWindow(hwnd);
let _ = DestroyWindow(overlay_hwnd);
‚ãÆ----
OVERLAY_HWND.store(0, Ordering::SeqCst);
WHEEL_HWND.store(0, Ordering::SeqCst);
let _ = CoUninitialize();
‚ãÆ----
while GetMessageW(&mut msg, None, 0, 0).into() {
‚ãÆ----
*cell.borrow_mut() = None;
‚ãÆ----
unsafe extern "system" fn overlay_wnd_proc(
‚ãÆ----
LRESULT(0)
‚ãÆ----
WM_CLOSE => LRESULT(0),
WM_ERASEBKGND => LRESULT(1),
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
‚ãÆ----
unsafe extern "system" fn wheel_wnd_proc(
‚ãÆ----
let items_html = PENDING_ITEMS_HTML.lock().unwrap().clone();
let dismiss_label = PENDING_DISMISS_LABEL.lock().unwrap().clone();
let themed_css = PENDING_CSS.lock().unwrap().clone();
let _ = SetWindowPos(
‚ãÆ----
Some(HWND_TOPMOST),
‚ãÆ----
WHEEL_WEBVIEW.with(|wv| {
if let Some(webview) = wv.borrow().as_ref() {
‚ãÆ----
.replace("\\", "\\\\")
.replace("`", "\\`")
.replace("$", "\\$");
let css_script = format!(
‚ãÆ----
let _ = webview.evaluate_script(&css_script);
let script = format!(
‚ãÆ----
let _ = webview.evaluate_script(&script);
let _ = webview.set_bounds(Rect {
‚ãÆ----
SetTimer(Some(hwnd), 99, 150, None);
‚ãÆ----
let _ = KillTimer(Some(hwnd), 99);
let (target_x, target_y) = *PENDING_POS.lock().unwrap();
let overlay_val = OVERLAY_HWND.load(Ordering::SeqCst);
let overlay = HWND(overlay_val as *mut _);
if !overlay.is_invalid() {
let _ = ShowWindow(overlay, SW_SHOWNOACTIVATE);
‚ãÆ----
let _ = InvalidateRect(Some(hwnd), None, true);
‚ãÆ----
let _ = PostMessageW(Some(hwnd), WM_APP_REAL_SHOW, WPARAM(0), LPARAM(0));
‚ãÆ----
let _ = ShowWindow(overlay, SW_HIDE);
‚ãÆ----
webview.evaluate_script("document.getElementById('grid').innerHTML = '';");
‚ãÆ----
let _ = PostMessageW(Some(hwnd), WM_APP_HIDE, WPARAM(0), LPARAM(0));
‚ãÆ----
PostQuitMessage(0);
</file>

<file path="src/overlay/prompt_dj/mod.rs">
use std::borrow::Cow;
use std::num::NonZeroIsize;
‚ãÆ----
use windows::Win32::Graphics::Gdi::HBRUSH;
‚ãÆ----
use windows::Win32::System::LibraryLoader::GetModuleHandleW;
use windows::Win32::System::Threading::GetCurrentProcessId;
‚ãÆ----
use crate::win_types::SendHwnd;
‚ãÆ----
static mut PDJ_HWND: SendHwnd = SendHwnd(HWND(std::ptr::null_mut()));
‚ãÆ----
thread_local! {
‚ãÆ----
const INDEX_HTML: &[u8] = include_bytes!("dist/index.html");
const ASSET_INDEX_JS: &[u8] = include_bytes!("dist/assets/index.js");
const ASSET_INDEX_CSS: &[u8] = include_bytes!("dist/assets/index.css");
const ASSET_CUBIC_JS: &[u8] = include_bytes!("dist/assets/cubic.js");
const ASSET_MORPH_JS: &[u8] = include_bytes!("dist/assets/morph-fixed.js");
const ASSET_ROUNDED_JS: &[u8] = include_bytes!("dist/assets/roundedPolygon.js");
const ASSET_UTILS_JS: &[u8] = include_bytes!("dist/assets/utils.js");
‚ãÆ----
fn update_child_pids() {
let current_pid = unsafe { GetCurrentProcessId() };
‚ãÆ----
.args(&["process", "get", "ProcessId,ParentProcessId", "/format:csv"])
.output();
‚ãÆ----
for line in s.lines() {
if line.trim().is_empty() {
‚ãÆ----
let parts: Vec<&str> = line.split(',').collect();
if parts.len() >= 3 {
‚ãÆ----
parts[1].trim().parse::<u32>(),
parts[2].trim().parse::<u32>(),
‚ãÆ----
tree.entry(ppid).or_insert_with(Vec::new).push(pid);
‚ãÆ----
let mut queue = vec![current_pid];
‚ãÆ----
visited.insert(current_pid);
while let Some(pid) = queue.pop() {
if let Some(children) = tree.get(&pid) {
‚ãÆ----
if visited.insert(child) {
descendants.push(child);
queue.push(child);
‚ãÆ----
if let Ok(mut lock) = CHILD_PIDS.lock() {
‚ãÆ----
unsafe fn set_app_volume(volume: f32) -> Result<()> {
let current_pid = GetCurrentProcessId();
let child_pids = CHILD_PIDS.lock().unwrap_or_else(|e| e.into_inner()).clone();
let _ = CoInitializeEx(None, COINIT_APARTMENTTHREADED);
‚ãÆ----
CoCreateInstance(&MMDeviceEnumerator, None, CLSCTX_ALL)?;
let device = device_enumerator.GetDefaultAudioEndpoint(eRender, eMultimedia)?;
let session_manager: IAudioSessionManager2 = device.Activate(CLSCTX_ALL, None)?;
let session_enumerator = session_manager.GetSessionEnumerator()?;
let count = session_enumerator.GetCount()?;
‚ãÆ----
if let Ok(session_control) = session_enumerator.GetSession(i) {
‚ãÆ----
if let Ok(pid) = session_control2.GetProcessId() {
if pid == current_pid || child_pids.contains(&pid) {
‚ãÆ----
let _ = simple_volume.SetMasterVolume(volume, std::ptr::null());
‚ãÆ----
Ok(())
‚ãÆ----
unsafe extern "system" fn pdj_wnd_proc(
‚ãÆ----
let app = crate::APP.lock().unwrap();
‚ãÆ----
app.config.gemini_api_key.clone(),
app.config.ui_language.clone(),
app.config.theme_mode.clone(),
‚ãÆ----
PDJ_WEBVIEW.with(|wv| {
if let Some(webview) = wv.borrow().as_ref() {
let script = format!(
‚ãÆ----
let _ = webview.evaluate_script(&script);
‚ãÆ----
let _ = ShowWindow(hwnd, SW_SHOW);
let _ = SetForegroundWindow(hwnd);
let _ = SetFocus(Some(hwnd));
LRESULT(0)
‚ãÆ----
let _ = ShowWindow(hwnd, SW_HIDE);
‚ãÆ----
PostQuitMessage(0);
‚ãÆ----
WM_ERASEBKGND => LRESULT(1),
‚ãÆ----
DefWindowProcW(hwnd, msg, wparam, lparam)
‚ãÆ----
let _ = GetClientRect(hwnd, &mut r);
‚ãÆ----
let _ = webview.set_bounds(Rect {
‚ãÆ----
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
‚ãÆ----
struct HwndWrapper(HWND);
impl HasWindowHandle for HwndWrapper {
fn window_handle(&self) -> std::result::Result<WindowHandle<'_>, HandleError> {
‚ãÆ----
return Err(HandleError::Unavailable);
‚ãÆ----
Ok(unsafe { WindowHandle::borrow_raw(raw) })
‚ãÆ----
Err(HandleError::Unavailable)
‚ãÆ----
fn wnd_http_response(
‚ãÆ----
.status(status)
.header("Content-Type", content_type)
.header("Access-Control-Allow-Origin", "*")
.body(body)
.unwrap_or_else(|_| {
‚ãÆ----
.status(500)
.body(Cow::Borrowed(b"Internal Error".as_slice()))
.unwrap()
‚ãÆ----
pub fn warmup() {
‚ãÆ----
internal_create_pdj_loop();
‚ãÆ----
pub fn show_prompt_dj() {
‚ãÆ----
// Check if warmed up
‚ãÆ----
// Trigger warmup for recovery
warmup();
// Show localized message that feature is not ready yet
let ui_lang = crate::APP.lock().unwrap().config.ui_language.clone();
‚ãÆ----
// Spawn a thread to wait for warmup and then show
‚ãÆ----
// Check if warmed up (requires unsafe access to static mut, or atomic)
// Since IS_WARMED_UP is static mut, this is unsafe.
// However, we are in unsafe block in show_prompt_dj, but we can't move unsafe execution into thread easily without raw pointer or ensuring safety.
let hwnd_wrapper = std::ptr::addr_of!(PDJ_HWND).read();
‚ãÆ----
if !hwnd_wrapper.is_invalid() && is_warmed {
‚ãÆ----
PostMessageW(Some(hwnd_wrapper.0), WM_APP_SHOW, WPARAM(0), LPARAM(0));
‚ãÆ----
if !std::ptr::addr_of!(PDJ_HWND).read().is_invalid() {
let _ = PostMessageW(Some(PDJ_HWND.0), WM_APP_SHOW, WPARAM(0), LPARAM(0));
‚ãÆ----
pub fn update_settings() {
‚ãÆ----
let _ = PostMessageW(
Some(PDJ_HWND.0),
‚ãÆ----
WPARAM(0),
LPARAM(0),
‚ãÆ----
unsafe fn internal_create_pdj_loop() {
let instance = GetModuleHandleW(None).unwrap();
let class_name = w!("PromptDJ_Class_Persistent");
REGISTER_PDJ_CLASS.call_once(|| {
‚ãÆ----
wc.lpfnWndProc = Some(pdj_wnd_proc);
wc.hInstance = instance.into();
‚ãÆ----
wc.hCursor = LoadCursorW(None, IDC_ARROW).unwrap();
wc.hbrBackground = HBRUSH(std::ptr::null_mut());
let _ = RegisterClassW(&wc);
‚ãÆ----
let screen_w = GetSystemMetrics(SM_CXSCREEN);
let screen_h = GetSystemMetrics(SM_CYSCREEN);
‚ãÆ----
let hwnd = CreateWindowExW(
‚ãÆ----
PCWSTR(title_wide.as_ptr()),
‚ãÆ----
Some(instance.into()),
‚ãÆ----
.unwrap();
PDJ_HWND = SendHwnd(hwnd);
‚ãÆ----
let _ = DwmSetWindowAttribute(
‚ãÆ----
let wrapper = HwndWrapper(hwnd);
‚ãÆ----
let init_script = format!(
‚ãÆ----
PDJ_WEB_CONTEXT.with(|ctx| {
if ctx.borrow().is_none() {
‚ãÆ----
*ctx.borrow_mut() = Some(WebContext::new(Some(shared_data_dir)));
‚ãÆ----
let webview_result = PDJ_WEB_CONTEXT.with(|ctx| {
let mut ctx_ref = ctx.borrow_mut();
let builder = WebViewBuilder::new_with_web_context(ctx_ref.as_mut().unwrap())
.with_custom_protocol("promptdj".to_string(), move |_id, request| {
let path = request.uri().path();
‚ãÆ----
} else if path.ends_with("index.js") {
‚ãÆ----
} else if path.ends_with("index.css") {
‚ãÆ----
} else if path.ends_with("cubic.js") {
‚ãÆ----
} else if path.ends_with("morph-fixed.js") {
‚ãÆ----
} else if path.ends_with("roundedPolygon.js") {
‚ãÆ----
} else if path.ends_with("utils.js") {
‚ãÆ----
return wnd_http_response(
‚ãÆ----
Cow::Borrowed(b"Not Found".as_slice()),
‚ãÆ----
wnd_http_response(200, mime, content)
‚ãÆ----
.with_initialization_script(&init_script)
.with_ipc_handler(move |msg: wry::http::Request<String>| {
let body = msg.body().as_str();
‚ãÆ----
let _ = ReleaseCapture();
‚ãÆ----
let _ = SendMessageW(
‚ãÆ----
Some(WPARAM(HTCAPTION as usize)),
Some(LPARAM(0)),
‚ãÆ----
let _ = ShowWindow(hwnd_ipc, SW_MINIMIZE);
‚ãÆ----
let _ = ShowWindow(hwnd_ipc, SW_HIDE);
‚ãÆ----
} else if body.starts_with("set_volume:") {
if let Ok(val) = body.trim_start_matches("set_volume:").parse::<f32>() {
‚ãÆ----
let _ = set_app_volume(val);
‚ãÆ----
.with_url("promptdj://localhost/index.html");
builder.build_as_child(&wrapper)
‚ãÆ----
eprintln!("Failed to create PromptDJ WebView: {:?}", e);
let _ = DestroyWindow(hwnd);
‚ãÆ----
let _ = webview_arc.set_bounds(Rect {
‚ãÆ----
*wv.borrow_mut() = Some(webview_arc);
‚ãÆ----
update_child_pids();
‚ãÆ----
while GetMessageW(&mut msg, None, 0, 0).as_bool() {
let _ = TranslateMessage(&msg);
let _ = DispatchMessageW(&msg);
‚ãÆ----
*wv.borrow_mut() = None;
</file>

<file path="src/overlay/tray_popup.rs">
use crate::APP;
use std::cell::RefCell;
‚ãÆ----
use windows::core::w;
‚ãÆ----
use windows::Win32::System::LibraryLoader::GetModuleHandleW;
‚ãÆ----
thread_local! {
‚ãÆ----
fn get_scaled_dimension(base: i32) -> i32 {
‚ãÆ----
struct HwndWrapper(HWND);
unsafe impl Send for HwndWrapper {}
unsafe impl Sync for HwndWrapper {}
‚ãÆ----
fn window_handle(
‚ãÆ----
std::num::NonZeroIsize::new(self.0 .0 as isize).expect("HWND cannot be null"),
‚ãÆ----
unsafe { Ok(raw_window_handle::WindowHandle::borrow_raw(handle)) }
‚ãÆ----
/// Show the tray popup at cursor position
pub fn show_tray_popup() {
‚ãÆ----
pub fn show_tray_popup() {
// Check if currently warming up (state 1) - try recovery
let current = POPUP_STATE.load(Ordering::SeqCst);
‚ãÆ----
// Still warming up - reset state to 0 and retry warmup
POPUP_STATE.store(0, Ordering::SeqCst);
warmup_tray_popup();
// Show loading notification
let ui_lang = APP.lock().unwrap().config.ui_language.clone();
‚ãÆ----
// Spawn thread to wait for warmup completion
‚ãÆ----
// Check if ready (State 2)
if POPUP_STATE.load(Ordering::SeqCst) == 2 {
// Check HWND
let hwnd_val = POPUP_HWND.load(Ordering::SeqCst);
‚ãÆ----
// Post Show Message or call show logic?
// Logic below shows use of WM_APP_SHOW or SetWindowPos.
// TrayPopup logic is complex, it calculates position.
// But we can trigger the show by calling show_tray_popup() again?
// Calling show_tray_popup() again from another thread is fine as it uses atomics.
// However, show_tray_popup() calculates position based on cursor which might have moved.
// Assume user wants it where the cursor NOW is (or was).
// Let's just call show_tray_popup() again.
show_tray_popup();
‚ãÆ----
let hwnd = HWND(hwnd_val as *mut std::ffi::c_void);
let is_valid = unsafe { windows::Win32::UI::WindowsAndMessaging::IsWindow(Some(hwnd)).as_bool() };
‚ãÆ----
POPUP_HWND.store(0, Ordering::SeqCst);
‚ãÆ----
hide_tray_popup();
‚ãÆ----
let prev = POPUP_STATE.swap(2, Ordering::SeqCst);
‚ãÆ----
create_popup_window(false);
‚ãÆ----
pub fn hide_tray_popup() {
if POPUP_STATE.load(Ordering::SeqCst) == 0 {
‚ãÆ----
let _ = PostMessageW(Some(hwnd), WM_CLOSE, WPARAM(0), LPARAM(0));
‚ãÆ----
POPUP_STATE.store(3, Ordering::SeqCst);
‚ãÆ----
pub fn warmup_tray_popup() {
if POPUP_STATE.compare_exchange(0, 1, Ordering::SeqCst, Ordering::SeqCst).is_ok() {
‚ãÆ----
create_popup_window(true);
‚ãÆ----
pub fn is_popup_open() -> bool {
POPUP_STATE.load(Ordering::SeqCst) == 2
‚ãÆ----
fn generate_popup_html() -> String {
use crate::config::ThemeMode;
let (settings_text, bubble_text, stop_tts_text, quit_text, bubble_checked, is_dark_mode) = if let Ok(app) = APP.lock() {
‚ãÆ----
let settings = match lang.as_str() {
‚ãÆ----
let bubble = match lang.as_str() {
‚ãÆ----
let stop_tts = match lang.as_str() {
‚ãÆ----
let quit = match lang.as_str() {
‚ãÆ----
let has_tts_pending = crate::api::tts::TTS_MANAGER.has_pending_audio();
‚ãÆ----
format!(
‚ãÆ----
// RAII Guard to ensure state reset
struct StateGuard;
impl Drop for StateGuard {
fn drop(&mut self) {
POPUP_ACTIVE_REF.store(0, Ordering::SeqCst);
POPUP_HWND_REF.store(0, Ordering::SeqCst);
// Also ensure WebView is dropped on thread exit which helps with cleanup
POPUP_WEBVIEW.with(|cell| {
*cell.borrow_mut() = None;
‚ãÆ----
// Accessors for Guard since it can't capture statics directly easily in Drop if they aren't accessible
// Actually statics are global so we can just use them.
// But to be clean we'll just refer to the statics in the Drop impl logic (which refers to global names).
// Wait, Drop implementation cannot capture 'self' context easily for statics unless I put them in a struct.
// But POPUP_STATE is static. I can access it directly.
// We need to define safe access or just use the statics.
// Since `POPUP_STATE` is static, we can access it.
‚ãÆ----
fn create_popup_window(is_warmup: bool) {
let _guard = StateGuard; // Will reset state to 0 on exit/panic
‚ãÆ----
let instance = GetModuleHandleW(None).unwrap_or_default();
let class_name = w!("SGTTrayPopup");
REGISTER_POPUP_CLASS.call_once(|| {
‚ãÆ----
lpfnWndProc: Some(popup_wnd_proc),
hInstance: instance.into(),
‚ãÆ----
hCursor: LoadCursorW(None, IDC_ARROW).unwrap_or_default(),
hbrBackground: HBRUSH(std::ptr::null_mut()),
‚ãÆ----
RegisterClassW(&wc);
‚ãÆ----
let popup_height = get_scaled_dimension(BASE_POPUP_HEIGHT);
let popup_width = get_scaled_dimension(BASE_POPUP_WIDTH);
‚ãÆ----
let _ = GetCursorPos(&mut pt);
let screen_w = GetSystemMetrics(SM_CXSCREEN);
let screen_h = GetSystemMetrics(SM_CYSCREEN);
let popup_x = (pt.x - popup_width / 2).max(0).min(screen_w - popup_width);
‚ãÆ----
.max(0)
.min(screen_h - popup_height);
‚ãÆ----
let hwnd = CreateWindowExW(
‚ãÆ----
w!("TrayPopup"),
‚ãÆ----
Some(instance.into()),
‚ãÆ----
.unwrap_or_default();
if hwnd.is_invalid() {
‚ãÆ----
POPUP_HWND.store(hwnd.0 as isize, Ordering::SeqCst);
‚ãÆ----
let _ = DwmSetWindowAttribute(
‚ãÆ----
let wrapper = HwndWrapper(hwnd);
let html = generate_popup_html();
POPUP_WEB_CONTEXT.with(|ctx| {
if ctx.borrow().is_none() {
‚ãÆ----
*ctx.borrow_mut() = Some(WebContext::new(Some(shared_data_dir)));
‚ãÆ----
let webview = POPUP_WEB_CONTEXT.with(|ctx| {
let mut ctx_ref = ctx.borrow_mut();
let builder = if let Some(web_ctx) = ctx_ref.as_mut() {
‚ãÆ----
.with_bounds(Rect {
‚ãÆ----
.with_transparent(true)
.with_html(&html)
.with_ipc_handler(move |msg: wry::http::Request<String>| {
let body = msg.body();
match body.as_str() {
‚ãÆ----
let h = POPUP_HWND.load(Ordering::SeqCst);
‚ãÆ----
let _ = PostMessageW(
Some(HWND(h as *mut _)),
‚ãÆ----
WPARAM(0),
LPARAM(0),
‚ãÆ----
let new_state = if let Ok(mut app) = APP.lock() {
‚ãÆ----
if let Some(webview) = cell.borrow().as_ref() {
let js = format!(
‚ãÆ----
let _ = webview.evaluate_script(&js);
‚ãÆ----
crate::api::tts::TTS_MANAGER.stop();
‚ãÆ----
.build(&wrapper)
‚ãÆ----
*cell.borrow_mut() = Some(wv);
‚ãÆ----
let current_state = POPUP_STATE.load(Ordering::SeqCst);
‚ãÆ----
let popup_y = (pt.y - popup_height - 10).max(0).min(screen_h - popup_height);
let _ = SetWindowPos(hwnd, None, popup_x, popup_y, popup_width, popup_height, SWP_NOZORDER);
let _ = ShowWindow(hwnd, SW_SHOW);
let _ = SetForegroundWindow(hwnd);
let _ = SetTimer(Some(hwnd), 888, 100, None);
‚ãÆ----
while GetMessageW(&mut msg, None, 0, 0).into() {
let _ = TranslateMessage(&msg);
DispatchMessageW(&msg);
‚ãÆ----
unsafe extern "system" fn popup_wnd_proc(
‚ãÆ----
LRESULT(0)
‚ãÆ----
let fg = GetForegroundWindow();
let root = GetAncestor(fg, GA_ROOT);
‚ãÆ----
return LRESULT(0);
‚ãÆ----
if now > IGNORE_FOCUS_LOSS_UNTIL.load(Ordering::SeqCst) {
let _ = KillTimer(Some(hwnd), 888);
‚ãÆ----
let _ = DestroyWindow(hwnd);
‚ãÆ----
PostQuitMessage(0);
‚ãÆ----
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
</file>

<file path="src/gui/locale.rs">
pub struct LocaleText {
‚ãÆ----
pub preset_type_text: &'static str, // NEW
‚ãÆ----
// --- NEW TEXT INPUT FIELDS ---
‚ãÆ----
pub continuous_input_label: &'static str, // Checkbox for continuous input mode
‚ãÆ----
// --- COMPOUND SEARCH UI ---
‚ãÆ----
pub search_searching: &'static str,        // "searching" / "t√¨m ki·∫øm"
‚ãÆ----
pub search_found_sources: &'static str,    // "FOUND {} SOURCES" / "ƒê√É T√åM TH·∫§Y {} NGU·ªíN"
‚ãÆ----
pub search_no_title: &'static str,      // "(No title)" / "(Kh√¥ng c√≥ ti√™u ƒë·ªÅ)"
‚ãÆ----
pub search_analyzed_sources: &'static str, // "Analyzed {} sources" / "ƒê√£ ph√¢n t√≠ch {} ngu·ªìn"
‚ãÆ----
pub controller_checkbox_label: &'static str, // "B·ªô ƒëi·ªÅu khi·ªÉn" / "Controller" / "Ïª®Ìä∏Î°§Îü¨"
// --- GLOBAL SETTINGS UI HEADERS ---
‚ãÆ----
// --- MODEL THINKING INDICATOR ---
‚ãÆ----
// App selection modal
‚ãÆ----
// --- TRAY MENU ---
‚ãÆ----
// --- FAVORITE BUBBLE ---
‚ãÆ----
// --- AUTO COPY BADGE ---
‚ãÆ----
// --- DROP OVERLAY ---
‚ãÆ----
impl LocaleText {
pub fn get(lang_code: &str) -> Self {
‚ãÆ----
tips_list: vec![
‚ãÆ----
tts_preview_texts: vec![
</file>

</files>
